{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\udc18 Probo UI A Python-Native Template Rendering Framework and Meta-framework for Django. Write Type-Safe HTML, CSS, and Logic in pure Python. No context switching. No template spaghetti. \ud83d\udce3 Version 1.1.1 is Live! Probo UI has officially reached stable v1 status. It is a backend-first framework that transforms Python objects into performant HTML/CSS, creating a seamless bridge between Django's backend logic and the frontend interface. \ud83d\udcda Read the Full Sample Documentation (v1.0) Click the link above for deep dives into : view sample documentation The Component Architecture: Brain (State) / Body (Elements) / Skin (Style). Shortcuts for building complex UIs. Probo Forms: Automatic Django Form rendering. JIT Styling: How the CSS engine works. \u26a1 Purpose & Philosophy Traditional Django development often requires context-switching between Python (views.py) and HTML/Jinja (templates/). Logic gets split, and typos in templates cause runtime errors. Probo UI solves this by bringing the Frontend into Python: \ud83e\udde0 Type-Safe UI: Write HTML in Python. If your code compiles, your HTML is valid. \ud83c\udfa8 Just-In-Time (JIT) CSS: Styles live with components. Probo UI scans your active components and generates a minified CSS bundle on the fly. No unused styles. \ud83d\udee1\ufe0f Logic Gates: Built-in State Management. Components automatically hide themselves if required data (like user.is_authenticated) or permissions are missing. \ud83d\udd0c Django Native: Deep integration with Django Forms and Requests via the RDT (Request Data Transformer). \ud83d\udce6 Installation pip install probo-ui \ud83d\ude80 Quick Example Here is how you build a reusable, styled component using the Flow API: def user_card(username): # 1. Define Logic (The Brain) # \"Look for 'name' in dynamic data. If missing, don't render.\" user_id = 'User_789xyz1323' user_info = {'practical-info':['python','javascript','docker','django']} li_el = ElementState('li', d_state='practical-info',i_state=True, strict_dynamic=True,) user_comp_state = ComponentState( d_data=user_info, li_el, ) # 2. Build Component (Structure + Style + Data) card = Component( name=\"UserCard\", template=f\"<div class='card'>{h1(username,strong(user_id))+ul(li_el.placeholder)}</div>\", # Inject Data state=user_comp_state, ) return card # Render it html= user_card(\"Admin\").render() print(html) # Output: # <div class='card'><h1>Admin<strong>User_789xyz1323</strong></h1><ul><li>python</li><li>javascript</li><li>docker</li><li>django</li></ul></div> \ud83d\udcac Community & Support Need help? Have a question that isn't a bug? Join our Discord Server to chat with other probo-ui developers.","title":"Home"},{"location":"#probo-ui","text":"A Python-Native Template Rendering Framework and Meta-framework for Django. Write Type-Safe HTML, CSS, and Logic in pure Python. No context switching. No template spaghetti.","title":"\ud83d\udc18 Probo UI"},{"location":"#version-111-is-live","text":"Probo UI has officially reached stable v1 status. It is a backend-first framework that transforms Python objects into performant HTML/CSS, creating a seamless bridge between Django's backend logic and the frontend interface.","title":"\ud83d\udce3 Version 1.1.1 is Live!"},{"location":"#read-the-full-sample-documentation-v10","text":"","title":"\ud83d\udcda Read the Full Sample Documentation (v1.0)"},{"location":"#click-the-link-above-for-deep-dives-into-view-sample-documentation","text":"The Component Architecture: Brain (State) / Body (Elements) / Skin (Style). Shortcuts for building complex UIs. Probo Forms: Automatic Django Form rendering. JIT Styling: How the CSS engine works.","title":"Click the link above for deep dives into : view sample documentation"},{"location":"#purpose-philosophy","text":"Traditional Django development often requires context-switching between Python (views.py) and HTML/Jinja (templates/). Logic gets split, and typos in templates cause runtime errors. Probo UI solves this by bringing the Frontend into Python: \ud83e\udde0 Type-Safe UI: Write HTML in Python. If your code compiles, your HTML is valid. \ud83c\udfa8 Just-In-Time (JIT) CSS: Styles live with components. Probo UI scans your active components and generates a minified CSS bundle on the fly. No unused styles. \ud83d\udee1\ufe0f Logic Gates: Built-in State Management. Components automatically hide themselves if required data (like user.is_authenticated) or permissions are missing. \ud83d\udd0c Django Native: Deep integration with Django Forms and Requests via the RDT (Request Data Transformer).","title":"\u26a1 Purpose &amp; Philosophy"},{"location":"#installation","text":"pip install probo-ui","title":"\ud83d\udce6 Installation"},{"location":"#quick-example","text":"Here is how you build a reusable, styled component using the Flow API: def user_card(username): # 1. Define Logic (The Brain) # \"Look for 'name' in dynamic data. If missing, don't render.\" user_id = 'User_789xyz1323' user_info = {'practical-info':['python','javascript','docker','django']} li_el = ElementState('li', d_state='practical-info',i_state=True, strict_dynamic=True,) user_comp_state = ComponentState( d_data=user_info, li_el, ) # 2. Build Component (Structure + Style + Data) card = Component( name=\"UserCard\", template=f\"<div class='card'>{h1(username,strong(user_id))+ul(li_el.placeholder)}</div>\", # Inject Data state=user_comp_state, ) return card # Render it html= user_card(\"Admin\").render() print(html) # Output: # <div class='card'><h1>Admin<strong>User_789xyz1323</strong></h1><ul><li>python</li><li>javascript</li><li>docker</li><li>django</li></ul></div> \ud83d\udcac Community & Support Need help? Have a question that isn't a bug? Join our Discord Server to chat with other probo-ui developers.","title":"\ud83d\ude80 Quick Example"},{"location":"simple_doc/","text":"Probo UI (PUI) v1.1.0 Documentation Probo allows you to build type-safe, server-side rendered HTML components in Python with built-in state management and JIT CSS generation. 1. Basic HTML Generation (Functional API) The simplest way to use Probo is through its functional tags. This replaces writing raw HTML strings. Goal: Create the \"Logo Section\" from your example. from probo import div, img, h2, span def logo_component(): return div( img( src=\"./user/Images/logo.jpg\", alt=\"logo\", width=\"80px\", ), h2( span(\"CLUB\"), \"BAC\", ), Class=\"log_logo\", ) # Render to string print(logo_component()) Output: <div class=\"log_logo\"> <img src=\"./user/Images/logo.jpg\" alt=\"logo\" width=\"80px\" /> <h2><span>CLUB</span>BAC</h2> </div> 2. The Component Class (Static) For reusable UI parts, use the Component class. This allows you to manage templates and CSS boundaries. Goal: Create the \"Sign Up Form\" container. from probo.components.component import Component from probo import div, form, h2, Input, button # 1. Define the internal structure (template) # The template is built using functional HTML helpers def signup_template(): return form( h2(\"Sign Up\"), # Name fields div( Input(type=\"text\", placeholder=\"First Name\", required=True), Input(type=\"text\", placeholder=\"Last Name\", required=True), Class=\"input-box1\", ), # Submit button button( \"Sign Up\", type=\"submit\", Class=\"btn\", onclick=\"login()\", ), ) # 2. Create the Component # The template is passed as rendered HTML signup_comp = Component( name=\"SignUpCard\", template=signup_template(), ) # 3. Set a root element (optional) signup_comp.set_root_element( \"div\", Class=\"sign\", ) # 4. Render html = signup_comp.render() print(html) 3. Adding State (Dynamic Components) Probo Components become powerful when you add State. This allows you to inject data dynamically without string formatting hacks. Goal: Make the \"Welcome\" header dynamic. Step 1: Define Element State ElementState is used to create smart placeholders inside templates. During rendering, each placeholder is replaced with data resolved from the component state. from probo.components.state import ElementState from probo import h1, span # 1. Define Element States # Resolve value from static state (s_data[\"club_name\"]) es_club_name = ElementState( \"span\", s_state=\"club_name\", Class=\"highlight\", ) # Resolve value from dynamic state (d_data[\"welcome_msg\"]) # If missing, the element will not be rendered es_message = ElementState( \"h1\", d_state=\"welcome_msg\", strict_dynamic=True, ) # Resolve value using both static and dynamic state # Priority: d_state > s_state # If strict_dynamic=True and d_state is missing, the element is skipped es_message_both = ElementState( \"h1\", s_state=\"welcome_fallback\", d_state=\"welcome_override\", strict_dynamic=True, ) Step 2: Create Component State The ComponentState acts as the \"brain\" of the component. It holds static and dynamic data and resolves which values are injected into each ElementState during rendering. from probo.components.state import ComponentState # 2. Define Component State state = ComponentState( # Register ElementState instances es_club_name, es_message, es_message_both, # Static Data (Defaults / Fallbacks) s_data={ \"club_name\": \"The Biologists in Action Club\", }, # Dynamic Data (e.g. from a view or database) d_data={ \"welcome_msg\": \"Jack the admin says: Welcome !!\", }, ) Step 3: Wire it Together We construct the template using placeholders generated by ElementState . Each ElementState.placeholder is replaced with resolved data during render. from probo.components.component import Component from probo.components.state import ElementState, ComponentState from probo import section # 1. Define Element States es_message = ElementState( \"h1\", d_state=\"welcome_msg\", strict_dynamic=True, ) es_message_both = ElementState( \"h1\", s_state=\"welcome_fallback\", d_state=\"welcome_override\", strict_dynamic=True, ) es_club_name = ElementState( \"span\", s_state=\"club_name\", Class=\"highlight\", ) # 2. Create Component State (data + element bindings) state = ComponentState( es_message, es_message_both, es_club_name, s_data={ \"club_name\": \"The Biologists in Action Club\", \"welcome_fallback\": \"Welcome!\", }, d_data={ \"welcome_msg\": \"Jack the admin says: Welcome !!\", }, ) # 3. Build Template using placeholders template_str = section( es_message.placeholder, es_message_both.placeholder, es_club_name.placeholder, Class=\"page\", ) # 4. Initialize Component page_component = Component( name=\"HomePage\", template=template_str, state=state, ) # 5. Render html = page_component.render() print(html) 4. Styling (JIT CSS) Styling support in Probo UI is currently experimental and not yet connected to the HTML rendering pipeline . While low-level CSS building blocks such as CssRule exist, they are not automatically injected into the rendered output of Component or Template . As a result, CSS rules defined in Python are not applied to the final HTML at this stage. from probo.styles.plain_css import CssRule # CssRule objects represent validated CSS declarations btn_style = CssRule( background_color=\"blue\", color=\"white\", ) input_style = CssRule( padding=\"40px\", margin_bottom=\"10px\", ) # Note: # These rules are currently not applied automatically during render. # Styling APIs are under active development. 5. Full Architecture Example (The \"shortcut\") For the best developer experience, use the shortcut to wire everything in one go. from probo.shortcuts import ( component, ComponentConfig, StateConfig, StyleConfig, ElementStateConfig ) from probo import div, form def build_signup_page(): # 1. Logic title_state = ElementStateConfig( tag='h2', s_state='form_title', ) state_config = StateConfig( s_data={ 'form_title': 'Join the Club', }, elements_state_config=[ title_state, ], ) # 2. Style style_config = StyleConfig( css = { '.sign': { 'background': '#fff', 'padding': '2px', }, # Since no input element exists in the template, # this rule will be skipped automatically 'input': { 'width': '100%', 'padding': '10px', }, } ) # 3. Component Configuration config = ComponentConfig( name=\"SignUpPage\", template=div( title_state.config_id, form('some form'), Class=\"sign\", ), state_config=state_config, style_config=style_config, ) # 4. Build Component return component(config) print(build_signup_page()) ( '<div class=\"sign\"><form>some form</form></div>', '.sign { background:#fff; padding:2px; }' )","title":"Probo UI (PUI) v1.1.0 Documentation"},{"location":"simple_doc/#probo-ui-pui-v110-documentation","text":"Probo allows you to build type-safe, server-side rendered HTML components in Python with built-in state management and JIT CSS generation.","title":"Probo UI (PUI) v1.1.0 Documentation"},{"location":"simple_doc/#1-basic-html-generation-functional-api","text":"The simplest way to use Probo is through its functional tags. This replaces writing raw HTML strings. Goal: Create the \"Logo Section\" from your example. from probo import div, img, h2, span def logo_component(): return div( img( src=\"./user/Images/logo.jpg\", alt=\"logo\", width=\"80px\", ), h2( span(\"CLUB\"), \"BAC\", ), Class=\"log_logo\", ) # Render to string print(logo_component()) Output: <div class=\"log_logo\"> <img src=\"./user/Images/logo.jpg\" alt=\"logo\" width=\"80px\" /> <h2><span>CLUB</span>BAC</h2> </div>","title":"1. Basic HTML Generation (Functional API)"},{"location":"simple_doc/#2-the-component-class-static","text":"For reusable UI parts, use the Component class. This allows you to manage templates and CSS boundaries. Goal: Create the \"Sign Up Form\" container. from probo.components.component import Component from probo import div, form, h2, Input, button # 1. Define the internal structure (template) # The template is built using functional HTML helpers def signup_template(): return form( h2(\"Sign Up\"), # Name fields div( Input(type=\"text\", placeholder=\"First Name\", required=True), Input(type=\"text\", placeholder=\"Last Name\", required=True), Class=\"input-box1\", ), # Submit button button( \"Sign Up\", type=\"submit\", Class=\"btn\", onclick=\"login()\", ), ) # 2. Create the Component # The template is passed as rendered HTML signup_comp = Component( name=\"SignUpCard\", template=signup_template(), ) # 3. Set a root element (optional) signup_comp.set_root_element( \"div\", Class=\"sign\", ) # 4. Render html = signup_comp.render() print(html)","title":"2. The Component Class (Static)"},{"location":"simple_doc/#3-adding-state-dynamic-components","text":"Probo Components become powerful when you add State. This allows you to inject data dynamically without string formatting hacks. Goal: Make the \"Welcome\" header dynamic.","title":"3. Adding State (Dynamic Components)"},{"location":"simple_doc/#step-1-define-element-state","text":"ElementState is used to create smart placeholders inside templates. During rendering, each placeholder is replaced with data resolved from the component state. from probo.components.state import ElementState from probo import h1, span # 1. Define Element States # Resolve value from static state (s_data[\"club_name\"]) es_club_name = ElementState( \"span\", s_state=\"club_name\", Class=\"highlight\", ) # Resolve value from dynamic state (d_data[\"welcome_msg\"]) # If missing, the element will not be rendered es_message = ElementState( \"h1\", d_state=\"welcome_msg\", strict_dynamic=True, ) # Resolve value using both static and dynamic state # Priority: d_state > s_state # If strict_dynamic=True and d_state is missing, the element is skipped es_message_both = ElementState( \"h1\", s_state=\"welcome_fallback\", d_state=\"welcome_override\", strict_dynamic=True, )","title":"Step 1: Define Element State"},{"location":"simple_doc/#step-2-create-component-state","text":"The ComponentState acts as the \"brain\" of the component. It holds static and dynamic data and resolves which values are injected into each ElementState during rendering. from probo.components.state import ComponentState # 2. Define Component State state = ComponentState( # Register ElementState instances es_club_name, es_message, es_message_both, # Static Data (Defaults / Fallbacks) s_data={ \"club_name\": \"The Biologists in Action Club\", }, # Dynamic Data (e.g. from a view or database) d_data={ \"welcome_msg\": \"Jack the admin says: Welcome !!\", }, )","title":"Step 2: Create Component State"},{"location":"simple_doc/#step-3-wire-it-together","text":"We construct the template using placeholders generated by ElementState . Each ElementState.placeholder is replaced with resolved data during render. from probo.components.component import Component from probo.components.state import ElementState, ComponentState from probo import section # 1. Define Element States es_message = ElementState( \"h1\", d_state=\"welcome_msg\", strict_dynamic=True, ) es_message_both = ElementState( \"h1\", s_state=\"welcome_fallback\", d_state=\"welcome_override\", strict_dynamic=True, ) es_club_name = ElementState( \"span\", s_state=\"club_name\", Class=\"highlight\", ) # 2. Create Component State (data + element bindings) state = ComponentState( es_message, es_message_both, es_club_name, s_data={ \"club_name\": \"The Biologists in Action Club\", \"welcome_fallback\": \"Welcome!\", }, d_data={ \"welcome_msg\": \"Jack the admin says: Welcome !!\", }, ) # 3. Build Template using placeholders template_str = section( es_message.placeholder, es_message_both.placeholder, es_club_name.placeholder, Class=\"page\", ) # 4. Initialize Component page_component = Component( name=\"HomePage\", template=template_str, state=state, ) # 5. Render html = page_component.render() print(html)","title":"Step 3: Wire it Together"},{"location":"simple_doc/#4-styling-jit-css","text":"Styling support in Probo UI is currently experimental and not yet connected to the HTML rendering pipeline . While low-level CSS building blocks such as CssRule exist, they are not automatically injected into the rendered output of Component or Template . As a result, CSS rules defined in Python are not applied to the final HTML at this stage. from probo.styles.plain_css import CssRule # CssRule objects represent validated CSS declarations btn_style = CssRule( background_color=\"blue\", color=\"white\", ) input_style = CssRule( padding=\"40px\", margin_bottom=\"10px\", ) # Note: # These rules are currently not applied automatically during render. # Styling APIs are under active development.","title":"4. Styling (JIT CSS)"},{"location":"simple_doc/#5-full-architecture-example-the-shortcut","text":"For the best developer experience, use the shortcut to wire everything in one go. from probo.shortcuts import ( component, ComponentConfig, StateConfig, StyleConfig, ElementStateConfig ) from probo import div, form def build_signup_page(): # 1. Logic title_state = ElementStateConfig( tag='h2', s_state='form_title', ) state_config = StateConfig( s_data={ 'form_title': 'Join the Club', }, elements_state_config=[ title_state, ], ) # 2. Style style_config = StyleConfig( css = { '.sign': { 'background': '#fff', 'padding': '2px', }, # Since no input element exists in the template, # this rule will be skipped automatically 'input': { 'width': '100%', 'padding': '10px', }, } ) # 3. Component Configuration config = ComponentConfig( name=\"SignUpPage\", template=div( title_state.config_id, form('some form'), Class=\"sign\", ), state_config=state_config, style_config=style_config, ) # 4. Build Component return component(config) print(build_signup_page()) ( '<div class=\"sign\"><form>some form</form></div>', '.sign { background:#fff; padding:2px; }' )","title":"5. Full Architecture Example (The \"shortcut\")"},{"location":"reference/probo/utility/","text":"utility","title":"utility"},{"location":"reference/probo/utility/#utility","text":"","title":"utility"},{"location":"reference/probo/components/attributes/","text":"attributes AttributeValue Bases: Enum Class to validate HTML attributes and their values. Source code in src\\probo\\components\\attributes.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 class AttributeValue ( Enum ): \"\"\"Class to validate HTML attributes and their values.\"\"\" ATTRIBUTE_VALUE = { \"accept\" : [ \"file_extension\" , \"audio/*\" , \"video/*\" , \"image/*\" , \"media_type\" ], \"accept-charset\" : [ \"UTF-8 \" , \"ISO-8859-1\" , \"ASCII\" , \"ANSI\" ], \"accesskey\" : \"any\" , \"action\" : \"any\" , \"alt\" : \"any\" , \"async\" : \"async\" , \"autocomplete\" : { \"form\" : [ \"on\" , \"off\" ], \"input\" : [ \"on\" , \"off\" , \"address-line1\" , \"address-line2\" , \"address-line3\" , \"address-level1\" , \"address-level2\" , \"address-level3\" , \"address-level4\" , \"street-address\" , \"country\" , \"country-name\" , \"postal-code\" , \"name\" , \"additional-name\" , \"family-name\" , \"give-name\" , \"honoric-prefix\" , \"honoric-suffix\" , \"nickname\" , \"organization-title\" , \"username\" , \"new-password\" , \"current-password\" , \"bday\" , \"bday-day\" , \"bday-month\" , \"bday-year\" , \"sex\" , \"one-time-code\" , \"organization\" , \"cc-name\" , \"cc-given-name\" , \"cc-additional-name\" , \"cc-family-name\" , \"cc-number\" , \"cc-exp\" , \"cc-exp-month\" , \"cc-exp-year\" , \"cc-csc\" , \"cc-type\" , \"transaction-currency\" , \"transaction-amount\" , \"language\" , \"url\" , \"email\" , \"photo\" , \"tel\" , \"tel-country-code\" , \"tel-national\" , \"tel-area-code\" , \"tel-local\" , \"tel-local-prefix\" , \"tel-local-suffix\" , \"tel-extension\" , \"impp\" , ], }, \"autofocus\" : \"autofocus\" , \"autoplay\" : \"autoplay\" , \"baseFrequency\" : \"any\" , \"charset\" : [ \"UTF-8\" , \"ISO-8859-1\" , \"ASCII\" , \"ANSI\" ], \"checked\" : \"checked\" , \"cite\" : \"any\" , \"class\" : \"any\" , \"cols\" : \"any\" , \"colspan\" : \"any\" , \"content\" : \"any\" , \"contenteditable\" : [ \"true\" , \"false\" ], \"controls\" : \"controls\" , \"coords\" : \"any\" , \"crossorigin\" : [ \"anonymous\" , \"use-credentials\" , \"\" ], \"cx\" : \"any\" , \"cy\" : \"any\" , \"dx\" : \"any\" , \"dy\" : \"any\" , \"d\" : \"any\" , # Path data string \"data\" : \"any\" , \"data-*\" : \"any\" , \"datetime\" : \"any\" , \"default\" : \"default\" , \"defer\" : \"defer\" , \"decoding\" : [ \"sync\" , \"async\" , \"auto\" ], # img \"dir\" : [ \"ltr\" , \"rtl\" , \"auto\" ], \"dirname\" : \"*.dir\" , \"disabled\" : \"disabled\" , \"display\" : \"any\" , \"dominant-baseline\" : [ \"auto\" , \"middle\" , \"central\" , \"hanging\" , \"mathematical\" ], \"download\" : { \"a\" : \"download\" , \"area\" : \"any\" }, \"draggable\" : [ \"true\" , \"false\" , \"auto\" ], \"enctype\" : [ \"application/x-www-form-urlencoded\" , \"multipart/form-data\" , \"text/plain\" , ], \"enterkeyhint\" : [ \"done\" , \"enter\" , \"go\" , \"next\" , \"previous\" , \"search\" , \"send\" ], \"fill\" : \"any\" , \"fill-opacity\" : \"any\" , \"for\" : \"any\" , \"form\" : \"any\" , \"formaction\" : \"any\" , \"gradientUnits\" : [ \"userSpaceOnUse\" , \"objectBoundingBox\" ], \"gradientTransform\" : \"any\" , \"headers\" : \"any\" , \"height\" : \"any\" , # number \"hidden\" : \"hidden\" , \"high\" : \"any\" , # number \"href\" : \"any\" , \"hreflang\" : [ \"ab\" , \"aa\" , \"af\" , \"ak\" , \"sq\" , \"am\" , \"ar\" , \"an\" , \"hy\" , \"as\" , \"av\" , \"ae\" , \"ay\" , \"az\" , \"bm\" , \"ba\" , \"eu\" , \"be\" , \"bn\" , \"bh\" , \"bi\" , \"bs\" , \"br\" , \"bg\" , \"my\" , \"ca\" , \"ch\" , \"ce\" , \"ny\" , \"zh\" , \"zh-Hans\" , \"zh-Hant\" , \"cv\" , \"kw\" , \"co\" , \"cr\" , \"hr\" , \"cs\" , \"da\" , \"dv\" , \"nl\" , \"dz\" , \"en\" , \"eo\" , \"et\" , \"ee\" , \"fo\" , \"fj\" , \"fi\" , \"fr\" , \"ff\" , \"gl\" , \"gd\" , \"gv\" , \"ka\" , \"de\" , \"el\" , \"kl\" , \"gn\" , \"gu\" , \"ht\" , \"ha\" , \"he\" , \"hz\" , \"hi\" , \"ho\" , \"hu\" , \"is\" , \"io\" , \"ig\" , \"id\" , \"in\" , \"ia\" , \"ie\" , \"iu\" , \"ik\" , \"ga\" , \"it\" , \"ja\" , \"jv\" , \"kl\" , \"kn\" , \"kr\" , \"ks\" , \"kk\" , \"km\" , \"ki\" , \"rw\" , \"rn\" , \"ky\" , \"kv\" , \"kg\" , \"ko\" , \"ku\" , \"kj\" , \"lo\" , \"la\" , \"lv\" , \"li\" , \"ln\" , \"lt\" , \"lu\" , \"lg\" , \"lb\" , \"gv\" , \"mk\" , \"mg\" , \"ms\" , \"ml\" , \"mt\" , \"mi\" , \"mr\" , \"mh\" , \"mo\" , \"mn\" , \"na\" , \"nv\" , \"ng\" , \"nd\" , \"ne\" , \"no\" , \"nb\" , \"nn\" , \"ii\" , \"oc\" , \"oj\" , \"cu\" , \"or\" , \"om\" , \"os\" , \"pi\" , \"ps\" , \"fa\" , \"pl\" , \"pt\" , \"pa\" , \"qu\" , \"rm\" , \"ro\" , \"ru\" , \"se\" , \"sm\" , \"sg\" , \"sa\" , \"sr\" , \"sh\" , \"st\" , \"tn\" , \"sn\" , \"ii\" , \"sd\" , \"si\" , \"ss\" , \"sk\" , \"sl\" , \"so\" , \"nr\" , \"es\" , \"su\" , \"sw\" , \"ss\" , \"sv\" , \"tl\" , \"ty\" , \"tg\" , \"ta\" , \"tt\" , \"te\" , \"th\" , \"bo\" , \"ti\" , \"to\" , \"ts\" , \"tr\" , \"tk\" , \"tw\" , \"ug\" , \"uk\" , \"ur\" , \"uz\" , \"ve\" , \"vi\" , \"vo\" , \"wa\" , \"cy\" , \"wo\" , \"fy\" , \"xh\" , \"yi\" , \"ji\" , \"yo\" , \"za\" , \"zu\" , ], \"http-equiv\" : [ \"content-security-policy\" , \"x-ua-compatible\" , \"content-type\" , \"default-style\" , \"refresh\" , \"content-language\" , ], \"id\" : \"any\" , \"in\" : [ \"SourceGraphic\" , \"SourceAlpha\" , \"BackgroundImage\" , \"BackgroundAlpha\" , \"FillPaint\" , \"StrokePaint\" ], \"in2\" : \"any\" , \"integrity\" : \"any\" , \"inert\" : \"inert\" , \"inputmode\" : [ \"decimal\" , \"email\" , \"none\" , \"numeric\" , \"search\" , \"tel\" , \"text\" , \"url\" , ], \"ismap\" : \"ismap\" , \"kind\" : [ \"captions\" , \"chapters\" , \"descriptions\" , \"metadata\" , \"subtitles\" ], \"k1\" : \"any\" , \"k2\" : \"any\" , \"k3\" : \"any\" , \"k4\" : \"any\" , \"label\" : \"any\" , \"lang\" : [ \"ab\" , \"aa\" , \"af\" , \"ak\" , \"sq\" , \"am\" , \"ar\" , \"an\" , \"hy\" , \"as\" , \"av\" , \"ae\" , \"ay\" , \"az\" , \"bm\" , \"ba\" , \"eu\" , \"be\" , \"bn\" , \"bh\" , \"bi\" , \"bs\" , \"br\" , \"bg\" , \"my\" , \"ca\" , \"ch\" , \"ce\" , \"ny\" , \"zh\" , \"zh-Hans\" , \"zh-Hant\" , \"cv\" , \"kw\" , \"co\" , \"cr\" , \"hr\" , \"cs\" , \"da\" , \"dv\" , \"nl\" , \"dz\" , \"en\" , \"eo\" , \"et\" , \"ee\" , \"fo\" , \"fj\" , \"fi\" , \"fr\" , \"ff\" , \"gl\" , \"gd\" , \"gv\" , \"ka\" , \"de\" , \"el\" , \"kl\" , \"gn\" , \"gu\" , \"ht\" , \"ha\" , \"he\" , \"hz\" , \"hi\" , \"ho\" , \"hu\" , \"is\" , \"io\" , \"ig\" , \"id\" , \"in\" , \"ia\" , \"ie\" , \"iu\" , \"ik\" , \"ga\" , \"it\" , \"ja\" , \"jv\" , \"kl\" , \"kn\" , \"kr\" , \"ks\" , \"kk\" , \"km\" , \"ki\" , \"rw\" , \"rn\" , \"ky\" , \"kv\" , \"kg\" , \"ko\" , \"ku\" , \"kj\" , \"lo\" , \"la\" , \"lv\" , \"li\" , \"ln\" , \"lt\" , \"lu\" , \"lg\" , \"lb\" , \"gv\" , \"mk\" , \"mg\" , \"ms\" , \"ml\" , \"mt\" , \"mi\" , \"mr\" , \"mh\" , \"mo\" , \"mn\" , \"na\" , \"nv\" , \"ng\" , \"nd\" , \"ne\" , \"no\" , \"nb\" , \"nn\" , \"ii\" , \"oc\" , \"oj\" , \"cu\" , \"or\" , \"om\" , \"os\" , \"pi\" , \"ps\" , \"fa\" , \"pl\" , \"pt\" , \"pa\" , \"qu\" , \"rm\" , \"ro\" , \"ru\" , \"se\" , \"sm\" , \"sg\" , \"sa\" , \"sr\" , \"sh\" , \"st\" , \"tn\" , \"sn\" , \"ii\" , \"sd\" , \"si\" , \"ss\" , \"sk\" , \"sl\" , \"so\" , \"nr\" , \"es\" , \"su\" , \"sw\" , \"ss\" , \"sv\" , \"tl\" , \"ty\" , \"tg\" , \"ta\" , \"tt\" , \"te\" , \"th\" , \"bo\" , \"ti\" , \"to\" , \"ts\" , \"tr\" , \"tk\" , \"tw\" , \"ug\" , \"uk\" , \"ur\" , \"uz\" , \"ve\" , \"vi\" , \"vo\" , \"wa\" , \"cy\" , \"wo\" , \"fy\" , \"xh\" , \"yi\" , \"ji\" , \"yo\" , \"za\" , \"zu\" , ], \"list\" : \"any\" , \"loading\" : [ \"lazy\" , \"eager\" ], # img, iframe \"loop\" : \"loop\" , \"low\" : \"any\" , # number \"max\" : \"any\" , # date \"markerUnits\" : [ \"strokeWidth\" , \"userSpaceOnUse\" ], \"markerWidth\" : \"any\" , \"markerHeight\" : \"any\" , \"maxlength\" : \"any\" , # number \"media\" : { \"operator\" : [ \"and\" , \"not\" , \",\" ], \"devices\" : [ \"all\" , \"aural\" , \"braille\" , \"handheld\" , \"projection\" , \"print\" , \"screen\" , \"tty\" , \"tv\" , ], \"values\" : [ \"width\" , \"height\" , \"device-width\" , \"device-height\" , \"orientation\" , \"aspect-ratio\" , \"device-aspect-ratio\" , \"color\" , \"color-index\" , \"monochrome\" , \"resolution\" , \"scan\" , \"grid\" , ], }, \"method\" : [ \"get\" , \"post\" ], \"min\" : \"any\" , \"mode\" : [ \"normal\" , \"multiply\" , \"screen\" , \"overlay\" , \"darken\" , \"lighten\" , \"color-dodge\" , \"color-burn\" , \"hard-light\" , \"soft-light\" , \"difference\" , \"exclusion\" , \"hue\" , \"saturation\" , \"color\" , \"luminosity\" ], \"multiple\" : \"multiple\" , \"muted\" : \"muted\" , \"name\" : \"any\" , \"numOctaves\" : \"any\" , \"novalidate\" : \"novalidate\" , \"open\" : \"open\" , \"optimum\" : \"any\" , # float number \"offset\" : \"any\" , \"orient\" : \"any\" , \"operator\" : [ \"over\" , \"in\" , \"out\" , \"atop\" , \"xor\" , \"arithmetic\" , \"erode\" , \"dilate\" ], \"pattern\" : \"any\" , \"crossorigin\" : \"any\" , \"placeholder\" : \"any\" , \"popover\" : \"popover\" , \"popovertarget\" : \"any\" , \"popovertargetaction\" : [ \"hide\" , \"show\" , \"toggle\" ], \"poster\" : \"any\" , \"preload\" : [ \"auto\" , \"metadata\" , \"none\" ], \"r\" : \"any\" , \"rx\" : \"any\" , \"ry\" : \"any\" , \"refX\" : \"any\" , \"refY\" : \"any\" , \"readonly\" : \"readonly\" , \"rel\" : { \"a\" : [ \"alternate\" , \"author\" , \"bookmark\" , \"external\" , \"help\" , \"license\" , \"next\" , \"nofollow\" , \"noopener\" , \"noreferrer\" , \"prev\" , \"search\" , \"tag\" , ], \"area\" : [ \"alternate\" , \"author\" , \"bookmark\" , \"help\" , \"license\" , \"next\" , \"nofollow\" , \"noreferrer\" , \"prefetch\" , \"prev\" , \"search\" , \"tag\" , ], \"link\" : [ \"alternate\" , \"author\" , \"dns-prefetch\" , \"help\" , \"icon\" , \"license\" , \"next\" , \"pingback\" , \"preconnect\" , \"prefetch\" , \"preload\" , \"prerender\" , \"prev\" , \"search\" , \"stylesheet\" , \"canonical\" , ], \"form\" : [ \"external\" , \"help\" , \"license\" , \"next\" , \"nofollow\" , \"noopener\" , \"noreferrer\" , \"opener\" , \"prev\" , \"search\" , ], }, \"required\" : \"required\" , \"reversed\" : \"reversed\" , \"referrerpolicy\" : [ \"no-referrer\" , \"no-referrer-when-downgrade\" , \"origin\" , \"origin-when-cross-origin\" , \"same-origin\" , \"strict-origin\" , \"strict-origin-when-cross-origin\" , \"unsafe-url\" ], \"role\" : [ \"alert\" , \"alertdialog\" , \"application\" , \"article\" , \"banner\" , \"button\" , \"cell\" , \"checkbox\" , \"columnheader\" , \"combobox\" , \"command\" , \"comment\" , \"complementary\" , \"composite\" , \"contentinfo\" , \"definition\" , \"dialog\" , \"directory\" , \"Deprecated\" , \"document\" , \"feed\" , \"figure\" , \"form\" , \"generic\" , \"grid\" , \"gridcell\" , \"group\" , \"heading\" , \"img\" , \"input\" , \"landmark\" , \"link\" , \"list\" , \"listbox\" , \"listitem\" , \"log\" , \"main\" , \"mark\" , \"marquee\" , \"math\" , \"menu\" , \"menubar\" , \"menuitem\" , \"menuitemcheckbox\" , \"menuitemradio\" , \"meter\" , \"navigation\" , \"none\" , \"note\" , \"option\" , \"presentation\" , \"progressbar\" , \"radio\" , \"radiogroup\" , \"range\" , \"region\" , \"roletype\" , \"row\" , \"rowgroup\" , \"rowheader\" , \"scrollbar\" , \"search\" , \"searchbox\" , \"section\" , \"sectionhead\" , \"select\" , \"separator\" , \"slider\" , \"spinbutton\" , \"status\" , \"Structural\" , \"structure\" , \"suggestion\" , \"switch\" , \"tab\" , \"table\" , \"tablist\" , \"tabpanel\" , \"term\" , \"textbox\" , \"timer\" , \"toolbar\" , \"tooltip\" , \"tree\" , \"treegrid\" , \"treeitem\" , \"widget\" , \"window\" , ], \"rows\" : \"any\" , # number \"rowspan\" : \"any\" , # number \"sandbox\" : \"sandbox\" , \"scope\" : [ \"col\" , \"row\" , \"colgroup\" , \"rowgroup\" ], \"selected\" : \"selected\" , \"shape\" : [ \"default\" , \"rect\" , \"circle\" , \"poly\" ], \"size\" : \"any\" , # number \"sizes\" : \"any\" , # numberxnumber \"slot\" : \"any\" , \"span\" : \"any\" , # number \"spellcheck\" : [ \"true\" , \"false\" ], \"spreadMethod\" : [ \"pad\" , \"reflect\" , \"repeat\" ], \"src\" : \"any\" , # url \"srcdoc\" : \"any\" , # HTML_code \"srclang\" : [ \"ab\" , \"aa\" , \"af\" , \"ak\" , \"sq\" , \"am\" , \"ar\" , \"an\" , \"hy\" , \"as\" , \"av\" , \"ae\" , \"ay\" , \"az\" , \"bm\" , \"ba\" , \"eu\" , \"be\" , \"bn\" , \"bh\" , \"bi\" , \"bs\" , \"br\" , \"bg\" , \"my\" , \"ca\" , \"ch\" , \"ce\" , \"ny\" , \"zh\" , \"zh-Hans\" , \"zh-Hant\" , \"cv\" , \"kw\" , \"co\" , \"cr\" , \"hr\" , \"cs\" , \"da\" , \"dv\" , \"nl\" , \"dz\" , \"en\" , \"eo\" , \"et\" , \"ee\" , \"fo\" , \"fj\" , \"fi\" , \"fr\" , \"ff\" , \"gl\" , \"gd\" , \"gv\" , \"ka\" , \"de\" , \"el\" , \"kl\" , \"gn\" , \"gu\" , \"ht\" , \"ha\" , \"he\" , \"hz\" , \"hi\" , \"ho\" , \"hu\" , \"is\" , \"io\" , \"ig\" , \"id\" , \"in\" , \"ia\" , \"ie\" , \"iu\" , \"ik\" , \"ga\" , \"it\" , \"ja\" , \"jv\" , \"kl\" , \"kn\" , \"kr\" , \"ks\" , \"kk\" , \"km\" , \"ki\" , \"rw\" , \"rn\" , \"ky\" , \"kv\" , \"kg\" , \"ko\" , \"ku\" , \"kj\" , \"lo\" , \"la\" , \"lv\" , \"li\" , \"ln\" , \"lt\" , \"lu\" , \"lg\" , \"lb\" , \"gv\" , \"mk\" , \"mg\" , \"ms\" , \"ml\" , \"mt\" , \"mi\" , \"mr\" , \"mh\" , \"mo\" , \"mn\" , \"na\" , \"nv\" , \"ng\" , \"nd\" , \"ne\" , \"no\" , \"nb\" , \"nn\" , \"ii\" , \"oc\" , \"oj\" , \"cu\" , \"or\" , \"om\" , \"os\" , \"pi\" , \"ps\" , \"fa\" , \"pl\" , \"pt\" , \"pa\" , \"qu\" , \"rm\" , \"ro\" , \"ru\" , \"se\" , \"sm\" , \"sg\" , \"sa\" , \"sr\" , \"sh\" , \"st\" , \"tn\" , \"sn\" , \"ii\" , \"sd\" , \"si\" , \"ss\" , \"sk\" , \"sl\" , \"so\" , \"nr\" , \"es\" , \"su\" , \"sw\" , \"ss\" , \"sv\" , \"tl\" , \"ty\" , \"tg\" , \"ta\" , \"tt\" , \"te\" , \"th\" , \"bo\" , \"ti\" , \"to\" , \"ts\" , \"tr\" , \"tk\" , \"tw\" , \"ug\" , \"uk\" , \"ur\" , \"uz\" , \"ve\" , \"vi\" , \"vo\" , \"wa\" , \"cy\" , \"wo\" , \"fy\" , \"xh\" , \"yi\" , \"ji\" , \"yo\" , \"za\" , \"zu\" , ], \"srcset\" : \"any\" , # url \"start\" : \"any\" , # number \"step\" : \"any\" , # number \"stop-color\" : \"any\" , \"stop-opacity\" : \"any\" , \"stroke\" : \"any\" , \"stroke-width\" : \"any\" , \"stroke-dasharray\" : \"any\" , \"stroke-dashoffset\" : \"any\" , \"stroke-opacity\" : \"any\" , \"stdDeviation\" : \"any\" , # Blur amount \"seed\" : \"any\" , \"stitchTiles\" : [ \"stitch\" , \"noStitch\" ], \"stroke-linecap\" : [ \"butt\" , \"round\" , \"square\" , \"inherit\" ], \"stroke-linejoin\" : [ \"miter\" , \"round\" , \"bevel\" , \"inherit\" ], \"style\" : \"any\" , # css \"tabindex\" : \"any\" , # number \"target\" : [ \"_blank\" , \"_self\" , \"_parent\" , \"_top\" , \"framename\" , ], # [0]=any tag, [1]= <base>tag \"text-anchor\" : [ \"start\" , \"middle\" , \"end\" , \"inherit\" ], \"title\" : \"any\" , \"translate\" : [ \"yes\" , \"no\" ], \"transform\" : \"any\" , \"type\" : { # --- HTML Forms --- \"input\" : [ \"button\" , \"checkbox\" , \"color\" , \"date\" , \"datetime-local\" , \"email\" , \"file\" , \"hidden\" , \"image\" , \"month\" , \"number\" , \"password\" , \"radio\" , \"range\" , \"reset\" , \"search\" , \"submit\" , \"tel\" , \"text\" , \"time\" , \"url\" , \"week\" ], \"button\" : [ \"submit\" , \"reset\" , \"button\" ], # --- HTML Lists --- \"ol\" : [ \"1\" , \"a\" , \"A\" , \"i\" , \"I\" ], # --- HTML Resources --- \"script\" : [ \"text/javascript\" , \"module\" , \"application/javascript\" , \"application/ecmascript\" , \"application/json\" , \"importmap\" ], \"style\" : [ \"text/css\" ], \"link\" : [ \"text/css\" , \"image/x-icon\" , \"image/png\" , \"image/jpeg\" , \"application/pdf\" , \"font/woff2\" ], # MIME types (incomplete list, but common ones) \"object\" : \"any\" , # MIME types \"embed\" : \"any\" , # MIME types \"source\" : \"any\" , # MIME types (audio/video) # --- HTML Menu/Command (Obsolete but sometimes used) --- \"menu\" : [ \"list\" , \"context\" , \"toolbar\" ], # --- SVG Filters --- \"feColorMatrix\" : [ \"matrix\" , \"saturate\" , \"hueRotate\" , \"luminanceToAlpha\" ], \"feTurbulence\" : [ \"fractalNoise\" , \"turbulence\" ], \"feFuncR\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], \"feFuncG\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], \"feFuncB\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], \"feFuncA\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], # --- SVG Animation --- \"animateTransform\" : [ \"translate\" , \"scale\" , \"rotate\" , \"skewX\" , \"skewY\" ], }, # [0]=<input>, [1]=<bottun>, [2]=any \"usemap\" : [ \"#any\" ], # starts with '#' \"value\" : \"any\" , \"values\" : \"any\" , # Matrix values \"visibility\" : [ \"visible\" , \"hidden\" , \"collapse\" , \"inherit\" ], \"width\" : \"any\" , # number \"wrap\" : [ \"soft\" , \"hard\" ], \"x\" : \"any\" , 'xmlns' :[ \"http://www.w3.org/2000/svg\" ], \"y\" : \"any\" , \"x1\" : \"any\" , \"y1\" : \"any\" , \"x2\" : \"any\" , \"y2\" : \"any\" , \"points\" : \"any\" , # Polygon points string \"viewBox\" : \"any\" , # \"min-x min-y width height\" \"preserveAspectRatio\" : \"any\" , \"opacity\" : \"any\" , } BOOTSTRAP_DATA_BS_ATTRIBUTE = { # === General (used across multiple components) === \"data-bs-toggle\" : [ \"modal\" , \"dropdown\" , \"collapse\" , \"offcanvas\" , \"tooltip\" , \"popover\" , \"tab\" , \"button\" , ], \"data-bs-dismiss\" : [ \"modal\" , \"alert\" , \"offcanvas\" , \"toast\" ], \"data-bs-container\" : [ \"body\" , \"element selector\" ], \"data-bs-placement\" : [ \"top\" , \"bottom\" , \"left\" , \"right\" , \"auto\" , \"top-start\" , \"top-end\" , \"bottom-start\" , \"bottom-end\" , \"left-start\" , \"left-end\" , \"right-start\" , \"right-end\" , ], # === Modals === \"data-bs-backdrop\" : [ \"true\" , \"false\" , \"static\" ], \"data-bs-keyboard\" : [ \"true\" , \"false\" ], \"data-bs-focus\" : [ \"true\" , \"false\" ], \"data-bs-show\" : [ \"true\" , \"false\" ], # === Collapse / Accordion === \"data-bs-target\" : \"any\" , \"data-bs-parent\" : \"any\" , # === Dropdowns === \"data-bs-offset\" : \"any\" , \"data-bs-reference\" : [ \"toggle\" , \"parent\" , \"body\" ], \"data-bs-display\" : [ \"dynamic\" , \"static\" ], \"data-bs-auto-close\" : [ \"true\" , \"false\" , \"inside\" , \"outside\" ], # === Offcanvas === \"data-bs-scroll\" : [ \"true\" , \"false\" ], # === Tooltips & Popovers === \"data-bs-title\" : \"any\" , \"data-bs-content\" : \"any\" , \"data-bs-html\" : [ \"true\" , \"false\" ], \"data-bs-delay\" : \"any\" , \"data-bs-trigger\" : [ \"hover\" , \"focus\" , \"click\" , \"manual\" ], \"data-bs-custom-class\" : \"any\" , \"data-bs-boundary\" : [ \"clippingParents\" , \"viewport\" , \"window\" ], # === Carousel === \"data-bs-slide\" : [ \"next\" , \"prev\" ], \"data-bs-ride\" : [ \"carousel\" ], \"data-bs-interval\" : [ \"any\" , \"false\" ], \"data-bs-pause\" : [ \"hover\" , \"false\" ], \"data-bs-wrap\" : [ \"true\" , \"false\" ], \"data-bs-touch\" : [ \"true\" , \"false\" ], \"data-bs-slide-to\" : \"any\" , # === Toasts === \"data-bs-autohide\" : [ \"true\" , \"false\" ], } ARIA_ATTRIBUTES = { # === Global States and Properties === \"aria-activedescendant\" : \"any\" , \"aria-atomic\" : [ \"true\" , \"false\" ], \"aria-autocomplete\" : [ \"none\" , \"inline\" , \"list\" , \"both\" ], \"aria-busy\" : [ \"true\" , \"false\" ], \"aria-checked\" : [ \"true\" , \"false\" , \"mixed\" , \"undefined\" ], \"aria-colcount\" : \"any\" , \"aria-colindex\" : \"any\" , \"aria-colspan\" : \"any\" , \"aria-controls\" : \"any\" , \"aria-current\" : [ \"page\" , \"step\" , \"location\" , \"date\" , \"time\" , \"true\" , \"false\" ], \"aria-describedby\" : \"any\" , \"aria-details\" : \"any\" , \"aria-disabled\" : [ \"true\" , \"false\" ], \"aria-errormessage\" : \"any\" , \"aria-expanded\" : [ \"true\" , \"false\" , \"undefined\" ], \"aria-flowto\" : \"any\" , \"aria-haspopup\" : [ \"true\" , \"false\" , \"menu\" , \"listbox\" , \"tree\" , \"grid\" , \"dialog\" ], \"aria-hidden\" : [ \"true\" , \"false\" ], \"aria-invalid\" : [ \"grammar\" , \"false\" , \"spelling\" , \"true\" ], \"aria-keyshortcuts\" : \"any\" , \"aria-label\" : \"any\" , \"aria-labelledby\" : \"any\" , \"aria-live\" : [ \"off\" , \"polite\" , \"assertive\" ], \"aria-modal\" : [ \"true\" , \"false\" ], \"aria-multiline\" : [ \"true\" , \"false\" ], \"aria-multiselectable\" : [ \"true\" , \"false\" ], \"aria-orientation\" : [ \"horizontal\" , \"vertical\" ], \"aria-owns\" : \"any\" , \"aria-placeholder\" : \"any\" , \"aria-posinset\" : \"any\" , \"aria-pressed\" : [ \"true\" , \"false\" , \"mixed\" ], \"aria-readonly\" : [ \"true\" , \"false\" ], \"aria-relevant\" : [ \"additions\" , \"removals\" , \"text\" , \"all\" ], \"aria-required\" : [ \"true\" , \"false\" ], \"aria-roledescription\" : \"any\" , \"aria-rowcount\" : \"any\" , \"aria-rowindex\" : \"any\" , \"aria-rowspan\" : \"any\" , \"aria-selected\" : [ \"true\" , \"false\" ], \"aria-setsize\" : \"any\" , \"aria-sort\" : [ \"none\" , \"ascending\" , \"descending\" , \"other\" ], \"aria-valuemax\" : \"any\" , \"aria-valuemin\" : \"any\" , \"aria-valuenow\" : \"any\" , \"aria-valuetext\" : \"any\" , # === Application / Structural Roles === \"role\" : [ \"alert\" , \"alertdialog\" , \"application\" , \"article\" , \"banner\" , \"button\" , \"cell\" , \"checkbox\" , \"columnheader\" , \"combobox\" , \"complementary\" , \"contentinfo\" , \"definition\" , \"dialog\" , \"directory\" , \"document\" , \"feed\" , \"figure\" , \"form\" , \"grid\" , \"gridcell\" , \"group\" , \"heading\" , \"img\" , \"link\" , \"list\" , \"listbox\" , \"listitem\" , \"log\" , \"main\" , \"marquee\" , \"math\" , \"menu\" , \"menubar\" , \"menuitem\" , \"menuitemcheckbox\" , \"menuitemradio\" , \"navigation\" , \"none\" , \"note\" , \"option\" , \"presentation\" , \"progressbar\" , \"radio\" , \"radiogroup\" , \"region\" , \"row\" , \"rowgroup\" , \"rowheader\" , \"scrollbar\" , \"search\" , \"searchbox\" , \"separator\" , \"slider\" , \"spinbutton\" , \"status\" , \"switch\" , \"tab\" , \"table\" , \"tablist\" , \"tabpanel\" , \"term\" , \"textbox\" , \"timer\" , \"toolbar\" , \"tooltip\" , \"tree\" , \"treegrid\" , \"treeitem\" , ], } ElementAttributeValidator Class to validate HTML attributes for elements. This class checks if the provided attributes are valid for a given HTML element. Source code in src\\probo\\components\\attributes.py 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 class ElementAttributeValidator : \"\"\"Class to validate HTML attributes for elements. This class checks if the provided attributes are valid for a given HTML element.\"\"\" def __init__ ( self , element_tag : str = \"\" , ** kwargs ): self . element_tag = element_tag if element_tag else \"\" self . raw_attrs = kwargs self . valid_attrs = {} self . error_attrs = [] # Run validation on init self . is_valid = self . validate () def validate ( self ) -> bool : \"\"\" Core Logic. Returns True if all attributes are processed successfully. Populates self.valid_attrs with the final, clean dictionary. \"\"\" if not self . raw_attrs : return True all_valid = True el_attr_definitions = ElementAttribute . ELEMENT_ATTRIBUTE . value # Access the master dictionary definitions = AttributeValue . ATTRIBUTE_VALUE . value for raw_key , value in self . raw_attrs . items (): # 1. NORMALIZE KEY (class_ -> class, aria_hidden -> aria-hidden) if len ( raw_key ) > 1 : key = raw_key [ 0 ] . lower () + raw_key [ 1 :] . strip () . replace ( \"_\" , \"-\" ) else : key = raw_key . lower () . strip () . replace ( \"_\" , \"-\" ) # --- SKIP PART 1: BOOLEANS --- if isinstance ( value , bool ) : if value is True : self . valid_attrs [ key ] = True # If False, we ignore it (it won't render) continue # --- SKIP PART 2: WILDCARDS --- # Bootstrap (data-*), HTMX (hx-*), Aria (aria-*), Events (on*), if key . startswith (( \"data-\" , \"aria-\" , \"hx-\" , \"on\" , \"xml\" , \"ng-\" , \"v-\" )): self . valid_attrs [ key ] = value continue el_attr_check = el_attr_definitions . get ( key , None ) if ( el_attr_check and not self . element_tag in el_attr_check ): return False # --- SKIP PART 3: THE CLUSTER (Fast Pass) --- in_cluster = key in ATTR_CLUSTER rule = definitions . get ( key , None ) # --- CHECK: DEFINITIONS --- if rule : # Case A: 'any' -> Accept anything if rule == \"any\" : self . valid_attrs [ key ] = value continue # Case B: List of allowed values -> Check it if isinstance ( rule , list ): # Convert to string to handle ints safely if str ( value ) not in rule : self . error_attrs . append ( f \" { key } =' { value } ' (Expected: { rule } )\" ) all_valid = False continue else : self . valid_attrs [ key ] = value continue # Case C: Dictionary (Element-Specific Rules) -> Check it if isinstance ( rule , dict ): tag_clean = self . element_tag . strip ( \"<>\" ) if tag_clean in rule : allowed_vals = rule [ tag_clean ] if str ( value ) not in allowed_vals : self . error_attrs . append ( f \" { key } =' { value } ' on < { tag_clean } > (Expected: { allowed_vals } )\" ) all_valid = False continue else : # Tag not specified in rule, be loose self . valid_attrs [ key ] = value continue # --- FALLBACK --- if in_cluster : self . valid_attrs [ key ] = value else : # Unknown/Custom attribute -> Allow it self . valid_attrs [ key ] = value return all_valid validate () Core Logic. Returns True if all attributes are processed successfully. Populates self.valid_attrs with the final, clean dictionary. Source code in src\\probo\\components\\attributes.py 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 def validate ( self ) -> bool : \"\"\" Core Logic. Returns True if all attributes are processed successfully. Populates self.valid_attrs with the final, clean dictionary. \"\"\" if not self . raw_attrs : return True all_valid = True el_attr_definitions = ElementAttribute . ELEMENT_ATTRIBUTE . value # Access the master dictionary definitions = AttributeValue . ATTRIBUTE_VALUE . value for raw_key , value in self . raw_attrs . items (): # 1. NORMALIZE KEY (class_ -> class, aria_hidden -> aria-hidden) if len ( raw_key ) > 1 : key = raw_key [ 0 ] . lower () + raw_key [ 1 :] . strip () . replace ( \"_\" , \"-\" ) else : key = raw_key . lower () . strip () . replace ( \"_\" , \"-\" ) # --- SKIP PART 1: BOOLEANS --- if isinstance ( value , bool ) : if value is True : self . valid_attrs [ key ] = True # If False, we ignore it (it won't render) continue # --- SKIP PART 2: WILDCARDS --- # Bootstrap (data-*), HTMX (hx-*), Aria (aria-*), Events (on*), if key . startswith (( \"data-\" , \"aria-\" , \"hx-\" , \"on\" , \"xml\" , \"ng-\" , \"v-\" )): self . valid_attrs [ key ] = value continue el_attr_check = el_attr_definitions . get ( key , None ) if ( el_attr_check and not self . element_tag in el_attr_check ): return False # --- SKIP PART 3: THE CLUSTER (Fast Pass) --- in_cluster = key in ATTR_CLUSTER rule = definitions . get ( key , None ) # --- CHECK: DEFINITIONS --- if rule : # Case A: 'any' -> Accept anything if rule == \"any\" : self . valid_attrs [ key ] = value continue # Case B: List of allowed values -> Check it if isinstance ( rule , list ): # Convert to string to handle ints safely if str ( value ) not in rule : self . error_attrs . append ( f \" { key } =' { value } ' (Expected: { rule } )\" ) all_valid = False continue else : self . valid_attrs [ key ] = value continue # Case C: Dictionary (Element-Specific Rules) -> Check it if isinstance ( rule , dict ): tag_clean = self . element_tag . strip ( \"<>\" ) if tag_clean in rule : allowed_vals = rule [ tag_clean ] if str ( value ) not in allowed_vals : self . error_attrs . append ( f \" { key } =' { value } ' on < { tag_clean } > (Expected: { allowed_vals } )\" ) all_valid = False continue else : # Tag not specified in rule, be loose self . valid_attrs [ key ] = value continue # --- FALLBACK --- if in_cluster : self . valid_attrs [ key ] = value else : # Unknown/Custom attribute -> Allow it self . valid_attrs [ key ] = value return all_valid","title":"attributes"},{"location":"reference/probo/components/attributes/#attributes","text":"","title":"attributes"},{"location":"reference/probo/components/attributes/#probo.components.attributes.AttributeValue","text":"Bases: Enum Class to validate HTML attributes and their values. Source code in src\\probo\\components\\attributes.py 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 672 673 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 691 692 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 710 711 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 729 730 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 748 749 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 767 768 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 786 787 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 805 806 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 824 825 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 843 844 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 862 863 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 881 882 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 900 901 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 919 920 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 938 939 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 957 958 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 976 977 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 995 996 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 1014 1015 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 1033 1034 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 1052 1053 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 1071 1072 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 1090 1091 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 1109 1110 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 1128 1129 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 1147 1148 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 1166 1167 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 1185 1186 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 1204 1205 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 1223 1224 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 1242 1243 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 1261 1262 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 1280 1281 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 1299 1300 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 1318 1319 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 1337 1338 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 1356 1357 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 1375 1376 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 1394 1395 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 1413 1414 1415 1416 1417 1418 1419 1420 1421 1422 1423 1424 1425 1426 1427 1428 1429 1430 1431 1432 1433 1434 1435 1436 1437 1438 1439 1440 1441 1442 1443 1444 1445 1446 1447 1448 1449 1450 1451 1452 1453 1454 1455 1456 1457 1458 1459 1460 1461 class AttributeValue ( Enum ): \"\"\"Class to validate HTML attributes and their values.\"\"\" ATTRIBUTE_VALUE = { \"accept\" : [ \"file_extension\" , \"audio/*\" , \"video/*\" , \"image/*\" , \"media_type\" ], \"accept-charset\" : [ \"UTF-8 \" , \"ISO-8859-1\" , \"ASCII\" , \"ANSI\" ], \"accesskey\" : \"any\" , \"action\" : \"any\" , \"alt\" : \"any\" , \"async\" : \"async\" , \"autocomplete\" : { \"form\" : [ \"on\" , \"off\" ], \"input\" : [ \"on\" , \"off\" , \"address-line1\" , \"address-line2\" , \"address-line3\" , \"address-level1\" , \"address-level2\" , \"address-level3\" , \"address-level4\" , \"street-address\" , \"country\" , \"country-name\" , \"postal-code\" , \"name\" , \"additional-name\" , \"family-name\" , \"give-name\" , \"honoric-prefix\" , \"honoric-suffix\" , \"nickname\" , \"organization-title\" , \"username\" , \"new-password\" , \"current-password\" , \"bday\" , \"bday-day\" , \"bday-month\" , \"bday-year\" , \"sex\" , \"one-time-code\" , \"organization\" , \"cc-name\" , \"cc-given-name\" , \"cc-additional-name\" , \"cc-family-name\" , \"cc-number\" , \"cc-exp\" , \"cc-exp-month\" , \"cc-exp-year\" , \"cc-csc\" , \"cc-type\" , \"transaction-currency\" , \"transaction-amount\" , \"language\" , \"url\" , \"email\" , \"photo\" , \"tel\" , \"tel-country-code\" , \"tel-national\" , \"tel-area-code\" , \"tel-local\" , \"tel-local-prefix\" , \"tel-local-suffix\" , \"tel-extension\" , \"impp\" , ], }, \"autofocus\" : \"autofocus\" , \"autoplay\" : \"autoplay\" , \"baseFrequency\" : \"any\" , \"charset\" : [ \"UTF-8\" , \"ISO-8859-1\" , \"ASCII\" , \"ANSI\" ], \"checked\" : \"checked\" , \"cite\" : \"any\" , \"class\" : \"any\" , \"cols\" : \"any\" , \"colspan\" : \"any\" , \"content\" : \"any\" , \"contenteditable\" : [ \"true\" , \"false\" ], \"controls\" : \"controls\" , \"coords\" : \"any\" , \"crossorigin\" : [ \"anonymous\" , \"use-credentials\" , \"\" ], \"cx\" : \"any\" , \"cy\" : \"any\" , \"dx\" : \"any\" , \"dy\" : \"any\" , \"d\" : \"any\" , # Path data string \"data\" : \"any\" , \"data-*\" : \"any\" , \"datetime\" : \"any\" , \"default\" : \"default\" , \"defer\" : \"defer\" , \"decoding\" : [ \"sync\" , \"async\" , \"auto\" ], # img \"dir\" : [ \"ltr\" , \"rtl\" , \"auto\" ], \"dirname\" : \"*.dir\" , \"disabled\" : \"disabled\" , \"display\" : \"any\" , \"dominant-baseline\" : [ \"auto\" , \"middle\" , \"central\" , \"hanging\" , \"mathematical\" ], \"download\" : { \"a\" : \"download\" , \"area\" : \"any\" }, \"draggable\" : [ \"true\" , \"false\" , \"auto\" ], \"enctype\" : [ \"application/x-www-form-urlencoded\" , \"multipart/form-data\" , \"text/plain\" , ], \"enterkeyhint\" : [ \"done\" , \"enter\" , \"go\" , \"next\" , \"previous\" , \"search\" , \"send\" ], \"fill\" : \"any\" , \"fill-opacity\" : \"any\" , \"for\" : \"any\" , \"form\" : \"any\" , \"formaction\" : \"any\" , \"gradientUnits\" : [ \"userSpaceOnUse\" , \"objectBoundingBox\" ], \"gradientTransform\" : \"any\" , \"headers\" : \"any\" , \"height\" : \"any\" , # number \"hidden\" : \"hidden\" , \"high\" : \"any\" , # number \"href\" : \"any\" , \"hreflang\" : [ \"ab\" , \"aa\" , \"af\" , \"ak\" , \"sq\" , \"am\" , \"ar\" , \"an\" , \"hy\" , \"as\" , \"av\" , \"ae\" , \"ay\" , \"az\" , \"bm\" , \"ba\" , \"eu\" , \"be\" , \"bn\" , \"bh\" , \"bi\" , \"bs\" , \"br\" , \"bg\" , \"my\" , \"ca\" , \"ch\" , \"ce\" , \"ny\" , \"zh\" , \"zh-Hans\" , \"zh-Hant\" , \"cv\" , \"kw\" , \"co\" , \"cr\" , \"hr\" , \"cs\" , \"da\" , \"dv\" , \"nl\" , \"dz\" , \"en\" , \"eo\" , \"et\" , \"ee\" , \"fo\" , \"fj\" , \"fi\" , \"fr\" , \"ff\" , \"gl\" , \"gd\" , \"gv\" , \"ka\" , \"de\" , \"el\" , \"kl\" , \"gn\" , \"gu\" , \"ht\" , \"ha\" , \"he\" , \"hz\" , \"hi\" , \"ho\" , \"hu\" , \"is\" , \"io\" , \"ig\" , \"id\" , \"in\" , \"ia\" , \"ie\" , \"iu\" , \"ik\" , \"ga\" , \"it\" , \"ja\" , \"jv\" , \"kl\" , \"kn\" , \"kr\" , \"ks\" , \"kk\" , \"km\" , \"ki\" , \"rw\" , \"rn\" , \"ky\" , \"kv\" , \"kg\" , \"ko\" , \"ku\" , \"kj\" , \"lo\" , \"la\" , \"lv\" , \"li\" , \"ln\" , \"lt\" , \"lu\" , \"lg\" , \"lb\" , \"gv\" , \"mk\" , \"mg\" , \"ms\" , \"ml\" , \"mt\" , \"mi\" , \"mr\" , \"mh\" , \"mo\" , \"mn\" , \"na\" , \"nv\" , \"ng\" , \"nd\" , \"ne\" , \"no\" , \"nb\" , \"nn\" , \"ii\" , \"oc\" , \"oj\" , \"cu\" , \"or\" , \"om\" , \"os\" , \"pi\" , \"ps\" , \"fa\" , \"pl\" , \"pt\" , \"pa\" , \"qu\" , \"rm\" , \"ro\" , \"ru\" , \"se\" , \"sm\" , \"sg\" , \"sa\" , \"sr\" , \"sh\" , \"st\" , \"tn\" , \"sn\" , \"ii\" , \"sd\" , \"si\" , \"ss\" , \"sk\" , \"sl\" , \"so\" , \"nr\" , \"es\" , \"su\" , \"sw\" , \"ss\" , \"sv\" , \"tl\" , \"ty\" , \"tg\" , \"ta\" , \"tt\" , \"te\" , \"th\" , \"bo\" , \"ti\" , \"to\" , \"ts\" , \"tr\" , \"tk\" , \"tw\" , \"ug\" , \"uk\" , \"ur\" , \"uz\" , \"ve\" , \"vi\" , \"vo\" , \"wa\" , \"cy\" , \"wo\" , \"fy\" , \"xh\" , \"yi\" , \"ji\" , \"yo\" , \"za\" , \"zu\" , ], \"http-equiv\" : [ \"content-security-policy\" , \"x-ua-compatible\" , \"content-type\" , \"default-style\" , \"refresh\" , \"content-language\" , ], \"id\" : \"any\" , \"in\" : [ \"SourceGraphic\" , \"SourceAlpha\" , \"BackgroundImage\" , \"BackgroundAlpha\" , \"FillPaint\" , \"StrokePaint\" ], \"in2\" : \"any\" , \"integrity\" : \"any\" , \"inert\" : \"inert\" , \"inputmode\" : [ \"decimal\" , \"email\" , \"none\" , \"numeric\" , \"search\" , \"tel\" , \"text\" , \"url\" , ], \"ismap\" : \"ismap\" , \"kind\" : [ \"captions\" , \"chapters\" , \"descriptions\" , \"metadata\" , \"subtitles\" ], \"k1\" : \"any\" , \"k2\" : \"any\" , \"k3\" : \"any\" , \"k4\" : \"any\" , \"label\" : \"any\" , \"lang\" : [ \"ab\" , \"aa\" , \"af\" , \"ak\" , \"sq\" , \"am\" , \"ar\" , \"an\" , \"hy\" , \"as\" , \"av\" , \"ae\" , \"ay\" , \"az\" , \"bm\" , \"ba\" , \"eu\" , \"be\" , \"bn\" , \"bh\" , \"bi\" , \"bs\" , \"br\" , \"bg\" , \"my\" , \"ca\" , \"ch\" , \"ce\" , \"ny\" , \"zh\" , \"zh-Hans\" , \"zh-Hant\" , \"cv\" , \"kw\" , \"co\" , \"cr\" , \"hr\" , \"cs\" , \"da\" , \"dv\" , \"nl\" , \"dz\" , \"en\" , \"eo\" , \"et\" , \"ee\" , \"fo\" , \"fj\" , \"fi\" , \"fr\" , \"ff\" , \"gl\" , \"gd\" , \"gv\" , \"ka\" , \"de\" , \"el\" , \"kl\" , \"gn\" , \"gu\" , \"ht\" , \"ha\" , \"he\" , \"hz\" , \"hi\" , \"ho\" , \"hu\" , \"is\" , \"io\" , \"ig\" , \"id\" , \"in\" , \"ia\" , \"ie\" , \"iu\" , \"ik\" , \"ga\" , \"it\" , \"ja\" , \"jv\" , \"kl\" , \"kn\" , \"kr\" , \"ks\" , \"kk\" , \"km\" , \"ki\" , \"rw\" , \"rn\" , \"ky\" , \"kv\" , \"kg\" , \"ko\" , \"ku\" , \"kj\" , \"lo\" , \"la\" , \"lv\" , \"li\" , \"ln\" , \"lt\" , \"lu\" , \"lg\" , \"lb\" , \"gv\" , \"mk\" , \"mg\" , \"ms\" , \"ml\" , \"mt\" , \"mi\" , \"mr\" , \"mh\" , \"mo\" , \"mn\" , \"na\" , \"nv\" , \"ng\" , \"nd\" , \"ne\" , \"no\" , \"nb\" , \"nn\" , \"ii\" , \"oc\" , \"oj\" , \"cu\" , \"or\" , \"om\" , \"os\" , \"pi\" , \"ps\" , \"fa\" , \"pl\" , \"pt\" , \"pa\" , \"qu\" , \"rm\" , \"ro\" , \"ru\" , \"se\" , \"sm\" , \"sg\" , \"sa\" , \"sr\" , \"sh\" , \"st\" , \"tn\" , \"sn\" , \"ii\" , \"sd\" , \"si\" , \"ss\" , \"sk\" , \"sl\" , \"so\" , \"nr\" , \"es\" , \"su\" , \"sw\" , \"ss\" , \"sv\" , \"tl\" , \"ty\" , \"tg\" , \"ta\" , \"tt\" , \"te\" , \"th\" , \"bo\" , \"ti\" , \"to\" , \"ts\" , \"tr\" , \"tk\" , \"tw\" , \"ug\" , \"uk\" , \"ur\" , \"uz\" , \"ve\" , \"vi\" , \"vo\" , \"wa\" , \"cy\" , \"wo\" , \"fy\" , \"xh\" , \"yi\" , \"ji\" , \"yo\" , \"za\" , \"zu\" , ], \"list\" : \"any\" , \"loading\" : [ \"lazy\" , \"eager\" ], # img, iframe \"loop\" : \"loop\" , \"low\" : \"any\" , # number \"max\" : \"any\" , # date \"markerUnits\" : [ \"strokeWidth\" , \"userSpaceOnUse\" ], \"markerWidth\" : \"any\" , \"markerHeight\" : \"any\" , \"maxlength\" : \"any\" , # number \"media\" : { \"operator\" : [ \"and\" , \"not\" , \",\" ], \"devices\" : [ \"all\" , \"aural\" , \"braille\" , \"handheld\" , \"projection\" , \"print\" , \"screen\" , \"tty\" , \"tv\" , ], \"values\" : [ \"width\" , \"height\" , \"device-width\" , \"device-height\" , \"orientation\" , \"aspect-ratio\" , \"device-aspect-ratio\" , \"color\" , \"color-index\" , \"monochrome\" , \"resolution\" , \"scan\" , \"grid\" , ], }, \"method\" : [ \"get\" , \"post\" ], \"min\" : \"any\" , \"mode\" : [ \"normal\" , \"multiply\" , \"screen\" , \"overlay\" , \"darken\" , \"lighten\" , \"color-dodge\" , \"color-burn\" , \"hard-light\" , \"soft-light\" , \"difference\" , \"exclusion\" , \"hue\" , \"saturation\" , \"color\" , \"luminosity\" ], \"multiple\" : \"multiple\" , \"muted\" : \"muted\" , \"name\" : \"any\" , \"numOctaves\" : \"any\" , \"novalidate\" : \"novalidate\" , \"open\" : \"open\" , \"optimum\" : \"any\" , # float number \"offset\" : \"any\" , \"orient\" : \"any\" , \"operator\" : [ \"over\" , \"in\" , \"out\" , \"atop\" , \"xor\" , \"arithmetic\" , \"erode\" , \"dilate\" ], \"pattern\" : \"any\" , \"crossorigin\" : \"any\" , \"placeholder\" : \"any\" , \"popover\" : \"popover\" , \"popovertarget\" : \"any\" , \"popovertargetaction\" : [ \"hide\" , \"show\" , \"toggle\" ], \"poster\" : \"any\" , \"preload\" : [ \"auto\" , \"metadata\" , \"none\" ], \"r\" : \"any\" , \"rx\" : \"any\" , \"ry\" : \"any\" , \"refX\" : \"any\" , \"refY\" : \"any\" , \"readonly\" : \"readonly\" , \"rel\" : { \"a\" : [ \"alternate\" , \"author\" , \"bookmark\" , \"external\" , \"help\" , \"license\" , \"next\" , \"nofollow\" , \"noopener\" , \"noreferrer\" , \"prev\" , \"search\" , \"tag\" , ], \"area\" : [ \"alternate\" , \"author\" , \"bookmark\" , \"help\" , \"license\" , \"next\" , \"nofollow\" , \"noreferrer\" , \"prefetch\" , \"prev\" , \"search\" , \"tag\" , ], \"link\" : [ \"alternate\" , \"author\" , \"dns-prefetch\" , \"help\" , \"icon\" , \"license\" , \"next\" , \"pingback\" , \"preconnect\" , \"prefetch\" , \"preload\" , \"prerender\" , \"prev\" , \"search\" , \"stylesheet\" , \"canonical\" , ], \"form\" : [ \"external\" , \"help\" , \"license\" , \"next\" , \"nofollow\" , \"noopener\" , \"noreferrer\" , \"opener\" , \"prev\" , \"search\" , ], }, \"required\" : \"required\" , \"reversed\" : \"reversed\" , \"referrerpolicy\" : [ \"no-referrer\" , \"no-referrer-when-downgrade\" , \"origin\" , \"origin-when-cross-origin\" , \"same-origin\" , \"strict-origin\" , \"strict-origin-when-cross-origin\" , \"unsafe-url\" ], \"role\" : [ \"alert\" , \"alertdialog\" , \"application\" , \"article\" , \"banner\" , \"button\" , \"cell\" , \"checkbox\" , \"columnheader\" , \"combobox\" , \"command\" , \"comment\" , \"complementary\" , \"composite\" , \"contentinfo\" , \"definition\" , \"dialog\" , \"directory\" , \"Deprecated\" , \"document\" , \"feed\" , \"figure\" , \"form\" , \"generic\" , \"grid\" , \"gridcell\" , \"group\" , \"heading\" , \"img\" , \"input\" , \"landmark\" , \"link\" , \"list\" , \"listbox\" , \"listitem\" , \"log\" , \"main\" , \"mark\" , \"marquee\" , \"math\" , \"menu\" , \"menubar\" , \"menuitem\" , \"menuitemcheckbox\" , \"menuitemradio\" , \"meter\" , \"navigation\" , \"none\" , \"note\" , \"option\" , \"presentation\" , \"progressbar\" , \"radio\" , \"radiogroup\" , \"range\" , \"region\" , \"roletype\" , \"row\" , \"rowgroup\" , \"rowheader\" , \"scrollbar\" , \"search\" , \"searchbox\" , \"section\" , \"sectionhead\" , \"select\" , \"separator\" , \"slider\" , \"spinbutton\" , \"status\" , \"Structural\" , \"structure\" , \"suggestion\" , \"switch\" , \"tab\" , \"table\" , \"tablist\" , \"tabpanel\" , \"term\" , \"textbox\" , \"timer\" , \"toolbar\" , \"tooltip\" , \"tree\" , \"treegrid\" , \"treeitem\" , \"widget\" , \"window\" , ], \"rows\" : \"any\" , # number \"rowspan\" : \"any\" , # number \"sandbox\" : \"sandbox\" , \"scope\" : [ \"col\" , \"row\" , \"colgroup\" , \"rowgroup\" ], \"selected\" : \"selected\" , \"shape\" : [ \"default\" , \"rect\" , \"circle\" , \"poly\" ], \"size\" : \"any\" , # number \"sizes\" : \"any\" , # numberxnumber \"slot\" : \"any\" , \"span\" : \"any\" , # number \"spellcheck\" : [ \"true\" , \"false\" ], \"spreadMethod\" : [ \"pad\" , \"reflect\" , \"repeat\" ], \"src\" : \"any\" , # url \"srcdoc\" : \"any\" , # HTML_code \"srclang\" : [ \"ab\" , \"aa\" , \"af\" , \"ak\" , \"sq\" , \"am\" , \"ar\" , \"an\" , \"hy\" , \"as\" , \"av\" , \"ae\" , \"ay\" , \"az\" , \"bm\" , \"ba\" , \"eu\" , \"be\" , \"bn\" , \"bh\" , \"bi\" , \"bs\" , \"br\" , \"bg\" , \"my\" , \"ca\" , \"ch\" , \"ce\" , \"ny\" , \"zh\" , \"zh-Hans\" , \"zh-Hant\" , \"cv\" , \"kw\" , \"co\" , \"cr\" , \"hr\" , \"cs\" , \"da\" , \"dv\" , \"nl\" , \"dz\" , \"en\" , \"eo\" , \"et\" , \"ee\" , \"fo\" , \"fj\" , \"fi\" , \"fr\" , \"ff\" , \"gl\" , \"gd\" , \"gv\" , \"ka\" , \"de\" , \"el\" , \"kl\" , \"gn\" , \"gu\" , \"ht\" , \"ha\" , \"he\" , \"hz\" , \"hi\" , \"ho\" , \"hu\" , \"is\" , \"io\" , \"ig\" , \"id\" , \"in\" , \"ia\" , \"ie\" , \"iu\" , \"ik\" , \"ga\" , \"it\" , \"ja\" , \"jv\" , \"kl\" , \"kn\" , \"kr\" , \"ks\" , \"kk\" , \"km\" , \"ki\" , \"rw\" , \"rn\" , \"ky\" , \"kv\" , \"kg\" , \"ko\" , \"ku\" , \"kj\" , \"lo\" , \"la\" , \"lv\" , \"li\" , \"ln\" , \"lt\" , \"lu\" , \"lg\" , \"lb\" , \"gv\" , \"mk\" , \"mg\" , \"ms\" , \"ml\" , \"mt\" , \"mi\" , \"mr\" , \"mh\" , \"mo\" , \"mn\" , \"na\" , \"nv\" , \"ng\" , \"nd\" , \"ne\" , \"no\" , \"nb\" , \"nn\" , \"ii\" , \"oc\" , \"oj\" , \"cu\" , \"or\" , \"om\" , \"os\" , \"pi\" , \"ps\" , \"fa\" , \"pl\" , \"pt\" , \"pa\" , \"qu\" , \"rm\" , \"ro\" , \"ru\" , \"se\" , \"sm\" , \"sg\" , \"sa\" , \"sr\" , \"sh\" , \"st\" , \"tn\" , \"sn\" , \"ii\" , \"sd\" , \"si\" , \"ss\" , \"sk\" , \"sl\" , \"so\" , \"nr\" , \"es\" , \"su\" , \"sw\" , \"ss\" , \"sv\" , \"tl\" , \"ty\" , \"tg\" , \"ta\" , \"tt\" , \"te\" , \"th\" , \"bo\" , \"ti\" , \"to\" , \"ts\" , \"tr\" , \"tk\" , \"tw\" , \"ug\" , \"uk\" , \"ur\" , \"uz\" , \"ve\" , \"vi\" , \"vo\" , \"wa\" , \"cy\" , \"wo\" , \"fy\" , \"xh\" , \"yi\" , \"ji\" , \"yo\" , \"za\" , \"zu\" , ], \"srcset\" : \"any\" , # url \"start\" : \"any\" , # number \"step\" : \"any\" , # number \"stop-color\" : \"any\" , \"stop-opacity\" : \"any\" , \"stroke\" : \"any\" , \"stroke-width\" : \"any\" , \"stroke-dasharray\" : \"any\" , \"stroke-dashoffset\" : \"any\" , \"stroke-opacity\" : \"any\" , \"stdDeviation\" : \"any\" , # Blur amount \"seed\" : \"any\" , \"stitchTiles\" : [ \"stitch\" , \"noStitch\" ], \"stroke-linecap\" : [ \"butt\" , \"round\" , \"square\" , \"inherit\" ], \"stroke-linejoin\" : [ \"miter\" , \"round\" , \"bevel\" , \"inherit\" ], \"style\" : \"any\" , # css \"tabindex\" : \"any\" , # number \"target\" : [ \"_blank\" , \"_self\" , \"_parent\" , \"_top\" , \"framename\" , ], # [0]=any tag, [1]= <base>tag \"text-anchor\" : [ \"start\" , \"middle\" , \"end\" , \"inherit\" ], \"title\" : \"any\" , \"translate\" : [ \"yes\" , \"no\" ], \"transform\" : \"any\" , \"type\" : { # --- HTML Forms --- \"input\" : [ \"button\" , \"checkbox\" , \"color\" , \"date\" , \"datetime-local\" , \"email\" , \"file\" , \"hidden\" , \"image\" , \"month\" , \"number\" , \"password\" , \"radio\" , \"range\" , \"reset\" , \"search\" , \"submit\" , \"tel\" , \"text\" , \"time\" , \"url\" , \"week\" ], \"button\" : [ \"submit\" , \"reset\" , \"button\" ], # --- HTML Lists --- \"ol\" : [ \"1\" , \"a\" , \"A\" , \"i\" , \"I\" ], # --- HTML Resources --- \"script\" : [ \"text/javascript\" , \"module\" , \"application/javascript\" , \"application/ecmascript\" , \"application/json\" , \"importmap\" ], \"style\" : [ \"text/css\" ], \"link\" : [ \"text/css\" , \"image/x-icon\" , \"image/png\" , \"image/jpeg\" , \"application/pdf\" , \"font/woff2\" ], # MIME types (incomplete list, but common ones) \"object\" : \"any\" , # MIME types \"embed\" : \"any\" , # MIME types \"source\" : \"any\" , # MIME types (audio/video) # --- HTML Menu/Command (Obsolete but sometimes used) --- \"menu\" : [ \"list\" , \"context\" , \"toolbar\" ], # --- SVG Filters --- \"feColorMatrix\" : [ \"matrix\" , \"saturate\" , \"hueRotate\" , \"luminanceToAlpha\" ], \"feTurbulence\" : [ \"fractalNoise\" , \"turbulence\" ], \"feFuncR\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], \"feFuncG\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], \"feFuncB\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], \"feFuncA\" : [ \"identity\" , \"table\" , \"discrete\" , \"linear\" , \"gamma\" ], # --- SVG Animation --- \"animateTransform\" : [ \"translate\" , \"scale\" , \"rotate\" , \"skewX\" , \"skewY\" ], }, # [0]=<input>, [1]=<bottun>, [2]=any \"usemap\" : [ \"#any\" ], # starts with '#' \"value\" : \"any\" , \"values\" : \"any\" , # Matrix values \"visibility\" : [ \"visible\" , \"hidden\" , \"collapse\" , \"inherit\" ], \"width\" : \"any\" , # number \"wrap\" : [ \"soft\" , \"hard\" ], \"x\" : \"any\" , 'xmlns' :[ \"http://www.w3.org/2000/svg\" ], \"y\" : \"any\" , \"x1\" : \"any\" , \"y1\" : \"any\" , \"x2\" : \"any\" , \"y2\" : \"any\" , \"points\" : \"any\" , # Polygon points string \"viewBox\" : \"any\" , # \"min-x min-y width height\" \"preserveAspectRatio\" : \"any\" , \"opacity\" : \"any\" , } BOOTSTRAP_DATA_BS_ATTRIBUTE = { # === General (used across multiple components) === \"data-bs-toggle\" : [ \"modal\" , \"dropdown\" , \"collapse\" , \"offcanvas\" , \"tooltip\" , \"popover\" , \"tab\" , \"button\" , ], \"data-bs-dismiss\" : [ \"modal\" , \"alert\" , \"offcanvas\" , \"toast\" ], \"data-bs-container\" : [ \"body\" , \"element selector\" ], \"data-bs-placement\" : [ \"top\" , \"bottom\" , \"left\" , \"right\" , \"auto\" , \"top-start\" , \"top-end\" , \"bottom-start\" , \"bottom-end\" , \"left-start\" , \"left-end\" , \"right-start\" , \"right-end\" , ], # === Modals === \"data-bs-backdrop\" : [ \"true\" , \"false\" , \"static\" ], \"data-bs-keyboard\" : [ \"true\" , \"false\" ], \"data-bs-focus\" : [ \"true\" , \"false\" ], \"data-bs-show\" : [ \"true\" , \"false\" ], # === Collapse / Accordion === \"data-bs-target\" : \"any\" , \"data-bs-parent\" : \"any\" , # === Dropdowns === \"data-bs-offset\" : \"any\" , \"data-bs-reference\" : [ \"toggle\" , \"parent\" , \"body\" ], \"data-bs-display\" : [ \"dynamic\" , \"static\" ], \"data-bs-auto-close\" : [ \"true\" , \"false\" , \"inside\" , \"outside\" ], # === Offcanvas === \"data-bs-scroll\" : [ \"true\" , \"false\" ], # === Tooltips & Popovers === \"data-bs-title\" : \"any\" , \"data-bs-content\" : \"any\" , \"data-bs-html\" : [ \"true\" , \"false\" ], \"data-bs-delay\" : \"any\" , \"data-bs-trigger\" : [ \"hover\" , \"focus\" , \"click\" , \"manual\" ], \"data-bs-custom-class\" : \"any\" , \"data-bs-boundary\" : [ \"clippingParents\" , \"viewport\" , \"window\" ], # === Carousel === \"data-bs-slide\" : [ \"next\" , \"prev\" ], \"data-bs-ride\" : [ \"carousel\" ], \"data-bs-interval\" : [ \"any\" , \"false\" ], \"data-bs-pause\" : [ \"hover\" , \"false\" ], \"data-bs-wrap\" : [ \"true\" , \"false\" ], \"data-bs-touch\" : [ \"true\" , \"false\" ], \"data-bs-slide-to\" : \"any\" , # === Toasts === \"data-bs-autohide\" : [ \"true\" , \"false\" ], } ARIA_ATTRIBUTES = { # === Global States and Properties === \"aria-activedescendant\" : \"any\" , \"aria-atomic\" : [ \"true\" , \"false\" ], \"aria-autocomplete\" : [ \"none\" , \"inline\" , \"list\" , \"both\" ], \"aria-busy\" : [ \"true\" , \"false\" ], \"aria-checked\" : [ \"true\" , \"false\" , \"mixed\" , \"undefined\" ], \"aria-colcount\" : \"any\" , \"aria-colindex\" : \"any\" , \"aria-colspan\" : \"any\" , \"aria-controls\" : \"any\" , \"aria-current\" : [ \"page\" , \"step\" , \"location\" , \"date\" , \"time\" , \"true\" , \"false\" ], \"aria-describedby\" : \"any\" , \"aria-details\" : \"any\" , \"aria-disabled\" : [ \"true\" , \"false\" ], \"aria-errormessage\" : \"any\" , \"aria-expanded\" : [ \"true\" , \"false\" , \"undefined\" ], \"aria-flowto\" : \"any\" , \"aria-haspopup\" : [ \"true\" , \"false\" , \"menu\" , \"listbox\" , \"tree\" , \"grid\" , \"dialog\" ], \"aria-hidden\" : [ \"true\" , \"false\" ], \"aria-invalid\" : [ \"grammar\" , \"false\" , \"spelling\" , \"true\" ], \"aria-keyshortcuts\" : \"any\" , \"aria-label\" : \"any\" , \"aria-labelledby\" : \"any\" , \"aria-live\" : [ \"off\" , \"polite\" , \"assertive\" ], \"aria-modal\" : [ \"true\" , \"false\" ], \"aria-multiline\" : [ \"true\" , \"false\" ], \"aria-multiselectable\" : [ \"true\" , \"false\" ], \"aria-orientation\" : [ \"horizontal\" , \"vertical\" ], \"aria-owns\" : \"any\" , \"aria-placeholder\" : \"any\" , \"aria-posinset\" : \"any\" , \"aria-pressed\" : [ \"true\" , \"false\" , \"mixed\" ], \"aria-readonly\" : [ \"true\" , \"false\" ], \"aria-relevant\" : [ \"additions\" , \"removals\" , \"text\" , \"all\" ], \"aria-required\" : [ \"true\" , \"false\" ], \"aria-roledescription\" : \"any\" , \"aria-rowcount\" : \"any\" , \"aria-rowindex\" : \"any\" , \"aria-rowspan\" : \"any\" , \"aria-selected\" : [ \"true\" , \"false\" ], \"aria-setsize\" : \"any\" , \"aria-sort\" : [ \"none\" , \"ascending\" , \"descending\" , \"other\" ], \"aria-valuemax\" : \"any\" , \"aria-valuemin\" : \"any\" , \"aria-valuenow\" : \"any\" , \"aria-valuetext\" : \"any\" , # === Application / Structural Roles === \"role\" : [ \"alert\" , \"alertdialog\" , \"application\" , \"article\" , \"banner\" , \"button\" , \"cell\" , \"checkbox\" , \"columnheader\" , \"combobox\" , \"complementary\" , \"contentinfo\" , \"definition\" , \"dialog\" , \"directory\" , \"document\" , \"feed\" , \"figure\" , \"form\" , \"grid\" , \"gridcell\" , \"group\" , \"heading\" , \"img\" , \"link\" , \"list\" , \"listbox\" , \"listitem\" , \"log\" , \"main\" , \"marquee\" , \"math\" , \"menu\" , \"menubar\" , \"menuitem\" , \"menuitemcheckbox\" , \"menuitemradio\" , \"navigation\" , \"none\" , \"note\" , \"option\" , \"presentation\" , \"progressbar\" , \"radio\" , \"radiogroup\" , \"region\" , \"row\" , \"rowgroup\" , \"rowheader\" , \"scrollbar\" , \"search\" , \"searchbox\" , \"separator\" , \"slider\" , \"spinbutton\" , \"status\" , \"switch\" , \"tab\" , \"table\" , \"tablist\" , \"tabpanel\" , \"term\" , \"textbox\" , \"timer\" , \"toolbar\" , \"tooltip\" , \"tree\" , \"treegrid\" , \"treeitem\" , ], }","title":"AttributeValue"},{"location":"reference/probo/components/attributes/#probo.components.attributes.ElementAttributeValidator","text":"Class to validate HTML attributes for elements. This class checks if the provided attributes are valid for a given HTML element. Source code in src\\probo\\components\\attributes.py 1919 1920 1921 1922 1923 1924 1925 1926 1927 1928 1929 1930 1931 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 class ElementAttributeValidator : \"\"\"Class to validate HTML attributes for elements. This class checks if the provided attributes are valid for a given HTML element.\"\"\" def __init__ ( self , element_tag : str = \"\" , ** kwargs ): self . element_tag = element_tag if element_tag else \"\" self . raw_attrs = kwargs self . valid_attrs = {} self . error_attrs = [] # Run validation on init self . is_valid = self . validate () def validate ( self ) -> bool : \"\"\" Core Logic. Returns True if all attributes are processed successfully. Populates self.valid_attrs with the final, clean dictionary. \"\"\" if not self . raw_attrs : return True all_valid = True el_attr_definitions = ElementAttribute . ELEMENT_ATTRIBUTE . value # Access the master dictionary definitions = AttributeValue . ATTRIBUTE_VALUE . value for raw_key , value in self . raw_attrs . items (): # 1. NORMALIZE KEY (class_ -> class, aria_hidden -> aria-hidden) if len ( raw_key ) > 1 : key = raw_key [ 0 ] . lower () + raw_key [ 1 :] . strip () . replace ( \"_\" , \"-\" ) else : key = raw_key . lower () . strip () . replace ( \"_\" , \"-\" ) # --- SKIP PART 1: BOOLEANS --- if isinstance ( value , bool ) : if value is True : self . valid_attrs [ key ] = True # If False, we ignore it (it won't render) continue # --- SKIP PART 2: WILDCARDS --- # Bootstrap (data-*), HTMX (hx-*), Aria (aria-*), Events (on*), if key . startswith (( \"data-\" , \"aria-\" , \"hx-\" , \"on\" , \"xml\" , \"ng-\" , \"v-\" )): self . valid_attrs [ key ] = value continue el_attr_check = el_attr_definitions . get ( key , None ) if ( el_attr_check and not self . element_tag in el_attr_check ): return False # --- SKIP PART 3: THE CLUSTER (Fast Pass) --- in_cluster = key in ATTR_CLUSTER rule = definitions . get ( key , None ) # --- CHECK: DEFINITIONS --- if rule : # Case A: 'any' -> Accept anything if rule == \"any\" : self . valid_attrs [ key ] = value continue # Case B: List of allowed values -> Check it if isinstance ( rule , list ): # Convert to string to handle ints safely if str ( value ) not in rule : self . error_attrs . append ( f \" { key } =' { value } ' (Expected: { rule } )\" ) all_valid = False continue else : self . valid_attrs [ key ] = value continue # Case C: Dictionary (Element-Specific Rules) -> Check it if isinstance ( rule , dict ): tag_clean = self . element_tag . strip ( \"<>\" ) if tag_clean in rule : allowed_vals = rule [ tag_clean ] if str ( value ) not in allowed_vals : self . error_attrs . append ( f \" { key } =' { value } ' on < { tag_clean } > (Expected: { allowed_vals } )\" ) all_valid = False continue else : # Tag not specified in rule, be loose self . valid_attrs [ key ] = value continue # --- FALLBACK --- if in_cluster : self . valid_attrs [ key ] = value else : # Unknown/Custom attribute -> Allow it self . valid_attrs [ key ] = value return all_valid","title":"ElementAttributeValidator"},{"location":"reference/probo/components/attributes/#probo.components.attributes.ElementAttributeValidator.validate","text":"Core Logic. Returns True if all attributes are processed successfully. Populates self.valid_attrs with the final, clean dictionary. Source code in src\\probo\\components\\attributes.py 1932 1933 1934 1935 1936 1937 1938 1939 1940 1941 1942 1943 1944 1945 1946 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 1964 1965 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 1983 1984 1985 1986 1987 1988 1989 1990 1991 1992 1993 1994 1995 1996 1997 1998 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 2013 2014 2015 2016 def validate ( self ) -> bool : \"\"\" Core Logic. Returns True if all attributes are processed successfully. Populates self.valid_attrs with the final, clean dictionary. \"\"\" if not self . raw_attrs : return True all_valid = True el_attr_definitions = ElementAttribute . ELEMENT_ATTRIBUTE . value # Access the master dictionary definitions = AttributeValue . ATTRIBUTE_VALUE . value for raw_key , value in self . raw_attrs . items (): # 1. NORMALIZE KEY (class_ -> class, aria_hidden -> aria-hidden) if len ( raw_key ) > 1 : key = raw_key [ 0 ] . lower () + raw_key [ 1 :] . strip () . replace ( \"_\" , \"-\" ) else : key = raw_key . lower () . strip () . replace ( \"_\" , \"-\" ) # --- SKIP PART 1: BOOLEANS --- if isinstance ( value , bool ) : if value is True : self . valid_attrs [ key ] = True # If False, we ignore it (it won't render) continue # --- SKIP PART 2: WILDCARDS --- # Bootstrap (data-*), HTMX (hx-*), Aria (aria-*), Events (on*), if key . startswith (( \"data-\" , \"aria-\" , \"hx-\" , \"on\" , \"xml\" , \"ng-\" , \"v-\" )): self . valid_attrs [ key ] = value continue el_attr_check = el_attr_definitions . get ( key , None ) if ( el_attr_check and not self . element_tag in el_attr_check ): return False # --- SKIP PART 3: THE CLUSTER (Fast Pass) --- in_cluster = key in ATTR_CLUSTER rule = definitions . get ( key , None ) # --- CHECK: DEFINITIONS --- if rule : # Case A: 'any' -> Accept anything if rule == \"any\" : self . valid_attrs [ key ] = value continue # Case B: List of allowed values -> Check it if isinstance ( rule , list ): # Convert to string to handle ints safely if str ( value ) not in rule : self . error_attrs . append ( f \" { key } =' { value } ' (Expected: { rule } )\" ) all_valid = False continue else : self . valid_attrs [ key ] = value continue # Case C: Dictionary (Element-Specific Rules) -> Check it if isinstance ( rule , dict ): tag_clean = self . element_tag . strip ( \"<>\" ) if tag_clean in rule : allowed_vals = rule [ tag_clean ] if str ( value ) not in allowed_vals : self . error_attrs . append ( f \" { key } =' { value } ' on < { tag_clean } > (Expected: { allowed_vals } )\" ) all_valid = False continue else : # Tag not specified in rule, be loose self . valid_attrs [ key ] = value continue # --- FALLBACK --- if in_cluster : self . valid_attrs [ key ] = value else : # Unknown/Custom attribute -> Allow it self . valid_attrs [ key ] = value return all_valid","title":"validate"},{"location":"reference/probo/components/base/","text":"base BaseHTMLElement Bases: ABC Base class for all HTML elements. Provides common initialization for content and attributes. Source code in src\\probo\\components\\base.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 class BaseHTMLElement ( ABC ): \"\"\" Base class for all HTML elements. Provides common initialization for content and attributes. \"\"\" def __init__ ( self , * content , ** kwargs ): \"\"\" Initializes the HTML element. Args: content: The content of the element. Can be a string, or another BaseHTMLElement instance, or a list of BaseHTMLElement instances. **kwargs: Arbitrary keyword arguments representing HTML attributes. (e.g., class_='my-class', id='my-id', style='color: red;'). \"\"\" self . content = content self . attributes = kwargs @property def attr_manager ( self ): return ElementAttributeManipulator ( self . attributes ) def _get_rendered_content ( self ): \"\"\" Recursively renders content if it consists of other BaseHTMLElement instances. \"\"\" is_nested_iter = any ([ not isinstance ( x , ( str , bytes )) for x in self . content ]) if not is_nested_iter : return \"\" . join ( [ item . render () if hasattr ( item , \"render\" ) else str ( item ) for item in self . content ] ) else : results = [] for sub_item in self . content : if hasattr ( sub_item , \"render\" ): results . append ( sub_item . render ()) elif isinstance ( sub_item , Iterable ): results . append ( \"\" . join ( [ x . render () if hasattr ( x , \"render\" ) else x for x in sub_item ] ) ) else : results . append ( str ( sub_item )) return \"\" . join ( results ) @abstractmethod def render ( self ): \"\"\" Abstract method to be implemented by subclasses to render their specific HTML. \"\"\" raise NotImplementedError ( \"Subclasses must implement the render method.\" ) __init__ ( * content , ** kwargs ) Initializes the HTML element. Args: content: The content of the element. Can be a string, or another BaseHTMLElement instance, or a list of BaseHTMLElement instances. **kwargs: Arbitrary keyword arguments representing HTML attributes. (e.g., class_='my-class', id='my-id', style='color: red;'). Source code in src\\probo\\components\\base.py 176 177 178 179 180 181 182 183 184 185 186 def __init__ ( self , * content , ** kwargs ): \"\"\" Initializes the HTML element. Args: content: The content of the element. Can be a string, or another BaseHTMLElement instance, or a list of BaseHTMLElement instances. **kwargs: Arbitrary keyword arguments representing HTML attributes. (e.g., class_='my-class', id='my-id', style='color: red;'). \"\"\" self . content = content self . attributes = kwargs render () abstractmethod Abstract method to be implemented by subclasses to render their specific HTML. Source code in src\\probo\\components\\base.py 222 223 224 225 226 227 @abstractmethod def render ( self ): \"\"\" Abstract method to be implemented by subclasses to render their specific HTML. \"\"\" raise NotImplementedError ( \"Subclasses must implement the render method.\" ) ComponentAttrManager Bases: ElementAttributeManipulator Manages the default attributes for a Component's root element. Source code in src\\probo\\components\\base.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class ComponentAttrManager ( ElementAttributeManipulator ): \"\"\" Manages the default attributes for a Component's root element. \"\"\" # The actual storage def __init__ ( self , ** childern ): self . childern = childern self . root = {} self . attrs = {} def add_child ( self , name , ** attrs ): self . childern [ name ] = attrs return self def update ( self , name , ** kwargs ): \"\"\" Bulk update attributes from kwargs. Handles class merging intelligently if 'class' is passed. \"\"\" for k , v in kwargs . items (): clean_key = self . _normalize_key ( k ) if clean_key == 'class' : # If updating class, use add_class logic to merge, or overwrite? # Usually update() implies overwrite or merge. # Let's support space-separated string merging for safety. if isinstance ( v , str ): self . add_class ( * v . split ()) elif isinstance ( v , ( list , tuple )): self . add_class ( * v ) else : self . attrs [ clean_key ] = v if self . childern . get ( name , None ): self . childer [ name ] . update ( self . attrs ) else : self . childer [ name ] = self . attrs self . clear () return self def clear ( self ): \"\"\"Wipes all attributes.\"\"\" self . attrs . clear () return self def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Returns the raw dictionary for rendering.\"\"\" return self . childern clear () Wipes all attributes. Source code in src\\probo\\components\\base.py 161 162 163 164 def clear ( self ): \"\"\"Wipes all attributes.\"\"\" self . attrs . clear () return self to_dict () Returns the raw dictionary for rendering. Source code in src\\probo\\components\\base.py 166 167 168 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Returns the raw dictionary for rendering.\"\"\" return self . childern update ( name , ** kwargs ) Bulk update attributes from kwargs. Handles class merging intelligently if 'class' is passed. Source code in src\\probo\\components\\base.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def update ( self , name , ** kwargs ): \"\"\" Bulk update attributes from kwargs. Handles class merging intelligently if 'class' is passed. \"\"\" for k , v in kwargs . items (): clean_key = self . _normalize_key ( k ) if clean_key == 'class' : # If updating class, use add_class logic to merge, or overwrite? # Usually update() implies overwrite or merge. # Let's support space-separated string merging for safety. if isinstance ( v , str ): self . add_class ( * v . split ()) elif isinstance ( v , ( list , tuple )): self . add_class ( * v ) else : self . attrs [ clean_key ] = v if self . childern . get ( name , None ): self . childer [ name ] . update ( self . attrs ) else : self . childer [ name ] = self . attrs self . clear () return self ElementAttributeManipulator Source code in src\\probo\\components\\base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class ElementAttributeManipulator : def __init__ ( self , attr_dict = None , ** kwargs ): # 1. Initialize storage per instance (Fixes Shared Memory Bug) self . attrs : Dict [ str , str ] = dict () if attr_dict is None else attr_dict self . attrs . update ( kwargs ) def add_class ( self , cls_str : str ) -> Self : \"\"\"Smartly adds class(es) without duplicating.\"\"\" # Split existing classes into a set to avoid duplicates current_classes = set ( self . attrs . get ( \"Class\" , \"\" ) . split ()) new_classes = cls_str . split () # Add new ones current_classes . update ( set ( new_classes )) # Save back as sorted string (cleaner HTML) self . attrs [ \"Class\" ] = \" \" . join ( sorted ( current_classes )) return self def remove_class ( self , cls_str : str ) -> Self : current_classes = self . attrs . get ( \"Class\" , \"\" ) . split () # Remove all instances of the class if cls_str in current_classes : # List comprehension to remove all occurrences safely current_classes = [ c for c in current_classes if c != cls_str ] self . attrs [ \"Class\" ] = \" \" . join ( current_classes ) return self def contains_class ( self , cls_str : str ) -> bool : \"\"\"Checks for exact class match.\"\"\" current_classes = self . attrs . get ( \"Class\" , \"\" ) . split () return cls_str in current_classes def toggle_class ( self , class_name : str , condition : bool = None ) -> Self : # Force Add if condition is True : return self . add_class ( class_name ) # Force Remove if condition is False : return self . remove_class ( class_name ) # Standard Toggle if self . contains_class ( class_name ): return self . remove_class ( class_name ) return self . add_class ( class_name ) def set_attr ( self , key : str , value : Union [ str , bool ]) -> Self : if isinstance ( value , bool ): if value is False : self . remove_attr ( key ) else : self . attrs [ key ] = \"\" # Boolean attribute (e.g. disabled=\"\") else : self . attrs [ self . _normalize_attr_key ( key )] = str ( value ) return self def set_bulk_attr ( self , ** attrs ) -> Self : for key , value in attrs . items (): self . set_attr ( key , value ) return self def get_attr ( self , key : str , default = None ) -> str : return self . attrs . get ( self . _normalize_attr_key ( key ), default ) def remove_attr ( self , key : str ) -> Self : \"\"\"Safely removes an attribute if it exists.\"\"\" if key in self . attrs : del self . attrs [ self . _normalize_attr_key ( key )] return self def set_data ( self , key : str , value : str ) -> Self : clean_key = key . replace ( \"_\" , \"-\" ) return self . set_attr ( f \"data- { clean_key } \" , value ) def set_id ( self , unique_id : str ) -> Self : return self . set_attr ( \"Id\" , unique_id ) def merge_attrs ( self , ** kwargs ) -> Self : for key , value in kwargs . items (): if key == \"Class\" : self . add_class ( value ) else : clean_key = key . replace ( \"_\" , \"-\" ) self . set_attr ( clean_key , value ) return self def _normalize_attr_key ( self , key ): reserved_attrs = { 'id' : 'Id' , 'class' : 'Class' ,} return reserved_attrs . get ( key . lower (), key ) def set_style ( self , property : str , value : str ) -> Self : \"\"\"Updates inline style intelligently.\"\"\" # 1. Parse existing style current_style_str = self . attrs . get ( \"style\" , \"\" ) style_dict = self . _parse_style_string ( current_style_str ) # 2. Update the property style_dict [ property ] = value # 3. Rebuild string new_style_str = \"; \" . join ([ f \" { k } : { v } \" for k , v in style_dict . items ()]) self . attrs [ \"style\" ] = new_style_str return self def _parse_style_string ( self , style_str : str ) -> Dict [ str , str ]: \"\"\"Helper to convert 'color: red; width: 10px' into a dict.\"\"\" if not style_str : return {} result = {} # Split by semicolon, then by colon items = style_str . split ( \";\" ) for item in items : if \":\" in item : key , val = item . split ( \":\" , 1 ) result [ key . strip ()] = val . strip () return result add_class ( cls_str ) Smartly adds class(es) without duplicating. Source code in src\\probo\\components\\base.py 12 13 14 15 16 17 18 19 20 21 22 def add_class ( self , cls_str : str ) -> Self : \"\"\"Smartly adds class(es) without duplicating.\"\"\" # Split existing classes into a set to avoid duplicates current_classes = set ( self . attrs . get ( \"Class\" , \"\" ) . split ()) new_classes = cls_str . split () # Add new ones current_classes . update ( set ( new_classes )) # Save back as sorted string (cleaner HTML) self . attrs [ \"Class\" ] = \" \" . join ( sorted ( current_classes )) return self contains_class ( cls_str ) Checks for exact class match. Source code in src\\probo\\components\\base.py 35 36 37 38 def contains_class ( self , cls_str : str ) -> bool : \"\"\"Checks for exact class match.\"\"\" current_classes = self . attrs . get ( \"Class\" , \"\" ) . split () return cls_str in current_classes remove_attr ( key ) Safely removes an attribute if it exists. Source code in src\\probo\\components\\base.py 70 71 72 73 74 def remove_attr ( self , key : str ) -> Self : \"\"\"Safely removes an attribute if it exists.\"\"\" if key in self . attrs : del self . attrs [ self . _normalize_attr_key ( key )] return self set_style ( property , value ) Updates inline style intelligently. Source code in src\\probo\\components\\base.py 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_style ( self , property : str , value : str ) -> Self : \"\"\"Updates inline style intelligently.\"\"\" # 1. Parse existing style current_style_str = self . attrs . get ( \"style\" , \"\" ) style_dict = self . _parse_style_string ( current_style_str ) # 2. Update the property style_dict [ property ] = value # 3. Rebuild string new_style_str = \"; \" . join ([ f \" { k } : { v } \" for k , v in style_dict . items ()]) self . attrs [ \"style\" ] = new_style_str return self","title":"base"},{"location":"reference/probo/components/base/#base","text":"","title":"base"},{"location":"reference/probo/components/base/#probo.components.base.BaseHTMLElement","text":"Bases: ABC Base class for all HTML elements. Provides common initialization for content and attributes. Source code in src\\probo\\components\\base.py 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 class BaseHTMLElement ( ABC ): \"\"\" Base class for all HTML elements. Provides common initialization for content and attributes. \"\"\" def __init__ ( self , * content , ** kwargs ): \"\"\" Initializes the HTML element. Args: content: The content of the element. Can be a string, or another BaseHTMLElement instance, or a list of BaseHTMLElement instances. **kwargs: Arbitrary keyword arguments representing HTML attributes. (e.g., class_='my-class', id='my-id', style='color: red;'). \"\"\" self . content = content self . attributes = kwargs @property def attr_manager ( self ): return ElementAttributeManipulator ( self . attributes ) def _get_rendered_content ( self ): \"\"\" Recursively renders content if it consists of other BaseHTMLElement instances. \"\"\" is_nested_iter = any ([ not isinstance ( x , ( str , bytes )) for x in self . content ]) if not is_nested_iter : return \"\" . join ( [ item . render () if hasattr ( item , \"render\" ) else str ( item ) for item in self . content ] ) else : results = [] for sub_item in self . content : if hasattr ( sub_item , \"render\" ): results . append ( sub_item . render ()) elif isinstance ( sub_item , Iterable ): results . append ( \"\" . join ( [ x . render () if hasattr ( x , \"render\" ) else x for x in sub_item ] ) ) else : results . append ( str ( sub_item )) return \"\" . join ( results ) @abstractmethod def render ( self ): \"\"\" Abstract method to be implemented by subclasses to render their specific HTML. \"\"\" raise NotImplementedError ( \"Subclasses must implement the render method.\" )","title":"BaseHTMLElement"},{"location":"reference/probo/components/base/#probo.components.base.BaseHTMLElement.__init__","text":"Initializes the HTML element. Args: content: The content of the element. Can be a string, or another BaseHTMLElement instance, or a list of BaseHTMLElement instances. **kwargs: Arbitrary keyword arguments representing HTML attributes. (e.g., class_='my-class', id='my-id', style='color: red;'). Source code in src\\probo\\components\\base.py 176 177 178 179 180 181 182 183 184 185 186 def __init__ ( self , * content , ** kwargs ): \"\"\" Initializes the HTML element. Args: content: The content of the element. Can be a string, or another BaseHTMLElement instance, or a list of BaseHTMLElement instances. **kwargs: Arbitrary keyword arguments representing HTML attributes. (e.g., class_='my-class', id='my-id', style='color: red;'). \"\"\" self . content = content self . attributes = kwargs","title":"__init__"},{"location":"reference/probo/components/base/#probo.components.base.BaseHTMLElement.render","text":"Abstract method to be implemented by subclasses to render their specific HTML. Source code in src\\probo\\components\\base.py 222 223 224 225 226 227 @abstractmethod def render ( self ): \"\"\" Abstract method to be implemented by subclasses to render their specific HTML. \"\"\" raise NotImplementedError ( \"Subclasses must implement the render method.\" )","title":"render"},{"location":"reference/probo/components/base/#probo.components.base.ComponentAttrManager","text":"Bases: ElementAttributeManipulator Manages the default attributes for a Component's root element. Source code in src\\probo\\components\\base.py 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 class ComponentAttrManager ( ElementAttributeManipulator ): \"\"\" Manages the default attributes for a Component's root element. \"\"\" # The actual storage def __init__ ( self , ** childern ): self . childern = childern self . root = {} self . attrs = {} def add_child ( self , name , ** attrs ): self . childern [ name ] = attrs return self def update ( self , name , ** kwargs ): \"\"\" Bulk update attributes from kwargs. Handles class merging intelligently if 'class' is passed. \"\"\" for k , v in kwargs . items (): clean_key = self . _normalize_key ( k ) if clean_key == 'class' : # If updating class, use add_class logic to merge, or overwrite? # Usually update() implies overwrite or merge. # Let's support space-separated string merging for safety. if isinstance ( v , str ): self . add_class ( * v . split ()) elif isinstance ( v , ( list , tuple )): self . add_class ( * v ) else : self . attrs [ clean_key ] = v if self . childern . get ( name , None ): self . childer [ name ] . update ( self . attrs ) else : self . childer [ name ] = self . attrs self . clear () return self def clear ( self ): \"\"\"Wipes all attributes.\"\"\" self . attrs . clear () return self def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Returns the raw dictionary for rendering.\"\"\" return self . childern","title":"ComponentAttrManager"},{"location":"reference/probo/components/base/#probo.components.base.ComponentAttrManager.clear","text":"Wipes all attributes. Source code in src\\probo\\components\\base.py 161 162 163 164 def clear ( self ): \"\"\"Wipes all attributes.\"\"\" self . attrs . clear () return self","title":"clear"},{"location":"reference/probo/components/base/#probo.components.base.ComponentAttrManager.to_dict","text":"Returns the raw dictionary for rendering. Source code in src\\probo\\components\\base.py 166 167 168 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Returns the raw dictionary for rendering.\"\"\" return self . childern","title":"to_dict"},{"location":"reference/probo/components/base/#probo.components.base.ComponentAttrManager.update","text":"Bulk update attributes from kwargs. Handles class merging intelligently if 'class' is passed. Source code in src\\probo\\components\\base.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def update ( self , name , ** kwargs ): \"\"\" Bulk update attributes from kwargs. Handles class merging intelligently if 'class' is passed. \"\"\" for k , v in kwargs . items (): clean_key = self . _normalize_key ( k ) if clean_key == 'class' : # If updating class, use add_class logic to merge, or overwrite? # Usually update() implies overwrite or merge. # Let's support space-separated string merging for safety. if isinstance ( v , str ): self . add_class ( * v . split ()) elif isinstance ( v , ( list , tuple )): self . add_class ( * v ) else : self . attrs [ clean_key ] = v if self . childern . get ( name , None ): self . childer [ name ] . update ( self . attrs ) else : self . childer [ name ] = self . attrs self . clear () return self","title":"update"},{"location":"reference/probo/components/base/#probo.components.base.ElementAttributeManipulator","text":"Source code in src\\probo\\components\\base.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class ElementAttributeManipulator : def __init__ ( self , attr_dict = None , ** kwargs ): # 1. Initialize storage per instance (Fixes Shared Memory Bug) self . attrs : Dict [ str , str ] = dict () if attr_dict is None else attr_dict self . attrs . update ( kwargs ) def add_class ( self , cls_str : str ) -> Self : \"\"\"Smartly adds class(es) without duplicating.\"\"\" # Split existing classes into a set to avoid duplicates current_classes = set ( self . attrs . get ( \"Class\" , \"\" ) . split ()) new_classes = cls_str . split () # Add new ones current_classes . update ( set ( new_classes )) # Save back as sorted string (cleaner HTML) self . attrs [ \"Class\" ] = \" \" . join ( sorted ( current_classes )) return self def remove_class ( self , cls_str : str ) -> Self : current_classes = self . attrs . get ( \"Class\" , \"\" ) . split () # Remove all instances of the class if cls_str in current_classes : # List comprehension to remove all occurrences safely current_classes = [ c for c in current_classes if c != cls_str ] self . attrs [ \"Class\" ] = \" \" . join ( current_classes ) return self def contains_class ( self , cls_str : str ) -> bool : \"\"\"Checks for exact class match.\"\"\" current_classes = self . attrs . get ( \"Class\" , \"\" ) . split () return cls_str in current_classes def toggle_class ( self , class_name : str , condition : bool = None ) -> Self : # Force Add if condition is True : return self . add_class ( class_name ) # Force Remove if condition is False : return self . remove_class ( class_name ) # Standard Toggle if self . contains_class ( class_name ): return self . remove_class ( class_name ) return self . add_class ( class_name ) def set_attr ( self , key : str , value : Union [ str , bool ]) -> Self : if isinstance ( value , bool ): if value is False : self . remove_attr ( key ) else : self . attrs [ key ] = \"\" # Boolean attribute (e.g. disabled=\"\") else : self . attrs [ self . _normalize_attr_key ( key )] = str ( value ) return self def set_bulk_attr ( self , ** attrs ) -> Self : for key , value in attrs . items (): self . set_attr ( key , value ) return self def get_attr ( self , key : str , default = None ) -> str : return self . attrs . get ( self . _normalize_attr_key ( key ), default ) def remove_attr ( self , key : str ) -> Self : \"\"\"Safely removes an attribute if it exists.\"\"\" if key in self . attrs : del self . attrs [ self . _normalize_attr_key ( key )] return self def set_data ( self , key : str , value : str ) -> Self : clean_key = key . replace ( \"_\" , \"-\" ) return self . set_attr ( f \"data- { clean_key } \" , value ) def set_id ( self , unique_id : str ) -> Self : return self . set_attr ( \"Id\" , unique_id ) def merge_attrs ( self , ** kwargs ) -> Self : for key , value in kwargs . items (): if key == \"Class\" : self . add_class ( value ) else : clean_key = key . replace ( \"_\" , \"-\" ) self . set_attr ( clean_key , value ) return self def _normalize_attr_key ( self , key ): reserved_attrs = { 'id' : 'Id' , 'class' : 'Class' ,} return reserved_attrs . get ( key . lower (), key ) def set_style ( self , property : str , value : str ) -> Self : \"\"\"Updates inline style intelligently.\"\"\" # 1. Parse existing style current_style_str = self . attrs . get ( \"style\" , \"\" ) style_dict = self . _parse_style_string ( current_style_str ) # 2. Update the property style_dict [ property ] = value # 3. Rebuild string new_style_str = \"; \" . join ([ f \" { k } : { v } \" for k , v in style_dict . items ()]) self . attrs [ \"style\" ] = new_style_str return self def _parse_style_string ( self , style_str : str ) -> Dict [ str , str ]: \"\"\"Helper to convert 'color: red; width: 10px' into a dict.\"\"\" if not style_str : return {} result = {} # Split by semicolon, then by colon items = style_str . split ( \";\" ) for item in items : if \":\" in item : key , val = item . split ( \":\" , 1 ) result [ key . strip ()] = val . strip () return result","title":"ElementAttributeManipulator"},{"location":"reference/probo/components/base/#probo.components.base.ElementAttributeManipulator.add_class","text":"Smartly adds class(es) without duplicating. Source code in src\\probo\\components\\base.py 12 13 14 15 16 17 18 19 20 21 22 def add_class ( self , cls_str : str ) -> Self : \"\"\"Smartly adds class(es) without duplicating.\"\"\" # Split existing classes into a set to avoid duplicates current_classes = set ( self . attrs . get ( \"Class\" , \"\" ) . split ()) new_classes = cls_str . split () # Add new ones current_classes . update ( set ( new_classes )) # Save back as sorted string (cleaner HTML) self . attrs [ \"Class\" ] = \" \" . join ( sorted ( current_classes )) return self","title":"add_class"},{"location":"reference/probo/components/base/#probo.components.base.ElementAttributeManipulator.contains_class","text":"Checks for exact class match. Source code in src\\probo\\components\\base.py 35 36 37 38 def contains_class ( self , cls_str : str ) -> bool : \"\"\"Checks for exact class match.\"\"\" current_classes = self . attrs . get ( \"Class\" , \"\" ) . split () return cls_str in current_classes","title":"contains_class"},{"location":"reference/probo/components/base/#probo.components.base.ElementAttributeManipulator.remove_attr","text":"Safely removes an attribute if it exists. Source code in src\\probo\\components\\base.py 70 71 72 73 74 def remove_attr ( self , key : str ) -> Self : \"\"\"Safely removes an attribute if it exists.\"\"\" if key in self . attrs : del self . attrs [ self . _normalize_attr_key ( key )] return self","title":"remove_attr"},{"location":"reference/probo/components/base/#probo.components.base.ElementAttributeManipulator.set_style","text":"Updates inline style intelligently. Source code in src\\probo\\components\\base.py 94 95 96 97 98 99 100 101 102 103 104 105 106 def set_style ( self , property : str , value : str ) -> Self : \"\"\"Updates inline style intelligently.\"\"\" # 1. Parse existing style current_style_str = self . attrs . get ( \"style\" , \"\" ) style_dict = self . _parse_style_string ( current_style_str ) # 2. Update the property style_dict [ property ] = value # 3. Rebuild string new_style_str = \"; \" . join ([ f \" { k } : { v } \" for k , v in style_dict . items ()]) self . attrs [ \"style\" ] = new_style_str return self","title":"set_style"},{"location":"reference/probo/components/component/","text":"component Component The base class for all UI components in PROBO. Orchestrates state management, template rendering, and JIT CSS compilation. This class acts as the conductor, coordinating the Body (Template/Elements), the Brain (ComponentState), and the Skin (JIT CSS). It supports lifecycle hooks, skin swapping, and root element proxying. Parameters: name ( str ) \u2013 Unique identifier for the component registry. Used for debugging and hydration. state ( ComponentState , default: None ) \u2013 The state manager containing static/dynamic data and logic gates. template ( str , default: str () ) \u2013 The raw HTML string containing element state placeholders. props ( dict , default: None ) \u2013 context or configuration properties passed to the component. **elements ( dict , default: {} ) \u2013 Child components or template fragments keyed by name. Attributes: name ( str ) \u2013 The component's registry name. comp_state ( ComponentState ) \u2013 The internal state manager. active_css_rules ( List [ CssRule ] ) \u2013 The list of CSS rules currently applied. default_css_rules ( List [ CssRule ] ) \u2013 The baseline CSS rules (used for resetting skins). Example: static: >>> # Define template >>> template_string = div(span('hello',strong('world!')),) >>> >>> # Define Component >>> comp = Component(\"UserBadge\",template_string) >>> >>> #set root element >>> comp.set_root_element('section',Id='root',Class='root-class') >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>hello<strong>world!</strong></span></section> >>> css -> span {font-weight:bold;} state defined: >>> # Define State >>> es = ElementState('span', d_state='username') >>> template_string = div(span('User:',strong(es.placeholder)),) >>> state = ComponentState(d_data={'username': 'Admin'}, es) >>> >>> # Define Component >>> comp = Component(\"UserBadge\", state=state, template=template_string) >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>User:<strong><span>Admin</span></strong></span></section> >>> css -> span {font-weight:bold;} Source code in src\\probo\\components\\component.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 class Component : \"\"\" The base class for all UI components in PROBO. Orchestrates state management, template rendering, and JIT CSS compilation. This class acts as the conductor, coordinating the Body (Template/Elements), the Brain (ComponentState), and the Skin (JIT CSS). It supports lifecycle hooks, skin swapping, and root element proxying. Args: name (str): Unique identifier for the component registry. Used for debugging and hydration. state (ComponentState, optional): The state manager containing static/dynamic data and logic gates. template (str, optional): The raw HTML string containing element state placeholders. props (dict, optional): context or configuration properties passed to the component. **elements (dict): Child components or template fragments keyed by name. Attributes: name (str): The component's registry name. comp_state (ComponentState): The internal state manager. active_css_rules (List[CssRule]): The list of CSS rules currently applied. default_css_rules (List[CssRule]): The baseline CSS rules (used for resetting skins). Example: static: >>> # Define template >>> template_string = div(span('hello',strong('world!')),) >>> >>> # Define Component >>> comp = Component(\"UserBadge\",template_string) >>> >>> #set root element >>> comp.set_root_element('section',Id='root',Class='root-class') >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>hello<strong>world!</strong></span></section> >>> css -> span {font-weight:bold;} state defined: >>> # Define State >>> es = ElementState('span', d_state='username') >>> template_string = div(span('User:',strong(es.placeholder)),) >>> state = ComponentState(d_data={'username': 'Admin'}, es) >>> >>> # Define Component >>> comp = Component(\"UserBadge\", state=state, template=template_string) >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>User:<strong><span>Admin</span></strong></span></section> >>> css -> span {font-weight:bold;} \"\"\" _registry = {} # Global component registry def __init__ ( self , name : str , state : ComponentState = None , template : str = str (), props : dict = None , ** elements , ): self . name : str = name self . index : int = 0 self . children : dict [ str , Any ] = elements or {} self . children_info = { k : TemplateResolver ( v ) . template_resolver () for k , v in elements . items () } self . attr_manager = ComponentAttrManager () if isinstance ( template , str ): self . template_obj = TemplateResolver ( tmplt_str = template , load_it = True ) else : self . template_obj = template self . is_root_element : bool = False self . root_element_tag = None self . root_element_attrs = {} self . props = props or {} self . comp_state = state or ComponentState () self . default_css_rules = list () self . active_css_rules = list () self . cmp_style = None self . _registry [ name ] = self # Auto-register self . on_init () def on_init ( self ): \"\"\"Lifecycle Hook: Called after initialization. Override to add setup logic.\"\"\" pass def before_render ( self , ** props ): \"\"\"Lifecycle Hook: Called before render. Override to modify state/props dynamically.\"\"\" return self @classmethod def get ( cls , name : str ): \"\"\"Retrieves a registered component by name.\"\"\" return cls . _registry . get ( name ) @classmethod def register ( cls , name : str , state : ComponentState = None , props : dict = None , * elements ): \"\"\"Registers a new component instance.\"\"\" comp = cls ( name = name , template = \"\" . join ( elements ), state = state , props = props ) cls . _registry [ name ] = comp return comp def set_root_element ( self , root : str = \"div\" , ** attrs ): \"\"\"Defines a wrapper element for the component.\"\"\" self . root_element_tag = root self . is_root_element = True self . root_element_attrs = attrs return self def add_root_class ( self , class_name : str ): \"\"\"Adds a CSS class to the root element.\"\"\" current = self . root_element_attrs . get ( \"class\" , \"\" ) # simple check to avoid duplicates or extra spaces if class_name not in current . split (): self . root_element_attrs [ \"class\" ] = f \" { current } { class_name } \" . strip () return self def set_root_id ( self , element_id : str ): \"\"\"Sets the ID of the root element.\"\"\" self . root_element_attrs [ \"id\" ] = element_id return self def add_child ( self , child : \"str|Component\" , name : str = None ): \"\"\"Adds a child component or string content.\"\"\" if child : if isinstance ( child , type ( self )): self . children . update ({ child . name : child . render ()}) elif isinstance ( child , str ) and name is not None : child_obj = TemplateResolver ( tmplt_str = child , load_it = True ) . template_resolver () self . children [ name ] = child self . children_info [ name ] = child_obj else : raise ValueError ( \"invalid child type or no name\" ) return self def sub_component ( self , component : Self ): \"\"\"Embeds another component inside this one.\"\"\" render_result = component . render () if isinstance ( render_result , tuple ): html , _ = render_result # Note: You might want to bubble up the CSS here too, # but for now we just store HTML self . children . update ({ component . name : html }) self . active_css_rules . update ( component . active_css_rules ) else : self . children . update ({ component . name : render_result }) self . props . update ( component . props ) return self def render ( self , override_props : dict = None , force_state : bool = False , add_to_global : bool = False , ) -> str | tuple : \"\"\" Compiles the component into final HTML and CSS. Returns: tuple: (html_string, css_string) or str: html_string (if no CSS) \"\"\" self . before_render ( ** ( override_props or {})) if isinstance ( override_props , dict ): if add_to_global : self . props . update ( override_props ) if force_state : self . comp_state . props = override_props # not quite else : self . comp_state . props . update ( override_props ) # not quite self . comp_state . state_errors = None template = self . template_obj . render () if hasattr ( self . template_obj , 'render' ) else str ( self . template_obj . tmplt_str ) if self . children : template += \"\" . join ( list ( self . children . values ())) self . comp_state . incoming_props = self . props # not quite final_template = str ( self . comp_state . resolved_template ( template )) if self . is_root_element : final_template = Element ( content = final_template , ** self . root_element_attrs ) . build_tag ( self . root_element_tag , ) if self . active_css_rules : valid_css = element_style_state ( final_template , self . comp_state . resolved_state_elements , * self . active_css_rules , ) self . cmp_style = ComponentStyle ( final_template , * valid_css ) return final_template , self . cmp_style . render () else : return final_template def change_skin ( self , source : dict [ \"str\" , Any ] | Self = None , root_attr : str = None , root_attr_value : str = None , ** root_css : dict [ \"CssSelector\" , \"CssRule\" ], ): \"\"\" Applies a new skin (CSS rules) to the component. Supports Dictionaries, other Components, Theme lists, and Root kwargs. \"\"\" new_rules = {} # --- CASE 1: Dictionary {selector: {prop: val}} --- if isinstance ( source , dict ): new_rules . update ( source ) # --- CASE 2: Component Inheritance --- elif hasattr ( source , \"active_css_rules\" ) and isinstance ( source . active_css_rules , list ): self . active_css_rules . extend ( source . active_css_rules ) # --- CASE 3: Root Inheritance (kwargs) --- if root_css : if root_attr : if self . root_element_attrs and root_attr not in self . root_element_attrs : self . root_element_attrs [ root_attr ] = ( \"true\" if not root_attr_value else root_attr_value ) new_rules [ f \" { self . root_element_tag } [ { root_attr } ]\" ] = root_css # Auto-detect if no explicit root_attr provided if not root_attr : if self . root_element_attrs : if \"id\" in self . root_element_attrs : root_attr = f \"# { self . root_element_attrs [ 'id' ] } \" elif \"class\" in self . root_element_attrs : # root_attr the first class root_attr = f \". { self . root_element_attrs [ 'class' ] . split ()[ 0 ] } \" # Fallback to tag if not root_attr and self . root_element_tag : root_attr = self . root_element_tag new_rules [ root_attr ] = root_css # Set the new skin dictionary. # Note: We assign the DICT, not .values(), because render() calls .keys() on it. self . active_css_rules = SelectorRuleBridge . make_bridge_list ( new_rules ) return self def load_css_rules ( self , ** css ): \"\"\"Loads initial CSS rules into the component.\"\"\" if css : self . default_css_rules . extend ( SelectorRuleBridge . make_bridge_list ( css )) self . active_css_rules = self . default_css_rules . copy () return self add_child ( child , name = None ) Adds a child component or string content. Source code in src\\probo\\components\\component.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def add_child ( self , child : \"str|Component\" , name : str = None ): \"\"\"Adds a child component or string content.\"\"\" if child : if isinstance ( child , type ( self )): self . children . update ({ child . name : child . render ()}) elif isinstance ( child , str ) and name is not None : child_obj = TemplateResolver ( tmplt_str = child , load_it = True ) . template_resolver () self . children [ name ] = child self . children_info [ name ] = child_obj else : raise ValueError ( \"invalid child type or no name\" ) return self add_root_class ( class_name ) Adds a CSS class to the root element. Source code in src\\probo\\components\\component.py 146 147 148 149 150 151 152 def add_root_class ( self , class_name : str ): \"\"\"Adds a CSS class to the root element.\"\"\" current = self . root_element_attrs . get ( \"class\" , \"\" ) # simple check to avoid duplicates or extra spaces if class_name not in current . split (): self . root_element_attrs [ \"class\" ] = f \" { current } { class_name } \" . strip () return self before_render ( ** props ) Lifecycle Hook: Called before render. Override to modify state/props dynamically. Source code in src\\probo\\components\\component.py 121 122 123 def before_render ( self , ** props ): \"\"\"Lifecycle Hook: Called before render. Override to modify state/props dynamically.\"\"\" return self change_skin ( source = None , root_attr = None , root_attr_value = None , ** root_css ) Applies a new skin (CSS rules) to the component. Supports Dictionaries, other Components, Theme lists, and Root kwargs. Source code in src\\probo\\components\\component.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def change_skin ( self , source : dict [ \"str\" , Any ] | Self = None , root_attr : str = None , root_attr_value : str = None , ** root_css : dict [ \"CssSelector\" , \"CssRule\" ], ): \"\"\" Applies a new skin (CSS rules) to the component. Supports Dictionaries, other Components, Theme lists, and Root kwargs. \"\"\" new_rules = {} # --- CASE 1: Dictionary {selector: {prop: val}} --- if isinstance ( source , dict ): new_rules . update ( source ) # --- CASE 2: Component Inheritance --- elif hasattr ( source , \"active_css_rules\" ) and isinstance ( source . active_css_rules , list ): self . active_css_rules . extend ( source . active_css_rules ) # --- CASE 3: Root Inheritance (kwargs) --- if root_css : if root_attr : if self . root_element_attrs and root_attr not in self . root_element_attrs : self . root_element_attrs [ root_attr ] = ( \"true\" if not root_attr_value else root_attr_value ) new_rules [ f \" { self . root_element_tag } [ { root_attr } ]\" ] = root_css # Auto-detect if no explicit root_attr provided if not root_attr : if self . root_element_attrs : if \"id\" in self . root_element_attrs : root_attr = f \"# { self . root_element_attrs [ 'id' ] } \" elif \"class\" in self . root_element_attrs : # root_attr the first class root_attr = f \". { self . root_element_attrs [ 'class' ] . split ()[ 0 ] } \" # Fallback to tag if not root_attr and self . root_element_tag : root_attr = self . root_element_tag new_rules [ root_attr ] = root_css # Set the new skin dictionary. # Note: We assign the DICT, not .values(), because render() calls .keys() on it. self . active_css_rules = SelectorRuleBridge . make_bridge_list ( new_rules ) return self get ( name ) classmethod Retrieves a registered component by name. Source code in src\\probo\\components\\component.py 125 126 127 128 @classmethod def get ( cls , name : str ): \"\"\"Retrieves a registered component by name.\"\"\" return cls . _registry . get ( name ) load_css_rules ( ** css ) Loads initial CSS rules into the component. Source code in src\\probo\\components\\component.py 288 289 290 291 292 293 294 295 def load_css_rules ( self , ** css ): \"\"\"Loads initial CSS rules into the component.\"\"\" if css : self . default_css_rules . extend ( SelectorRuleBridge . make_bridge_list ( css )) self . active_css_rules = self . default_css_rules . copy () return self on_init () Lifecycle Hook: Called after initialization. Override to add setup logic. Source code in src\\probo\\components\\component.py 117 118 119 def on_init ( self ): \"\"\"Lifecycle Hook: Called after initialization. Override to add setup logic.\"\"\" pass register ( name , state = None , props = None , * elements ) classmethod Registers a new component instance. Source code in src\\probo\\components\\component.py 130 131 132 133 134 135 136 137 @classmethod def register ( cls , name : str , state : ComponentState = None , props : dict = None , * elements ): \"\"\"Registers a new component instance.\"\"\" comp = cls ( name = name , template = \"\" . join ( elements ), state = state , props = props ) cls . _registry [ name ] = comp return comp render ( override_props = None , force_state = False , add_to_global = False ) Compiles the component into final HTML and CSS. Returns: tuple ( str | tuple ) \u2013 (html_string, css_string) or str: html_string (if no CSS) Source code in src\\probo\\components\\component.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def render ( self , override_props : dict = None , force_state : bool = False , add_to_global : bool = False , ) -> str | tuple : \"\"\" Compiles the component into final HTML and CSS. Returns: tuple: (html_string, css_string) or str: html_string (if no CSS) \"\"\" self . before_render ( ** ( override_props or {})) if isinstance ( override_props , dict ): if add_to_global : self . props . update ( override_props ) if force_state : self . comp_state . props = override_props # not quite else : self . comp_state . props . update ( override_props ) # not quite self . comp_state . state_errors = None template = self . template_obj . render () if hasattr ( self . template_obj , 'render' ) else str ( self . template_obj . tmplt_str ) if self . children : template += \"\" . join ( list ( self . children . values ())) self . comp_state . incoming_props = self . props # not quite final_template = str ( self . comp_state . resolved_template ( template )) if self . is_root_element : final_template = Element ( content = final_template , ** self . root_element_attrs ) . build_tag ( self . root_element_tag , ) if self . active_css_rules : valid_css = element_style_state ( final_template , self . comp_state . resolved_state_elements , * self . active_css_rules , ) self . cmp_style = ComponentStyle ( final_template , * valid_css ) return final_template , self . cmp_style . render () else : return final_template set_root_element ( root = 'div' , ** attrs ) Defines a wrapper element for the component. Source code in src\\probo\\components\\component.py 139 140 141 142 143 144 def set_root_element ( self , root : str = \"div\" , ** attrs ): \"\"\"Defines a wrapper element for the component.\"\"\" self . root_element_tag = root self . is_root_element = True self . root_element_attrs = attrs return self set_root_id ( element_id ) Sets the ID of the root element. Source code in src\\probo\\components\\component.py 154 155 156 157 def set_root_id ( self , element_id : str ): \"\"\"Sets the ID of the root element.\"\"\" self . root_element_attrs [ \"id\" ] = element_id return self sub_component ( component ) Embeds another component inside this one. Source code in src\\probo\\components\\component.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def sub_component ( self , component : Self ): \"\"\"Embeds another component inside this one.\"\"\" render_result = component . render () if isinstance ( render_result , tuple ): html , _ = render_result # Note: You might want to bubble up the CSS here too, # but for now we just store HTML self . children . update ({ component . name : html }) self . active_css_rules . update ( component . active_css_rules ) else : self . children . update ({ component . name : render_result }) self . props . update ( component . props ) return self","title":"component"},{"location":"reference/probo/components/component/#component","text":"","title":"component"},{"location":"reference/probo/components/component/#probo.components.component.Component","text":"The base class for all UI components in PROBO. Orchestrates state management, template rendering, and JIT CSS compilation. This class acts as the conductor, coordinating the Body (Template/Elements), the Brain (ComponentState), and the Skin (JIT CSS). It supports lifecycle hooks, skin swapping, and root element proxying. Parameters: name ( str ) \u2013 Unique identifier for the component registry. Used for debugging and hydration. state ( ComponentState , default: None ) \u2013 The state manager containing static/dynamic data and logic gates. template ( str , default: str () ) \u2013 The raw HTML string containing element state placeholders. props ( dict , default: None ) \u2013 context or configuration properties passed to the component. **elements ( dict , default: {} ) \u2013 Child components or template fragments keyed by name. Attributes: name ( str ) \u2013 The component's registry name. comp_state ( ComponentState ) \u2013 The internal state manager. active_css_rules ( List [ CssRule ] ) \u2013 The list of CSS rules currently applied. default_css_rules ( List [ CssRule ] ) \u2013 The baseline CSS rules (used for resetting skins). Example: static: >>> # Define template >>> template_string = div(span('hello',strong('world!')),) >>> >>> # Define Component >>> comp = Component(\"UserBadge\",template_string) >>> >>> #set root element >>> comp.set_root_element('section',Id='root',Class='root-class') >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>hello<strong>world!</strong></span></section> >>> css -> span {font-weight:bold;} state defined: >>> # Define State >>> es = ElementState('span', d_state='username') >>> template_string = div(span('User:',strong(es.placeholder)),) >>> state = ComponentState(d_data={'username': 'Admin'}, es) >>> >>> # Define Component >>> comp = Component(\"UserBadge\", state=state, template=template_string) >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>User:<strong><span>Admin</span></strong></span></section> >>> css -> span {font-weight:bold;} Source code in src\\probo\\components\\component.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 class Component : \"\"\" The base class for all UI components in PROBO. Orchestrates state management, template rendering, and JIT CSS compilation. This class acts as the conductor, coordinating the Body (Template/Elements), the Brain (ComponentState), and the Skin (JIT CSS). It supports lifecycle hooks, skin swapping, and root element proxying. Args: name (str): Unique identifier for the component registry. Used for debugging and hydration. state (ComponentState, optional): The state manager containing static/dynamic data and logic gates. template (str, optional): The raw HTML string containing element state placeholders. props (dict, optional): context or configuration properties passed to the component. **elements (dict): Child components or template fragments keyed by name. Attributes: name (str): The component's registry name. comp_state (ComponentState): The internal state manager. active_css_rules (List[CssRule]): The list of CSS rules currently applied. default_css_rules (List[CssRule]): The baseline CSS rules (used for resetting skins). Example: static: >>> # Define template >>> template_string = div(span('hello',strong('world!')),) >>> >>> # Define Component >>> comp = Component(\"UserBadge\",template_string) >>> >>> #set root element >>> comp.set_root_element('section',Id='root',Class='root-class') >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>hello<strong>world!</strong></span></section> >>> css -> span {font-weight:bold;} state defined: >>> # Define State >>> es = ElementState('span', d_state='username') >>> template_string = div(span('User:',strong(es.placeholder)),) >>> state = ComponentState(d_data={'username': 'Admin'}, es) >>> >>> # Define Component >>> comp = Component(\"UserBadge\", state=state, template=template_string) >>> >>> # Apply Style >>> comp.load_css_rules(span=CssRule(font_weight=\"bold\")) >>> >>> # Render >>> html, css = comp.render() >>> html -> <section id=\"root\" class=\"root-class\"><span>User:<strong><span>Admin</span></strong></span></section> >>> css -> span {font-weight:bold;} \"\"\" _registry = {} # Global component registry def __init__ ( self , name : str , state : ComponentState = None , template : str = str (), props : dict = None , ** elements , ): self . name : str = name self . index : int = 0 self . children : dict [ str , Any ] = elements or {} self . children_info = { k : TemplateResolver ( v ) . template_resolver () for k , v in elements . items () } self . attr_manager = ComponentAttrManager () if isinstance ( template , str ): self . template_obj = TemplateResolver ( tmplt_str = template , load_it = True ) else : self . template_obj = template self . is_root_element : bool = False self . root_element_tag = None self . root_element_attrs = {} self . props = props or {} self . comp_state = state or ComponentState () self . default_css_rules = list () self . active_css_rules = list () self . cmp_style = None self . _registry [ name ] = self # Auto-register self . on_init () def on_init ( self ): \"\"\"Lifecycle Hook: Called after initialization. Override to add setup logic.\"\"\" pass def before_render ( self , ** props ): \"\"\"Lifecycle Hook: Called before render. Override to modify state/props dynamically.\"\"\" return self @classmethod def get ( cls , name : str ): \"\"\"Retrieves a registered component by name.\"\"\" return cls . _registry . get ( name ) @classmethod def register ( cls , name : str , state : ComponentState = None , props : dict = None , * elements ): \"\"\"Registers a new component instance.\"\"\" comp = cls ( name = name , template = \"\" . join ( elements ), state = state , props = props ) cls . _registry [ name ] = comp return comp def set_root_element ( self , root : str = \"div\" , ** attrs ): \"\"\"Defines a wrapper element for the component.\"\"\" self . root_element_tag = root self . is_root_element = True self . root_element_attrs = attrs return self def add_root_class ( self , class_name : str ): \"\"\"Adds a CSS class to the root element.\"\"\" current = self . root_element_attrs . get ( \"class\" , \"\" ) # simple check to avoid duplicates or extra spaces if class_name not in current . split (): self . root_element_attrs [ \"class\" ] = f \" { current } { class_name } \" . strip () return self def set_root_id ( self , element_id : str ): \"\"\"Sets the ID of the root element.\"\"\" self . root_element_attrs [ \"id\" ] = element_id return self def add_child ( self , child : \"str|Component\" , name : str = None ): \"\"\"Adds a child component or string content.\"\"\" if child : if isinstance ( child , type ( self )): self . children . update ({ child . name : child . render ()}) elif isinstance ( child , str ) and name is not None : child_obj = TemplateResolver ( tmplt_str = child , load_it = True ) . template_resolver () self . children [ name ] = child self . children_info [ name ] = child_obj else : raise ValueError ( \"invalid child type or no name\" ) return self def sub_component ( self , component : Self ): \"\"\"Embeds another component inside this one.\"\"\" render_result = component . render () if isinstance ( render_result , tuple ): html , _ = render_result # Note: You might want to bubble up the CSS here too, # but for now we just store HTML self . children . update ({ component . name : html }) self . active_css_rules . update ( component . active_css_rules ) else : self . children . update ({ component . name : render_result }) self . props . update ( component . props ) return self def render ( self , override_props : dict = None , force_state : bool = False , add_to_global : bool = False , ) -> str | tuple : \"\"\" Compiles the component into final HTML and CSS. Returns: tuple: (html_string, css_string) or str: html_string (if no CSS) \"\"\" self . before_render ( ** ( override_props or {})) if isinstance ( override_props , dict ): if add_to_global : self . props . update ( override_props ) if force_state : self . comp_state . props = override_props # not quite else : self . comp_state . props . update ( override_props ) # not quite self . comp_state . state_errors = None template = self . template_obj . render () if hasattr ( self . template_obj , 'render' ) else str ( self . template_obj . tmplt_str ) if self . children : template += \"\" . join ( list ( self . children . values ())) self . comp_state . incoming_props = self . props # not quite final_template = str ( self . comp_state . resolved_template ( template )) if self . is_root_element : final_template = Element ( content = final_template , ** self . root_element_attrs ) . build_tag ( self . root_element_tag , ) if self . active_css_rules : valid_css = element_style_state ( final_template , self . comp_state . resolved_state_elements , * self . active_css_rules , ) self . cmp_style = ComponentStyle ( final_template , * valid_css ) return final_template , self . cmp_style . render () else : return final_template def change_skin ( self , source : dict [ \"str\" , Any ] | Self = None , root_attr : str = None , root_attr_value : str = None , ** root_css : dict [ \"CssSelector\" , \"CssRule\" ], ): \"\"\" Applies a new skin (CSS rules) to the component. Supports Dictionaries, other Components, Theme lists, and Root kwargs. \"\"\" new_rules = {} # --- CASE 1: Dictionary {selector: {prop: val}} --- if isinstance ( source , dict ): new_rules . update ( source ) # --- CASE 2: Component Inheritance --- elif hasattr ( source , \"active_css_rules\" ) and isinstance ( source . active_css_rules , list ): self . active_css_rules . extend ( source . active_css_rules ) # --- CASE 3: Root Inheritance (kwargs) --- if root_css : if root_attr : if self . root_element_attrs and root_attr not in self . root_element_attrs : self . root_element_attrs [ root_attr ] = ( \"true\" if not root_attr_value else root_attr_value ) new_rules [ f \" { self . root_element_tag } [ { root_attr } ]\" ] = root_css # Auto-detect if no explicit root_attr provided if not root_attr : if self . root_element_attrs : if \"id\" in self . root_element_attrs : root_attr = f \"# { self . root_element_attrs [ 'id' ] } \" elif \"class\" in self . root_element_attrs : # root_attr the first class root_attr = f \". { self . root_element_attrs [ 'class' ] . split ()[ 0 ] } \" # Fallback to tag if not root_attr and self . root_element_tag : root_attr = self . root_element_tag new_rules [ root_attr ] = root_css # Set the new skin dictionary. # Note: We assign the DICT, not .values(), because render() calls .keys() on it. self . active_css_rules = SelectorRuleBridge . make_bridge_list ( new_rules ) return self def load_css_rules ( self , ** css ): \"\"\"Loads initial CSS rules into the component.\"\"\" if css : self . default_css_rules . extend ( SelectorRuleBridge . make_bridge_list ( css )) self . active_css_rules = self . default_css_rules . copy () return self","title":"Component"},{"location":"reference/probo/components/component/#probo.components.component.Component.add_child","text":"Adds a child component or string content. Source code in src\\probo\\components\\component.py 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 def add_child ( self , child : \"str|Component\" , name : str = None ): \"\"\"Adds a child component or string content.\"\"\" if child : if isinstance ( child , type ( self )): self . children . update ({ child . name : child . render ()}) elif isinstance ( child , str ) and name is not None : child_obj = TemplateResolver ( tmplt_str = child , load_it = True ) . template_resolver () self . children [ name ] = child self . children_info [ name ] = child_obj else : raise ValueError ( \"invalid child type or no name\" ) return self","title":"add_child"},{"location":"reference/probo/components/component/#probo.components.component.Component.add_root_class","text":"Adds a CSS class to the root element. Source code in src\\probo\\components\\component.py 146 147 148 149 150 151 152 def add_root_class ( self , class_name : str ): \"\"\"Adds a CSS class to the root element.\"\"\" current = self . root_element_attrs . get ( \"class\" , \"\" ) # simple check to avoid duplicates or extra spaces if class_name not in current . split (): self . root_element_attrs [ \"class\" ] = f \" { current } { class_name } \" . strip () return self","title":"add_root_class"},{"location":"reference/probo/components/component/#probo.components.component.Component.before_render","text":"Lifecycle Hook: Called before render. Override to modify state/props dynamically. Source code in src\\probo\\components\\component.py 121 122 123 def before_render ( self , ** props ): \"\"\"Lifecycle Hook: Called before render. Override to modify state/props dynamically.\"\"\" return self","title":"before_render"},{"location":"reference/probo/components/component/#probo.components.component.Component.change_skin","text":"Applies a new skin (CSS rules) to the component. Supports Dictionaries, other Components, Theme lists, and Root kwargs. Source code in src\\probo\\components\\component.py 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 def change_skin ( self , source : dict [ \"str\" , Any ] | Self = None , root_attr : str = None , root_attr_value : str = None , ** root_css : dict [ \"CssSelector\" , \"CssRule\" ], ): \"\"\" Applies a new skin (CSS rules) to the component. Supports Dictionaries, other Components, Theme lists, and Root kwargs. \"\"\" new_rules = {} # --- CASE 1: Dictionary {selector: {prop: val}} --- if isinstance ( source , dict ): new_rules . update ( source ) # --- CASE 2: Component Inheritance --- elif hasattr ( source , \"active_css_rules\" ) and isinstance ( source . active_css_rules , list ): self . active_css_rules . extend ( source . active_css_rules ) # --- CASE 3: Root Inheritance (kwargs) --- if root_css : if root_attr : if self . root_element_attrs and root_attr not in self . root_element_attrs : self . root_element_attrs [ root_attr ] = ( \"true\" if not root_attr_value else root_attr_value ) new_rules [ f \" { self . root_element_tag } [ { root_attr } ]\" ] = root_css # Auto-detect if no explicit root_attr provided if not root_attr : if self . root_element_attrs : if \"id\" in self . root_element_attrs : root_attr = f \"# { self . root_element_attrs [ 'id' ] } \" elif \"class\" in self . root_element_attrs : # root_attr the first class root_attr = f \". { self . root_element_attrs [ 'class' ] . split ()[ 0 ] } \" # Fallback to tag if not root_attr and self . root_element_tag : root_attr = self . root_element_tag new_rules [ root_attr ] = root_css # Set the new skin dictionary. # Note: We assign the DICT, not .values(), because render() calls .keys() on it. self . active_css_rules = SelectorRuleBridge . make_bridge_list ( new_rules ) return self","title":"change_skin"},{"location":"reference/probo/components/component/#probo.components.component.Component.get","text":"Retrieves a registered component by name. Source code in src\\probo\\components\\component.py 125 126 127 128 @classmethod def get ( cls , name : str ): \"\"\"Retrieves a registered component by name.\"\"\" return cls . _registry . get ( name )","title":"get"},{"location":"reference/probo/components/component/#probo.components.component.Component.load_css_rules","text":"Loads initial CSS rules into the component. Source code in src\\probo\\components\\component.py 288 289 290 291 292 293 294 295 def load_css_rules ( self , ** css ): \"\"\"Loads initial CSS rules into the component.\"\"\" if css : self . default_css_rules . extend ( SelectorRuleBridge . make_bridge_list ( css )) self . active_css_rules = self . default_css_rules . copy () return self","title":"load_css_rules"},{"location":"reference/probo/components/component/#probo.components.component.Component.on_init","text":"Lifecycle Hook: Called after initialization. Override to add setup logic. Source code in src\\probo\\components\\component.py 117 118 119 def on_init ( self ): \"\"\"Lifecycle Hook: Called after initialization. Override to add setup logic.\"\"\" pass","title":"on_init"},{"location":"reference/probo/components/component/#probo.components.component.Component.register","text":"Registers a new component instance. Source code in src\\probo\\components\\component.py 130 131 132 133 134 135 136 137 @classmethod def register ( cls , name : str , state : ComponentState = None , props : dict = None , * elements ): \"\"\"Registers a new component instance.\"\"\" comp = cls ( name = name , template = \"\" . join ( elements ), state = state , props = props ) cls . _registry [ name ] = comp return comp","title":"register"},{"location":"reference/probo/components/component/#probo.components.component.Component.render","text":"Compiles the component into final HTML and CSS. Returns: tuple ( str | tuple ) \u2013 (html_string, css_string) or str: html_string (if no CSS) Source code in src\\probo\\components\\component.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 def render ( self , override_props : dict = None , force_state : bool = False , add_to_global : bool = False , ) -> str | tuple : \"\"\" Compiles the component into final HTML and CSS. Returns: tuple: (html_string, css_string) or str: html_string (if no CSS) \"\"\" self . before_render ( ** ( override_props or {})) if isinstance ( override_props , dict ): if add_to_global : self . props . update ( override_props ) if force_state : self . comp_state . props = override_props # not quite else : self . comp_state . props . update ( override_props ) # not quite self . comp_state . state_errors = None template = self . template_obj . render () if hasattr ( self . template_obj , 'render' ) else str ( self . template_obj . tmplt_str ) if self . children : template += \"\" . join ( list ( self . children . values ())) self . comp_state . incoming_props = self . props # not quite final_template = str ( self . comp_state . resolved_template ( template )) if self . is_root_element : final_template = Element ( content = final_template , ** self . root_element_attrs ) . build_tag ( self . root_element_tag , ) if self . active_css_rules : valid_css = element_style_state ( final_template , self . comp_state . resolved_state_elements , * self . active_css_rules , ) self . cmp_style = ComponentStyle ( final_template , * valid_css ) return final_template , self . cmp_style . render () else : return final_template","title":"render"},{"location":"reference/probo/components/component/#probo.components.component.Component.set_root_element","text":"Defines a wrapper element for the component. Source code in src\\probo\\components\\component.py 139 140 141 142 143 144 def set_root_element ( self , root : str = \"div\" , ** attrs ): \"\"\"Defines a wrapper element for the component.\"\"\" self . root_element_tag = root self . is_root_element = True self . root_element_attrs = attrs return self","title":"set_root_element"},{"location":"reference/probo/components/component/#probo.components.component.Component.set_root_id","text":"Sets the ID of the root element. Source code in src\\probo\\components\\component.py 154 155 156 157 def set_root_id ( self , element_id : str ): \"\"\"Sets the ID of the root element.\"\"\" self . root_element_attrs [ \"id\" ] = element_id return self","title":"set_root_id"},{"location":"reference/probo/components/component/#probo.components.component.Component.sub_component","text":"Embeds another component inside this one. Source code in src\\probo\\components\\component.py 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def sub_component ( self , component : Self ): \"\"\"Embeds another component inside this one.\"\"\" render_result = component . render () if isinstance ( render_result , tuple ): html , _ = render_result # Note: You might want to bubble up the CSS here too, # but for now we just store HTML self . children . update ({ component . name : html }) self . active_css_rules . update ( component . active_css_rules ) else : self . children . update ({ component . name : render_result }) self . props . update ( component . props ) return self","title":"sub_component"},{"location":"reference/probo/components/elements/","text":"elements Element A class to create HTML elements with attributes and content. Source code in src\\probo\\components\\elements.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 class Element : \"\"\"A class to create HTML elements with attributes and content.\"\"\" def __init__ ( self , tag = str (), content : str = \"\" , is_list : bool = False , is_natural : bool = False , ** attrs , ): self . element : str | list [ str ] = str () self . is_list : bool = is_list self . is_natural : bool = is_natural self . content : str = content or str () self . attrs : dict [ str , str ] = attrs self . tag = tag if self . tag : self . element = self . build_tag ( self . tag ) . replace ( MARKER , \"\" ) def __getattr__ ( self , name ): self . tag = name if self . _tag_loader ( name ): return getattr ( self , name ) else : raise AttributeError ( f \"Tag ' { name } ' is not defined as { self . __name__ } method. \" ) def _tag_loader ( self , name : str ) -> bool : try : attr = Tag [ name . upper ()] method = self . make_private_handler ( attr ) method_name = f \" { attr . name . lower () } \" # name-mangled to be private setattr ( self , method_name , method ) return True except : return False def make_private_handler ( self , attr ): def handler ( * args , ** kwargs ): is_args = False if args or kwargs : parsed = self . _element_parser ( * args , ** kwargs ) tag = parsed [ \"tag\" ] attrs_dict = parsed [ \"attrs\" ] content = parsed [ \"content\" ] self . attrs . update ( attrs_dict ) if CONTENT_MARKER in self . content : self . content = self . content . replace ( CONTENT_MARKER , content ) else : self . content += content # is_args = True # if is_args: # string = self.build_tag(tag) # assuming Tag.A is valid # else: string = self . build_tag ( attr ) # assuming Tag.A is valid if self . is_list : self . element = string . split ( MARKER ) else : if self . is_natural : self . element = string . replace ( MARKER , \" \\n \" ) else : self . element = string . replace ( MARKER , \"\" ) self . attrs . clear () return self return handler def _element_parser ( self , * args , ** kwargs ): \"\"\" Smart HTML handler. Accepts: - tag name: str - attrs: dict or kwargs - context: str, ElementObj, or anything \"\"\" tag = None attrs_dict = {} content = \" \" element_obj = None for arg in args : if isinstance ( arg , str ) and Tag . get ( arg ) and not tag : try : result = Tag . get ( arg ) if result : tag = result element_obj = self . __class__ ( is_list = self . is_list , is_natural = self . is_natural ) except Exception as e : content = f '<strong style=\"color:red;size:120px;\"> { e } </strong>' break elif isinstance ( arg , str ): content += arg elif isinstance ( arg , dict ): attrs_dict . update ( arg ) elif hasattr ( arg , \"_Element_tag_loader\" ): content += arg . element elif isinstance ( arg , ( str , int , float )): content += str ( arg ) attrs_dict . update ( kwargs ) if element_obj and tag : try : func = getattr ( element_obj , tag . value [ 0 ]) content = func ( content , ** attrs_dict ) . element attrs_dict . clear () except : pass if not tag : tag = tag or Tag . get ( \"div\" ) return { \"tag\" : tag , \"attrs\" : attrs_dict , \"content\" : content , } def build_tag ( self , tag , is_custom = False ): if not isinstance ( tag , Enum ): tag = Tag . get ( str ( tag )) if not is_custom : flag = self . element_health ( opening_tag = f \"< { tag . value [ 0 ] } >\" ) if isinstance ( flag , str ): return flag if tag . value [ 1 ][ \"void\" ]: if self . tag == \"doctype\" : return f \"< { tag . value [ 0 ] }{ self . render_attrs () } >\" else : return f \"< { tag . value [ 0 ] }{ self . render_attrs () } />\" else : return f \"< { tag . value [ 0 ] }{ self . render_attrs () } > { MARKER }{ self . render_content () }{ MARKER } </ { tag . value [ 0 ] } >\" def render_attrs ( self ): \"\"\"Render the attributes of the element as a string.\"\"\" if not self . attrs : return str () # attr_string = \" \" + \" \".join(f'{key.lower().replace('_','-') if '_' in key.lower() else key.lower()}=\"{value}\"' for key, value in self.attrs.items()) attr_string = f \" { render_attributes ( self . tag , self . attrs ) } \" return attr_string def element_health ( self , opening_tag : str ): \"\"\"Check if the element is valid and return it or an error message.\"\"\" attribute_value = ElementAttributeValidator ( element_tag = opening_tag , ** self . attrs ) if attribute_value . is_valid or not self . attrs : self . attrs = attribute_value . valid_attrs return self else : error_attrs_string = \" \" . join ( attribute_value . error_attrs ) message = f '<div style=\"color:red;\"><strong> \" { opening_tag [ 1 : - 1 ] } \" element don \\' accept these attributes \" { error_attrs_string } \" </strong> element string: \"\" { opening_tag } \"\"</div> \\n ' attribute_value . error_attrs . clear () return message def stringify_element ( self , ): \"\"\"Convert the element to a string representation.\"\"\" if self . is_list : self . element = \"\" . join ( self . element ) return self def render_content ( self ): \"\"\"Render the content of the element.\"\"\" if not self . content : return str () content_string = f \" { self . content . replace ( CONTENT_MARKER , self . element ) if CONTENT_MARKER in self . content and self . element else self . content } \" self . content = \"\" return content_string def set_attrs ( self , ** attributes ): \"\"\"Set attributes for the element.\"\"\" self . attrs = attributes return self def render ( self ): return self . element def set_content ( self , content : str , extend = False ): \"\"\" Set the content for the element. \"\"\" if extend : self . content += content else : self . content = content return self def raw ( self , * string , inner = False , is_comment = False ) -> \"Element\" : STRING = \"\" . join ([ \"<!--\" , * string , \"-->\" ]) if inner : self . content += \"<!--\" + STRING + \"-->\" if is_comment else STRING if self . is_list : self . element . extend ( [ \"<!--\" , * string , \"-->\" ] ) if is_comment else self . element . extend ( list ( string )) else : self . element += \"<!--\" + STRING + \"-->\" if is_comment else STRING return self def set_data ( self , * string ) -> \"Element\" : self . content += \" \" . join ( [ f '<$probo-var name=\" { str ( string_arg ) } \"/>' for string_arg in string ] ) return self def custom_element ( self , cstm_tag , content = \"\" , is_void_element = False , ** attrs ): tag = Enum ( \"tag\" , { cstm_tag . upper (): [ cstm_tag . lower (), { \"void\" : True if cstm_tag . lower () in VoidTags . VOID_TAGS . value or is_void_element else False }, ] }, ) if tag or attrs : self . attrs . update ( attrs ) if CONTENT_MARKER in self . content : self . content = self . content . replace ( CONTENT_MARKER , content ) else : self . content += content string = self . build_tag ( tag [ cstm_tag . upper ()], is_custom = True ) if self . is_list : self . element = string . split ( MARKER ) else : if self . is_natural : self . element = string . replace ( MARKER , \" \\n \" ) else : self . element = string . replace ( MARKER , \"\" ) self . attrs . clear () return self def __str__ ( self , ): return str ( self . stringify_element () . element ) element_health ( opening_tag ) Check if the element is valid and return it or an error message. Source code in src\\probo\\components\\elements.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def element_health ( self , opening_tag : str ): \"\"\"Check if the element is valid and return it or an error message.\"\"\" attribute_value = ElementAttributeValidator ( element_tag = opening_tag , ** self . attrs ) if attribute_value . is_valid or not self . attrs : self . attrs = attribute_value . valid_attrs return self else : error_attrs_string = \" \" . join ( attribute_value . error_attrs ) message = f '<div style=\"color:red;\"><strong> \" { opening_tag [ 1 : - 1 ] } \" element don \\' accept these attributes \" { error_attrs_string } \" </strong> element string: \"\" { opening_tag } \"\"</div> \\n ' attribute_value . error_attrs . clear () return message render_attrs () Render the attributes of the element as a string. Source code in src\\probo\\components\\elements.py 149 150 151 152 153 154 155 def render_attrs ( self ): \"\"\"Render the attributes of the element as a string.\"\"\" if not self . attrs : return str () # attr_string = \" \" + \" \".join(f'{key.lower().replace('_','-') if '_' in key.lower() else key.lower()}=\"{value}\"' for key, value in self.attrs.items()) attr_string = f \" { render_attributes ( self . tag , self . attrs ) } \" return attr_string render_content () Render the content of the element. Source code in src\\probo\\components\\elements.py 180 181 182 183 184 185 186 def render_content ( self ): \"\"\"Render the content of the element.\"\"\" if not self . content : return str () content_string = f \" { self . content . replace ( CONTENT_MARKER , self . element ) if CONTENT_MARKER in self . content and self . element else self . content } \" self . content = \"\" return content_string set_attrs ( ** attributes ) Set attributes for the element. Source code in src\\probo\\components\\elements.py 188 189 190 191 def set_attrs ( self , ** attributes ): \"\"\"Set attributes for the element.\"\"\" self . attrs = attributes return self set_content ( content , extend = False ) Set the content for the element. Source code in src\\probo\\components\\elements.py 196 197 198 199 200 201 202 203 204 def set_content ( self , content : str , extend = False ): \"\"\" Set the content for the element. \"\"\" if extend : self . content += content else : self . content = content return self stringify_element () Convert the element to a string representation. Source code in src\\probo\\components\\elements.py 172 173 174 175 176 177 178 def stringify_element ( self , ): \"\"\"Convert the element to a string representation.\"\"\" if self . is_list : self . element = \"\" . join ( self . element ) return self Head Manages the section of an HTML document. This class acts as a smart registry for metadata, links, scripts, and titles. It uses a key-based system to handle overwrites, allowing child templates or components to replace metadata defined in parent layouts (e.g., changing the page title dynamically). Parameters: *head_strings \u2013 Initial list of elements (title, meta tags, etc.) to add. Attributes: _registry ( OrderedDict ) \u2013 Internal storage ensuring insertion order and unique keys. Example head = Head() head.set_title(\"Home Page\") head.register_meta(name=\"description\", content=\"Welcome\") print(head.render()) Home Page Source code in src\\probo\\components\\elements.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 class Head : \"\"\" Manages the <head> section of an HTML document. This class acts as a smart registry for metadata, links, scripts, and titles. It uses a key-based system to handle overwrites, allowing child templates or components to replace metadata defined in parent layouts (e.g., changing the page title dynamically). Args: *head_strings: Initial list of elements (title, meta tags, etc.) to add. Attributes: _registry (OrderedDict): Internal storage ensuring insertion order and unique keys. Example: >>> head = Head() >>> head.set_title(\"Home Page\") >>> head.register_meta(name=\"description\", content=\"Welcome\") >>> print(head.render()) <head><title>Home Page</title><meta name=\"description\" content=\"Welcome\"></head> \"\"\" def __init__ ( self , * head_strings ): self . head_strings = list ( head_strings ) self . _registry = OrderedDict () self . meta_tags = [] self . link_tags = [] self . script_tags = [] self . style_tags = [] self . title = None self . _var_attrs = {} for item in head_strings : self . add ( item ) def add ( self , element , key = None ): \"\"\" Smartly adds an element to the head. If a key matches an existing element, it OVERWRITES it. \"\"\" # 1. Determine Key if key is None : key = self . _generate_key ( element ) # 2. Store (Overwrite if exists) self . _registry [ key ] = ( element . element if isinstance ( element , Element ) else str ( element ) ) return self def _generate_key ( self , element ): \"\"\"Auto-generates keys based on element type/attributes.\"\"\" # Assuming element has .tag_name and .attrs properties tag = getattr ( element , \"tag\" , \"unknown\" ) attrs = getattr ( element , \"attrs\" , {}) or self . _var_attrs if tag == \"title\" : self . title = element . element return \"title\" # Singleton if tag == \"meta\" : if \"name\" in attrs : return f \"meta:name: { attrs [ 'name' ] } \" if \"property\" in attrs : # For OpenGraph return f \"meta:property: { attrs [ 'property' ] } \" if \"charset\" in attrs : return \"meta:charset\" self . meta_tags . append ( element . element ) if tag == \"link\" : self . link_tags . append ( element . element ) if \"rel\" in attrs : return f \"link:rel: { attrs [ 'rel' ] } \" if tag == \"script\" : self . script_tags . append ( element . element ) if tag == \"style\" : self . style_tags . append ( element . element ) # Fallback: Use a UUID if we can't identify it uniquely # or just append a random counter if you want to allow duplicates by default import uuid return f \" { tag } : { uuid . uuid4 () . hex [: 8 ] } \" def set_title ( self , title : str , ** title_attrs ): title = Element () . set_attrs ( ** title_attrs ) . set_content ( title ) . title () self . _var_attrs = title_attrs return self . add ( title ) def register_meta ( self , ** meta_attrs ): meta_tag = Element () . set_attrs ( ** meta_attrs ) . meta () self . _var_attrs = meta_attrs return self . add ( meta_tag ) def register_link ( self , ** link_attrs ): link_tag = Element () . set_attrs ( ** link_attrs ) . link () self . _var_attrs = link_attrs return self . add ( link_tag ) def register_script ( self , content = \"\" , ** attrs ): script_tag = Element () . set_attrs ( ** attrs ) . set_content ( content ) . script () self . _var_attrs = attrs return self . add ( script_tag ) def register_style ( self , content = \"\" ): style_tag = Element () . set_content ( content ) . style () return self . add ( style_tag ) def render ( self , * extra_head_content ): \"\"\" Render the full <head> tag with all registered tags and content. \"\"\" for x in extra_head_content : self . add ( x ) head_tag = ( Element () . set_content ( \"\" . join ([ el for el in self . _registry . values ()])) . head () . element ) return head_tag add ( element , key = None ) Smartly adds an element to the head. If a key matches an existing element, it OVERWRITES it. Source code in src\\probo\\components\\elements.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def add ( self , element , key = None ): \"\"\" Smartly adds an element to the head. If a key matches an existing element, it OVERWRITES it. \"\"\" # 1. Determine Key if key is None : key = self . _generate_key ( element ) # 2. Store (Overwrite if exists) self . _registry [ key ] = ( element . element if isinstance ( element , Element ) else str ( element ) ) return self render ( * extra_head_content ) Render the full tag with all registered tags and content. Source code in src\\probo\\components\\elements.py 370 371 372 373 374 375 376 377 378 379 380 381 382 def render ( self , * extra_head_content ): \"\"\" Render the full <head> tag with all registered tags and content. \"\"\" for x in extra_head_content : self . add ( x ) head_tag = ( Element () . set_content ( \"\" . join ([ el for el in self . _registry . values ()])) . head () . element ) return head_tag Template Represents a full HTML Document. Acts as a Layout Manager allowing components to be swapped by name. This class serves as the skeleton for pages. It manages the global <head> and organizes body content into named slots (header, main, footer). It supports dynamic component swapping, making it ideal for layout inheritance. Args: separator (str, optional): String or HTML to place between body components. Defaults to \" \". **components (dict): Named slots for the body content (e.g., header=..., main=...). Attributes: head (Head): The managed Head instance for this document. components (OrderedDict): The ordered registry of body components. Example: >>> # Define Layout >>> layout = Template( ... header=\"<nav>...</nav>\", ... main=\"<!-- Content -->\", ... footer=\"<footer>...</footer>\" ... ) >>> >>> # Swap Content >>> layout.swap_component(main=\"<h1>Hello World</h1>\") >>> >>> # Render >>> html = layout.render() Source code in src\\probo\\components\\elements.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 class Template : \"\"\" Represents a full HTML Document. Acts as a Layout Manager allowing components to be swapped by name. This class serves as the skeleton for pages. It manages the global <head> and organizes body content into named slots (header, main, footer). It supports dynamic component swapping, making it ideal for layout inheritance. Args: separator (str, optional): String or HTML to place between body components. Defaults to \"\\n\". **components (dict): Named slots for the body content (e.g., header=..., main=...). Attributes: head (Head): The managed Head instance for this document. components (OrderedDict): The ordered registry of body components. Example: >>> # Define Layout >>> layout = Template( ... header=\"<nav>...</nav>\", ... main=\"<!-- Content -->\", ... footer=\"<footer>...</footer>\" ... ) >>> >>> # Swap Content >>> layout.swap_component(main=\"<h1>Hello World</h1>\") >>> >>> # Render >>> html = layout.render() \"\"\" def __init__ ( self , separator : str = \" \\n \" , ** components ): \"\"\" Initialize the template. Args: separator: String or HTML to place between body components. **components: Named slots for the body (e.g., header=..., main=...) \"\"\" self . separator = separator # 1. Initialize Smart Head (Standard HTML5 Defaults) self . head = Head () self . head . register_meta ( charset = \"UTF-8\" ) self . head . register_meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) self . head . set_title ( \"probo Page\" ) self . __loaded_base = \"\" # 2. Initialize Body Slots (OrderedDict preserves insertion order) self . components = OrderedDict ( components ) def swap_component ( self , ** kwargs ): \"\"\" Updates or adds components to the body slots. Usage: template.swap_component(main=NewComponent()) \"\"\" self . components . update ( kwargs ) return self def load_base_template ( self , template : str , use_as_base = False ): if use_as_base : self . switch_base = True if template : self . __loaded_base = template else : self . switch_base = False return self def _get_separator_html ( self ) -> str : \"\"\"Resolves the separator into a string.\"\"\" if self . separator == \"hr\" : return hr () . render () elif self . separator == \"comment\" : return \" \\n <!-- Section Break --> \\n \" return self . separator def render ( self ) -> str : \"\"\" Assembles the full document: DOCTYPE + HTML(HEAD + BODY). \"\"\" # 1. Render Body Components rendered_parts = [] for comp in self . components . values (): if hasattr ( comp , \"render\" ): # It's a Component/Element -> Render it # Handle tuple return from Component (html, css) result = comp . render () if isinstance ( result , tuple ): # If component returned CSS, inject it into HEAD automatically # This is a \"Pro\" feature: Automatic Style hoisting html_str , css_str = result if css_str : self . head . register_style ( css_str ) rendered_parts . append ( html_str ) else : rendered_parts . append ( result ) else : # It's a string rendered_parts . append ( str ( comp )) # 2. Join Body parts sep = self . _get_separator_html () body_content = sep . join ( rendered_parts ) # 3. Construct the Tree # doctype() returns string \"<!DOCTYPE html>\" # html(...) wraps head and body # Note: We use your functional tags here document = ( Element () . doctype () . element + Element () . set_attrs ( lang = \"en\" ) . set_content ( self . head . render () + Element () . set_content ( body_content ) . body () . element ) . html () . element ) return document def preview ( self ): \"\"\" Renders and opens the template in the default web browser. \"\"\" html_content = self . render () with tempfile . NamedTemporaryFile ( \"w\" , delete = False , suffix = \".html\" , encoding = \"utf-8\" ) as f : f . write ( html_content ) f . flush () url = f \"file:// { os . path . abspath ( f . name ) } \" print ( f \"Opening preview: { url } \" ) webbrowser . open ( url ) __init__ ( separator = ' \\n ' , ** components ) Initialize the template. Args: separator: String or HTML to place between body components. **components: Named slots for the body (e.g., header=..., main=...) Source code in src\\probo\\components\\elements.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def __init__ ( self , separator : str = \" \\n \" , ** components ): \"\"\" Initialize the template. Args: separator: String or HTML to place between body components. **components: Named slots for the body (e.g., header=..., main=...) \"\"\" self . separator = separator # 1. Initialize Smart Head (Standard HTML5 Defaults) self . head = Head () self . head . register_meta ( charset = \"UTF-8\" ) self . head . register_meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) self . head . set_title ( \"probo Page\" ) self . __loaded_base = \"\" # 2. Initialize Body Slots (OrderedDict preserves insertion order) self . components = OrderedDict ( components ) preview () Renders and opens the template in the default web browser. Source code in src\\probo\\components\\elements.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def preview ( self ): \"\"\" Renders and opens the template in the default web browser. \"\"\" html_content = self . render () with tempfile . NamedTemporaryFile ( \"w\" , delete = False , suffix = \".html\" , encoding = \"utf-8\" ) as f : f . write ( html_content ) f . flush () url = f \"file:// { os . path . abspath ( f . name ) } \" print ( f \"Opening preview: { url } \" ) webbrowser . open ( url ) render () Assembles the full document: DOCTYPE + HTML(HEAD + BODY). Source code in src\\probo\\components\\elements.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def render ( self ) -> str : \"\"\" Assembles the full document: DOCTYPE + HTML(HEAD + BODY). \"\"\" # 1. Render Body Components rendered_parts = [] for comp in self . components . values (): if hasattr ( comp , \"render\" ): # It's a Component/Element -> Render it # Handle tuple return from Component (html, css) result = comp . render () if isinstance ( result , tuple ): # If component returned CSS, inject it into HEAD automatically # This is a \"Pro\" feature: Automatic Style hoisting html_str , css_str = result if css_str : self . head . register_style ( css_str ) rendered_parts . append ( html_str ) else : rendered_parts . append ( result ) else : # It's a string rendered_parts . append ( str ( comp )) # 2. Join Body parts sep = self . _get_separator_html () body_content = sep . join ( rendered_parts ) # 3. Construct the Tree # doctype() returns string \"<!DOCTYPE html>\" # html(...) wraps head and body # Note: We use your functional tags here document = ( Element () . doctype () . element + Element () . set_attrs ( lang = \"en\" ) . set_content ( self . head . render () + Element () . set_content ( body_content ) . body () . element ) . html () . element ) return document swap_component ( ** kwargs ) Updates or adds components to the body slots. Usage: template.swap_component(main=NewComponent()) Source code in src\\probo\\components\\elements.py 437 438 439 440 441 442 443 def swap_component ( self , ** kwargs ): \"\"\" Updates or adds components to the body slots. Usage: template.swap_component(main=NewComponent()) \"\"\" self . components . update ( kwargs ) return self","title":"elements"},{"location":"reference/probo/components/elements/#elements","text":"","title":"elements"},{"location":"reference/probo/components/elements/#probo.components.elements.Element","text":"A class to create HTML elements with attributes and content. Source code in src\\probo\\components\\elements.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 class Element : \"\"\"A class to create HTML elements with attributes and content.\"\"\" def __init__ ( self , tag = str (), content : str = \"\" , is_list : bool = False , is_natural : bool = False , ** attrs , ): self . element : str | list [ str ] = str () self . is_list : bool = is_list self . is_natural : bool = is_natural self . content : str = content or str () self . attrs : dict [ str , str ] = attrs self . tag = tag if self . tag : self . element = self . build_tag ( self . tag ) . replace ( MARKER , \"\" ) def __getattr__ ( self , name ): self . tag = name if self . _tag_loader ( name ): return getattr ( self , name ) else : raise AttributeError ( f \"Tag ' { name } ' is not defined as { self . __name__ } method. \" ) def _tag_loader ( self , name : str ) -> bool : try : attr = Tag [ name . upper ()] method = self . make_private_handler ( attr ) method_name = f \" { attr . name . lower () } \" # name-mangled to be private setattr ( self , method_name , method ) return True except : return False def make_private_handler ( self , attr ): def handler ( * args , ** kwargs ): is_args = False if args or kwargs : parsed = self . _element_parser ( * args , ** kwargs ) tag = parsed [ \"tag\" ] attrs_dict = parsed [ \"attrs\" ] content = parsed [ \"content\" ] self . attrs . update ( attrs_dict ) if CONTENT_MARKER in self . content : self . content = self . content . replace ( CONTENT_MARKER , content ) else : self . content += content # is_args = True # if is_args: # string = self.build_tag(tag) # assuming Tag.A is valid # else: string = self . build_tag ( attr ) # assuming Tag.A is valid if self . is_list : self . element = string . split ( MARKER ) else : if self . is_natural : self . element = string . replace ( MARKER , \" \\n \" ) else : self . element = string . replace ( MARKER , \"\" ) self . attrs . clear () return self return handler def _element_parser ( self , * args , ** kwargs ): \"\"\" Smart HTML handler. Accepts: - tag name: str - attrs: dict or kwargs - context: str, ElementObj, or anything \"\"\" tag = None attrs_dict = {} content = \" \" element_obj = None for arg in args : if isinstance ( arg , str ) and Tag . get ( arg ) and not tag : try : result = Tag . get ( arg ) if result : tag = result element_obj = self . __class__ ( is_list = self . is_list , is_natural = self . is_natural ) except Exception as e : content = f '<strong style=\"color:red;size:120px;\"> { e } </strong>' break elif isinstance ( arg , str ): content += arg elif isinstance ( arg , dict ): attrs_dict . update ( arg ) elif hasattr ( arg , \"_Element_tag_loader\" ): content += arg . element elif isinstance ( arg , ( str , int , float )): content += str ( arg ) attrs_dict . update ( kwargs ) if element_obj and tag : try : func = getattr ( element_obj , tag . value [ 0 ]) content = func ( content , ** attrs_dict ) . element attrs_dict . clear () except : pass if not tag : tag = tag or Tag . get ( \"div\" ) return { \"tag\" : tag , \"attrs\" : attrs_dict , \"content\" : content , } def build_tag ( self , tag , is_custom = False ): if not isinstance ( tag , Enum ): tag = Tag . get ( str ( tag )) if not is_custom : flag = self . element_health ( opening_tag = f \"< { tag . value [ 0 ] } >\" ) if isinstance ( flag , str ): return flag if tag . value [ 1 ][ \"void\" ]: if self . tag == \"doctype\" : return f \"< { tag . value [ 0 ] }{ self . render_attrs () } >\" else : return f \"< { tag . value [ 0 ] }{ self . render_attrs () } />\" else : return f \"< { tag . value [ 0 ] }{ self . render_attrs () } > { MARKER }{ self . render_content () }{ MARKER } </ { tag . value [ 0 ] } >\" def render_attrs ( self ): \"\"\"Render the attributes of the element as a string.\"\"\" if not self . attrs : return str () # attr_string = \" \" + \" \".join(f'{key.lower().replace('_','-') if '_' in key.lower() else key.lower()}=\"{value}\"' for key, value in self.attrs.items()) attr_string = f \" { render_attributes ( self . tag , self . attrs ) } \" return attr_string def element_health ( self , opening_tag : str ): \"\"\"Check if the element is valid and return it or an error message.\"\"\" attribute_value = ElementAttributeValidator ( element_tag = opening_tag , ** self . attrs ) if attribute_value . is_valid or not self . attrs : self . attrs = attribute_value . valid_attrs return self else : error_attrs_string = \" \" . join ( attribute_value . error_attrs ) message = f '<div style=\"color:red;\"><strong> \" { opening_tag [ 1 : - 1 ] } \" element don \\' accept these attributes \" { error_attrs_string } \" </strong> element string: \"\" { opening_tag } \"\"</div> \\n ' attribute_value . error_attrs . clear () return message def stringify_element ( self , ): \"\"\"Convert the element to a string representation.\"\"\" if self . is_list : self . element = \"\" . join ( self . element ) return self def render_content ( self ): \"\"\"Render the content of the element.\"\"\" if not self . content : return str () content_string = f \" { self . content . replace ( CONTENT_MARKER , self . element ) if CONTENT_MARKER in self . content and self . element else self . content } \" self . content = \"\" return content_string def set_attrs ( self , ** attributes ): \"\"\"Set attributes for the element.\"\"\" self . attrs = attributes return self def render ( self ): return self . element def set_content ( self , content : str , extend = False ): \"\"\" Set the content for the element. \"\"\" if extend : self . content += content else : self . content = content return self def raw ( self , * string , inner = False , is_comment = False ) -> \"Element\" : STRING = \"\" . join ([ \"<!--\" , * string , \"-->\" ]) if inner : self . content += \"<!--\" + STRING + \"-->\" if is_comment else STRING if self . is_list : self . element . extend ( [ \"<!--\" , * string , \"-->\" ] ) if is_comment else self . element . extend ( list ( string )) else : self . element += \"<!--\" + STRING + \"-->\" if is_comment else STRING return self def set_data ( self , * string ) -> \"Element\" : self . content += \" \" . join ( [ f '<$probo-var name=\" { str ( string_arg ) } \"/>' for string_arg in string ] ) return self def custom_element ( self , cstm_tag , content = \"\" , is_void_element = False , ** attrs ): tag = Enum ( \"tag\" , { cstm_tag . upper (): [ cstm_tag . lower (), { \"void\" : True if cstm_tag . lower () in VoidTags . VOID_TAGS . value or is_void_element else False }, ] }, ) if tag or attrs : self . attrs . update ( attrs ) if CONTENT_MARKER in self . content : self . content = self . content . replace ( CONTENT_MARKER , content ) else : self . content += content string = self . build_tag ( tag [ cstm_tag . upper ()], is_custom = True ) if self . is_list : self . element = string . split ( MARKER ) else : if self . is_natural : self . element = string . replace ( MARKER , \" \\n \" ) else : self . element = string . replace ( MARKER , \"\" ) self . attrs . clear () return self def __str__ ( self , ): return str ( self . stringify_element () . element )","title":"Element"},{"location":"reference/probo/components/elements/#probo.components.elements.Element.element_health","text":"Check if the element is valid and return it or an error message. Source code in src\\probo\\components\\elements.py 157 158 159 160 161 162 163 164 165 166 167 168 169 170 def element_health ( self , opening_tag : str ): \"\"\"Check if the element is valid and return it or an error message.\"\"\" attribute_value = ElementAttributeValidator ( element_tag = opening_tag , ** self . attrs ) if attribute_value . is_valid or not self . attrs : self . attrs = attribute_value . valid_attrs return self else : error_attrs_string = \" \" . join ( attribute_value . error_attrs ) message = f '<div style=\"color:red;\"><strong> \" { opening_tag [ 1 : - 1 ] } \" element don \\' accept these attributes \" { error_attrs_string } \" </strong> element string: \"\" { opening_tag } \"\"</div> \\n ' attribute_value . error_attrs . clear () return message","title":"element_health"},{"location":"reference/probo/components/elements/#probo.components.elements.Element.render_attrs","text":"Render the attributes of the element as a string. Source code in src\\probo\\components\\elements.py 149 150 151 152 153 154 155 def render_attrs ( self ): \"\"\"Render the attributes of the element as a string.\"\"\" if not self . attrs : return str () # attr_string = \" \" + \" \".join(f'{key.lower().replace('_','-') if '_' in key.lower() else key.lower()}=\"{value}\"' for key, value in self.attrs.items()) attr_string = f \" { render_attributes ( self . tag , self . attrs ) } \" return attr_string","title":"render_attrs"},{"location":"reference/probo/components/elements/#probo.components.elements.Element.render_content","text":"Render the content of the element. Source code in src\\probo\\components\\elements.py 180 181 182 183 184 185 186 def render_content ( self ): \"\"\"Render the content of the element.\"\"\" if not self . content : return str () content_string = f \" { self . content . replace ( CONTENT_MARKER , self . element ) if CONTENT_MARKER in self . content and self . element else self . content } \" self . content = \"\" return content_string","title":"render_content"},{"location":"reference/probo/components/elements/#probo.components.elements.Element.set_attrs","text":"Set attributes for the element. Source code in src\\probo\\components\\elements.py 188 189 190 191 def set_attrs ( self , ** attributes ): \"\"\"Set attributes for the element.\"\"\" self . attrs = attributes return self","title":"set_attrs"},{"location":"reference/probo/components/elements/#probo.components.elements.Element.set_content","text":"Set the content for the element. Source code in src\\probo\\components\\elements.py 196 197 198 199 200 201 202 203 204 def set_content ( self , content : str , extend = False ): \"\"\" Set the content for the element. \"\"\" if extend : self . content += content else : self . content = content return self","title":"set_content"},{"location":"reference/probo/components/elements/#probo.components.elements.Element.stringify_element","text":"Convert the element to a string representation. Source code in src\\probo\\components\\elements.py 172 173 174 175 176 177 178 def stringify_element ( self , ): \"\"\"Convert the element to a string representation.\"\"\" if self . is_list : self . element = \"\" . join ( self . element ) return self","title":"stringify_element"},{"location":"reference/probo/components/elements/#probo.components.elements.Head","text":"Manages the section of an HTML document. This class acts as a smart registry for metadata, links, scripts, and titles. It uses a key-based system to handle overwrites, allowing child templates or components to replace metadata defined in parent layouts (e.g., changing the page title dynamically). Parameters: *head_strings \u2013 Initial list of elements (title, meta tags, etc.) to add. Attributes: _registry ( OrderedDict ) \u2013 Internal storage ensuring insertion order and unique keys. Example head = Head() head.set_title(\"Home Page\") head.register_meta(name=\"description\", content=\"Welcome\") print(head.render()) Home Page Source code in src\\probo\\components\\elements.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 class Head : \"\"\" Manages the <head> section of an HTML document. This class acts as a smart registry for metadata, links, scripts, and titles. It uses a key-based system to handle overwrites, allowing child templates or components to replace metadata defined in parent layouts (e.g., changing the page title dynamically). Args: *head_strings: Initial list of elements (title, meta tags, etc.) to add. Attributes: _registry (OrderedDict): Internal storage ensuring insertion order and unique keys. Example: >>> head = Head() >>> head.set_title(\"Home Page\") >>> head.register_meta(name=\"description\", content=\"Welcome\") >>> print(head.render()) <head><title>Home Page</title><meta name=\"description\" content=\"Welcome\"></head> \"\"\" def __init__ ( self , * head_strings ): self . head_strings = list ( head_strings ) self . _registry = OrderedDict () self . meta_tags = [] self . link_tags = [] self . script_tags = [] self . style_tags = [] self . title = None self . _var_attrs = {} for item in head_strings : self . add ( item ) def add ( self , element , key = None ): \"\"\" Smartly adds an element to the head. If a key matches an existing element, it OVERWRITES it. \"\"\" # 1. Determine Key if key is None : key = self . _generate_key ( element ) # 2. Store (Overwrite if exists) self . _registry [ key ] = ( element . element if isinstance ( element , Element ) else str ( element ) ) return self def _generate_key ( self , element ): \"\"\"Auto-generates keys based on element type/attributes.\"\"\" # Assuming element has .tag_name and .attrs properties tag = getattr ( element , \"tag\" , \"unknown\" ) attrs = getattr ( element , \"attrs\" , {}) or self . _var_attrs if tag == \"title\" : self . title = element . element return \"title\" # Singleton if tag == \"meta\" : if \"name\" in attrs : return f \"meta:name: { attrs [ 'name' ] } \" if \"property\" in attrs : # For OpenGraph return f \"meta:property: { attrs [ 'property' ] } \" if \"charset\" in attrs : return \"meta:charset\" self . meta_tags . append ( element . element ) if tag == \"link\" : self . link_tags . append ( element . element ) if \"rel\" in attrs : return f \"link:rel: { attrs [ 'rel' ] } \" if tag == \"script\" : self . script_tags . append ( element . element ) if tag == \"style\" : self . style_tags . append ( element . element ) # Fallback: Use a UUID if we can't identify it uniquely # or just append a random counter if you want to allow duplicates by default import uuid return f \" { tag } : { uuid . uuid4 () . hex [: 8 ] } \" def set_title ( self , title : str , ** title_attrs ): title = Element () . set_attrs ( ** title_attrs ) . set_content ( title ) . title () self . _var_attrs = title_attrs return self . add ( title ) def register_meta ( self , ** meta_attrs ): meta_tag = Element () . set_attrs ( ** meta_attrs ) . meta () self . _var_attrs = meta_attrs return self . add ( meta_tag ) def register_link ( self , ** link_attrs ): link_tag = Element () . set_attrs ( ** link_attrs ) . link () self . _var_attrs = link_attrs return self . add ( link_tag ) def register_script ( self , content = \"\" , ** attrs ): script_tag = Element () . set_attrs ( ** attrs ) . set_content ( content ) . script () self . _var_attrs = attrs return self . add ( script_tag ) def register_style ( self , content = \"\" ): style_tag = Element () . set_content ( content ) . style () return self . add ( style_tag ) def render ( self , * extra_head_content ): \"\"\" Render the full <head> tag with all registered tags and content. \"\"\" for x in extra_head_content : self . add ( x ) head_tag = ( Element () . set_content ( \"\" . join ([ el for el in self . _registry . values ()])) . head () . element ) return head_tag","title":"Head"},{"location":"reference/probo/components/elements/#probo.components.elements.Head.add","text":"Smartly adds an element to the head. If a key matches an existing element, it OVERWRITES it. Source code in src\\probo\\components\\elements.py 299 300 301 302 303 304 305 306 307 308 309 310 311 312 def add ( self , element , key = None ): \"\"\" Smartly adds an element to the head. If a key matches an existing element, it OVERWRITES it. \"\"\" # 1. Determine Key if key is None : key = self . _generate_key ( element ) # 2. Store (Overwrite if exists) self . _registry [ key ] = ( element . element if isinstance ( element , Element ) else str ( element ) ) return self","title":"add"},{"location":"reference/probo/components/elements/#probo.components.elements.Head.render","text":"Render the full tag with all registered tags and content. Source code in src\\probo\\components\\elements.py 370 371 372 373 374 375 376 377 378 379 380 381 382 def render ( self , * extra_head_content ): \"\"\" Render the full <head> tag with all registered tags and content. \"\"\" for x in extra_head_content : self . add ( x ) head_tag = ( Element () . set_content ( \"\" . join ([ el for el in self . _registry . values ()])) . head () . element ) return head_tag","title":"render"},{"location":"reference/probo/components/elements/#probo.components.elements.Template","text":"Represents a full HTML Document. Acts as a Layout Manager allowing components to be swapped by name. This class serves as the skeleton for pages. It manages the global <head> and organizes body content into named slots (header, main, footer). It supports dynamic component swapping, making it ideal for layout inheritance. Args: separator (str, optional): String or HTML to place between body components. Defaults to \" \". **components (dict): Named slots for the body content (e.g., header=..., main=...). Attributes: head (Head): The managed Head instance for this document. components (OrderedDict): The ordered registry of body components. Example: >>> # Define Layout >>> layout = Template( ... header=\"<nav>...</nav>\", ... main=\"<!-- Content -->\", ... footer=\"<footer>...</footer>\" ... ) >>> >>> # Swap Content >>> layout.swap_component(main=\"<h1>Hello World</h1>\") >>> >>> # Render >>> html = layout.render() Source code in src\\probo\\components\\elements.py 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 class Template : \"\"\" Represents a full HTML Document. Acts as a Layout Manager allowing components to be swapped by name. This class serves as the skeleton for pages. It manages the global <head> and organizes body content into named slots (header, main, footer). It supports dynamic component swapping, making it ideal for layout inheritance. Args: separator (str, optional): String or HTML to place between body components. Defaults to \"\\n\". **components (dict): Named slots for the body content (e.g., header=..., main=...). Attributes: head (Head): The managed Head instance for this document. components (OrderedDict): The ordered registry of body components. Example: >>> # Define Layout >>> layout = Template( ... header=\"<nav>...</nav>\", ... main=\"<!-- Content -->\", ... footer=\"<footer>...</footer>\" ... ) >>> >>> # Swap Content >>> layout.swap_component(main=\"<h1>Hello World</h1>\") >>> >>> # Render >>> html = layout.render() \"\"\" def __init__ ( self , separator : str = \" \\n \" , ** components ): \"\"\" Initialize the template. Args: separator: String or HTML to place between body components. **components: Named slots for the body (e.g., header=..., main=...) \"\"\" self . separator = separator # 1. Initialize Smart Head (Standard HTML5 Defaults) self . head = Head () self . head . register_meta ( charset = \"UTF-8\" ) self . head . register_meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) self . head . set_title ( \"probo Page\" ) self . __loaded_base = \"\" # 2. Initialize Body Slots (OrderedDict preserves insertion order) self . components = OrderedDict ( components ) def swap_component ( self , ** kwargs ): \"\"\" Updates or adds components to the body slots. Usage: template.swap_component(main=NewComponent()) \"\"\" self . components . update ( kwargs ) return self def load_base_template ( self , template : str , use_as_base = False ): if use_as_base : self . switch_base = True if template : self . __loaded_base = template else : self . switch_base = False return self def _get_separator_html ( self ) -> str : \"\"\"Resolves the separator into a string.\"\"\" if self . separator == \"hr\" : return hr () . render () elif self . separator == \"comment\" : return \" \\n <!-- Section Break --> \\n \" return self . separator def render ( self ) -> str : \"\"\" Assembles the full document: DOCTYPE + HTML(HEAD + BODY). \"\"\" # 1. Render Body Components rendered_parts = [] for comp in self . components . values (): if hasattr ( comp , \"render\" ): # It's a Component/Element -> Render it # Handle tuple return from Component (html, css) result = comp . render () if isinstance ( result , tuple ): # If component returned CSS, inject it into HEAD automatically # This is a \"Pro\" feature: Automatic Style hoisting html_str , css_str = result if css_str : self . head . register_style ( css_str ) rendered_parts . append ( html_str ) else : rendered_parts . append ( result ) else : # It's a string rendered_parts . append ( str ( comp )) # 2. Join Body parts sep = self . _get_separator_html () body_content = sep . join ( rendered_parts ) # 3. Construct the Tree # doctype() returns string \"<!DOCTYPE html>\" # html(...) wraps head and body # Note: We use your functional tags here document = ( Element () . doctype () . element + Element () . set_attrs ( lang = \"en\" ) . set_content ( self . head . render () + Element () . set_content ( body_content ) . body () . element ) . html () . element ) return document def preview ( self ): \"\"\" Renders and opens the template in the default web browser. \"\"\" html_content = self . render () with tempfile . NamedTemporaryFile ( \"w\" , delete = False , suffix = \".html\" , encoding = \"utf-8\" ) as f : f . write ( html_content ) f . flush () url = f \"file:// { os . path . abspath ( f . name ) } \" print ( f \"Opening preview: { url } \" ) webbrowser . open ( url )","title":"Template"},{"location":"reference/probo/components/elements/#probo.components.elements.Template.__init__","text":"Initialize the template. Args: separator: String or HTML to place between body components. **components: Named slots for the body (e.g., header=..., main=...) Source code in src\\probo\\components\\elements.py 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 def __init__ ( self , separator : str = \" \\n \" , ** components ): \"\"\" Initialize the template. Args: separator: String or HTML to place between body components. **components: Named slots for the body (e.g., header=..., main=...) \"\"\" self . separator = separator # 1. Initialize Smart Head (Standard HTML5 Defaults) self . head = Head () self . head . register_meta ( charset = \"UTF-8\" ) self . head . register_meta ( name = \"viewport\" , content = \"width=device-width, initial-scale=1.0\" ) self . head . set_title ( \"probo Page\" ) self . __loaded_base = \"\" # 2. Initialize Body Slots (OrderedDict preserves insertion order) self . components = OrderedDict ( components )","title":"__init__"},{"location":"reference/probo/components/elements/#probo.components.elements.Template.preview","text":"Renders and opens the template in the default web browser. Source code in src\\probo\\components\\elements.py 509 510 511 512 513 514 515 516 517 518 519 520 521 522 def preview ( self ): \"\"\" Renders and opens the template in the default web browser. \"\"\" html_content = self . render () with tempfile . NamedTemporaryFile ( \"w\" , delete = False , suffix = \".html\" , encoding = \"utf-8\" ) as f : f . write ( html_content ) f . flush () url = f \"file:// { os . path . abspath ( f . name ) } \" print ( f \"Opening preview: { url } \" ) webbrowser . open ( url )","title":"preview"},{"location":"reference/probo/components/elements/#probo.components.elements.Template.render","text":"Assembles the full document: DOCTYPE + HTML(HEAD + BODY). Source code in src\\probo\\components\\elements.py 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 def render ( self ) -> str : \"\"\" Assembles the full document: DOCTYPE + HTML(HEAD + BODY). \"\"\" # 1. Render Body Components rendered_parts = [] for comp in self . components . values (): if hasattr ( comp , \"render\" ): # It's a Component/Element -> Render it # Handle tuple return from Component (html, css) result = comp . render () if isinstance ( result , tuple ): # If component returned CSS, inject it into HEAD automatically # This is a \"Pro\" feature: Automatic Style hoisting html_str , css_str = result if css_str : self . head . register_style ( css_str ) rendered_parts . append ( html_str ) else : rendered_parts . append ( result ) else : # It's a string rendered_parts . append ( str ( comp )) # 2. Join Body parts sep = self . _get_separator_html () body_content = sep . join ( rendered_parts ) # 3. Construct the Tree # doctype() returns string \"<!DOCTYPE html>\" # html(...) wraps head and body # Note: We use your functional tags here document = ( Element () . doctype () . element + Element () . set_attrs ( lang = \"en\" ) . set_content ( self . head . render () + Element () . set_content ( body_content ) . body () . element ) . html () . element ) return document","title":"render"},{"location":"reference/probo/components/elements/#probo.components.elements.Template.swap_component","text":"Updates or adds components to the body slots. Usage: template.swap_component(main=NewComponent()) Source code in src\\probo\\components\\elements.py 437 438 439 440 441 442 443 def swap_component ( self , ** kwargs ): \"\"\" Updates or adds components to the body slots. Usage: template.swap_component(main=NewComponent()) \"\"\" self . components . update ( kwargs ) return self","title":"swap_component"},{"location":"reference/probo/components/node/","text":"node ElementNodeMixin + Adds Tree capabilities to any class. Source code in src\\probo\\components\\node.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ElementNodeMixin : \"\"\"+ Adds Tree capabilities to any class. \"\"\" def __init__ ( self ): self . children = [] self . parent = None def __init_subclass__ ( cls , ** kwargs ): cls . _id = f \" { ( kwargs . get ( \"id\" , None ) or 'probo' ) } - { uuid . uuid4 () . hex [: 8 ] } \" def add ( self , child , index = None ): \"\"\" Adds a child node. Handles parent linkage automatically. \"\"\" if child is None : return self # Link the child to this parent if hasattr ( child , 'parent' ): child . parent = self if index is None : self . children . append ( child ) else : self . children . insert ( index , child ) return self # Return self for chaining! .add(x).add(y) def remove ( self , child ): if child in self . children : self . children . remove ( child ) if hasattr ( child , 'parent' ): child . parent = None return self def get_tree_depth ( self ): \"\"\"Helper to know how deep this node is.\"\"\" depth = 0 p = self . parent while p : depth += 1 p = p . parent return depth add ( child , index = None ) Adds a child node. Handles parent linkage automatically. Source code in src\\probo\\components\\node.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def add ( self , child , index = None ): \"\"\" Adds a child node. Handles parent linkage automatically. \"\"\" if child is None : return self # Link the child to this parent if hasattr ( child , 'parent' ): child . parent = self if index is None : self . children . append ( child ) else : self . children . insert ( index , child ) return self # Return self for chaining! .add(x).add(y) get_tree_depth () Helper to know how deep this node is. Source code in src\\probo\\components\\node.py 35 36 37 38 39 40 41 42 def get_tree_depth ( self ): \"\"\"Helper to know how deep this node is.\"\"\" depth = 0 p = self . parent while p : depth += 1 p = p . parent return depth","title":"node"},{"location":"reference/probo/components/node/#node","text":"","title":"node"},{"location":"reference/probo/components/node/#probo.components.node.ElementNodeMixin","text":"+ Adds Tree capabilities to any class. Source code in src\\probo\\components\\node.py 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class ElementNodeMixin : \"\"\"+ Adds Tree capabilities to any class. \"\"\" def __init__ ( self ): self . children = [] self . parent = None def __init_subclass__ ( cls , ** kwargs ): cls . _id = f \" { ( kwargs . get ( \"id\" , None ) or 'probo' ) } - { uuid . uuid4 () . hex [: 8 ] } \" def add ( self , child , index = None ): \"\"\" Adds a child node. Handles parent linkage automatically. \"\"\" if child is None : return self # Link the child to this parent if hasattr ( child , 'parent' ): child . parent = self if index is None : self . children . append ( child ) else : self . children . insert ( index , child ) return self # Return self for chaining! .add(x).add(y) def remove ( self , child ): if child in self . children : self . children . remove ( child ) if hasattr ( child , 'parent' ): child . parent = None return self def get_tree_depth ( self ): \"\"\"Helper to know how deep this node is.\"\"\" depth = 0 p = self . parent while p : depth += 1 p = p . parent return depth","title":"ElementNodeMixin"},{"location":"reference/probo/components/node/#probo.components.node.ElementNodeMixin.add","text":"Adds a child node. Handles parent linkage automatically. Source code in src\\probo\\components\\node.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 def add ( self , child , index = None ): \"\"\" Adds a child node. Handles parent linkage automatically. \"\"\" if child is None : return self # Link the child to this parent if hasattr ( child , 'parent' ): child . parent = self if index is None : self . children . append ( child ) else : self . children . insert ( index , child ) return self # Return self for chaining! .add(x).add(y)","title":"add"},{"location":"reference/probo/components/node/#probo.components.node.ElementNodeMixin.get_tree_depth","text":"Helper to know how deep this node is. Source code in src\\probo\\components\\node.py 35 36 37 38 39 40 41 42 def get_tree_depth ( self ): \"\"\"Helper to know how deep this node is.\"\"\" depth = 0 p = self . parent while p : depth += 1 p = p . parent return depth","title":"get_tree_depth"},{"location":"reference/probo/components/forms/probo_form/","text":"probo_form ProboForm The orchestrator for rendering HTML forms. Manages CSRF tokens, field iteration, and validation integration. This class acts as the bridge between Django's backend form handling (via RDT) and probo's frontend rendering. It supports both automatic rendering of Django forms and manual construction of forms for static sites or other frameworks. Parameters: action ( str ) \u2013 The URL to submit the form to (e.g., \"/login/\"). *form_field_declarations ( tuple [ ProboFormField ] , default: () ) \u2013 Variable length list of manual field declarations. request_data ( RequestDataTransformer , default: None ) \u2013 The RDT instance wrapping the Django request. Required for auto-magic mode. method ( str , default: None ) \u2013 HTTP method (e.g., \"post\", \"get\"). If None, defaults based on context. manual ( bool , default: False ) \u2013 If True, bypasses RDT and uses manually provided fields/tokens. Defaults to False. use_htmx ( bool , default: True ) \u2013 If True, prepares the form for HTMX injection. Defaults to True. form_class ( Any , default: None ) \u2013 The Django Form class (used for validation logic if RDT is present). form_declaration ( Optional [ str ] , default: None ) \u2013 Optional identifier or string representation for the form declaration. csrf_token ( str , default: None ) \u2013 Manual CSRF token string. Used if RDT is missing or in manual mode. Attributes: handler ( FormHandler ) \u2013 The business logic handler for saving/validating data. Example Django Mode (Auto) rdt = RequestDataTransformer(request, MyForm) form = ProboForm(action=\".\", request_data=rdt) html = form.render() Manual Mode email_field = ProboFormField(\"input\", 'email to contact with',Type=\"email\",value=\"\",name=\"email\",) form = ProboForm(\"/search\",email_field, method=\"get\", manual=True, csrf_token=\"xyz\") html = form.render() html -> email to contact with Source code in src\\probo\\components\\forms\\probo_form.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 class ProboForm : \"\"\" The orchestrator for rendering HTML forms. Manages CSRF tokens, field iteration, and validation integration. This class acts as the bridge between Django's backend form handling (via RDT) and probo's frontend rendering. It supports both automatic rendering of Django forms and manual construction of forms for static sites or other frameworks. Args: action (str): The URL to submit the form to (e.g., \"/login/\"). *form_field_declarations (tuple[ProboFormField]): Variable length list of manual field declarations. request_data (RequestDataTransformer, optional): The RDT instance wrapping the Django request. Required for auto-magic mode. method (str, optional): HTTP method (e.g., \"post\", \"get\"). If None, defaults based on context. manual (bool, optional): If True, bypasses RDT and uses manually provided fields/tokens. Defaults to False. use_htmx (bool, optional): If True, prepares the form for HTMX injection. Defaults to True. form_class (Any, optional): The Django Form class (used for validation logic if RDT is present). form_declaration (Optional[str], optional): Optional identifier or string representation for the form declaration. csrf_token (str, optional): Manual CSRF token string. Used if RDT is missing or in manual mode. Attributes: handler (FormHandler): The business logic handler for saving/validating data. Example: >>> # Django Mode (Auto) >>> rdt = RequestDataTransformer(request, MyForm) >>> form = ProboForm(action=\".\", request_data=rdt) >>> html = form.render() >>> # Manual Mode >>> email_field = ProboFormField(\"input\", 'email to contact with',Type=\"email\",value=\"\",name=\"email\",) >>> form = ProboForm(\"/search\",email_field, method=\"get\", manual=True, csrf_token=\"xyz\") >>> html = form.render() >>> html -> <form action=\"/search\" method=\"get\"><input type=\"hidden\" value=\"xyz\"/><label for=\"email\">email to contact with</label><input type=\"email\" name=\"email\" value=\"\"/> \"\"\" def __init__ ( self , action : str , * form_field_declarations : tuple [ ProboFormField ], request_data : Optional [ RequestDataTransformer ] = None , method : str = None , manual : bool = False , use_htmx : bool = True , form_class : Any = None , form_declaration : Optional [ str ] = None , override_button = False , override_button_attrs = None , csrf_token : str = None , ** attrs ): self . form_class = form_class self . request_data = request_data self . request_form_bool : bool = bool ( request_data ) self . is_handled = False self . use_htmx = use_htmx self . method = method if method else request_data . request_method if request_data else 'GET' self . action = action self . attrs = { 'action' : self . action , 'method' : self . method . lower (), 'enctype' : \"multipart/form-data\" , } self . attrs . update ( attrs ) self . override_button = override_button self . override_button_attrs = override_button_attrs self . handler = None self . is_valid = False self . form_declaration = form_declaration self . manual = manual self . submit_btn = None self . _manual_csrf = csrf_token self . fields = form_field_declarations if not manual and self . request_data : self . form_class = ( self . request_data . form_class if not self . form_class else self . form_class ) def get_csrf_token ( self ): if self . _manual_csrf : return self . _manual_csrf if self . request_data : return self . request_data . get_csrf_token () return \"\" def render ( self , ): token = self . get_csrf_token () csrf_field = Input ( type = \"hidden\" , name = \"csrfmiddlewaretoken\" , value = token ) fields_html = list ( self . fields ) if self . request_data and self . request_data . form : # Iterate over the Django Form Fields for field in self . request_data . form : # Wrap each Django field in MFF and render mff = ProboFormField ( dj_field = field ) fields_html . append ( mff . render ()) if self . form_declaration : fields_html . append ( self . form_declaration ) submit_btn = '' if not self . override_button : if self . override_button_attrs : submit_btn = button ( \"Submit\" , ** self . override_button_attrs ) else : submit_btn = button ( \"Submit\" , type = \"submit\" , Class = \"btn btn-lg\" ) return form ( csrf_field , * fields_html , submit_btn , ** self . attrs , # Safe default ) def save_to_db ( self , ): if self . request_form_bool : self . handler = FormHandler ( self . request_data ) self . is_handled = self . handler . form_handling () return self . is_handled ProboFormField A declarative renderer for individual form fields. Bridging Django BoundFields with probo Elements. This class handles the extraction of widget attributes (type, class, choices) from Django fields and renders them into semantic HTML using probo's functional tags. It supports both automatic extraction (from Django) and manual declaration (for static forms). Parameters: tag_name ( str , default: None ) \u2013 The HTML tag name (e.g., 'input', 'select', 'textarea'). field_label ( str , default: '' ) \u2013 The text label for the field. Defaults to \"\". content ( str , default: '' ) \u2013 Inner content for the element (used for textareas or custom containers). Defaults to \"\". dj_field ( BoundField , default: None ) \u2013 A Django BoundField object. If provided, attributes are extracted automatically. **attrs ( dict [ str , str ] , default: {} ) \u2013 Additional HTML attributes (e.g., id, class, placeholder, required). Attributes: info ( dict ) \u2013 The normalized dictionary containing tag type, attributes, value, and choices. Example Automatic (Django) mff = ProboFormField(dj_field=form['username']) Manual mff = ProboFormField( ... tag_name='input', ... type='email', ... name='email', ... field_label='Email Address' ... ) print(mff.render()) Email Address Source code in src\\probo\\components\\forms\\probo_form.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 class ProboFormField : \"\"\" A declarative renderer for individual form fields. Bridging Django BoundFields with probo Elements. This class handles the extraction of widget attributes (type, class, choices) from Django fields and renders them into semantic HTML using probo's functional tags. It supports both automatic extraction (from Django) and manual declaration (for static forms). Args: tag_name (str, optional): The HTML tag name (e.g., 'input', 'select', 'textarea'). field_label (str, optional): The text label for the field. Defaults to \"\". content (str, optional): Inner content for the element (used for textareas or custom containers). Defaults to \"\". dj_field (BoundField, optional): A Django BoundField object. If provided, attributes are extracted automatically. **attrs: Additional HTML attributes (e.g., id, class, placeholder, required). Attributes: info (dict): The normalized dictionary containing tag type, attributes, value, and choices. Example: >>> # Automatic (Django) >>> mff = ProboFormField(dj_field=form['username']) >>> >>> # Manual >>> mff = ProboFormField( ... tag_name='input', ... type='email', ... name='email', ... field_label='Email Address' ... ) >>> print(mff.render()) <label>Email Address</label><input type=\"email\" name=\"email\"/> \"\"\" def __init__ ( self , tag_name : str = None , field_label : str = \"\" , content : str = \"\" , label_attr : dict [ str , str ] = None , dj_field = None , wraper_func = None , ** attrs : dict [ str , str ], ): self . content = content self . wraper_func = wraper_func self . field_label = field_label self . attrs = attrs self . label_attr = label_attr or {} self . tag_name = tag_name self . widget_info : dict [ str , str ] = dict () self . form_field = str () self . dj_field = None self . dj_field_info = dict () self . dj_field = ( dj_field ,) if dj_field : self . include_dj_field ( dj_field ) if tag_name : info = self . _make_info ( self . attrs , self . field_label , { \"for\" : attrs . get ( \"id\" , None ), ** self . label_attr }, content ) self . _field_build ( tag_name , ** info ) def _make_info ( self , attrs : dict [ str , str ], label_string : str , label_attr : dict [ str , str ], content : str = None , ) -> dict [ str , str ]: return { \"attrs\" : { k . lower () . replace ( \"_\" , \"-\" ): v for k , v in attrs . items ()}, \"label_string\" : label_string , \"label_attr \" : label_attr , \"content\" : content , } def _field_build ( self , tag : str , ** info ): tag_info_dict = { \"input\" : { \"method\" : Input , \"void\" : True }, \"textarea\" : { \"method\" : textarea , \"void\" : False }, \"select\" : { \"method\" : select , \"void\" : False }, \"fieldset\" : { \"method\" : fieldset , \"void\" : False }, \"datalist\" : { \"method\" : datalist , \"void\" : False }, \"output\" : { \"method\" : output , \"void\" : False }, } valid_tag = tag in tag_info_dict if valid_tag : tag_method = tag_info_dict [ tag ][ \"method\" ] tag_void = tag_info_dict [ tag ][ \"void\" ] tag_content = info . get ( \"content\" , None ) tag_attrs = { x : y for x , y in info [ \"attrs\" ] . items ()} input_id = info [ \"attrs\" ] . get ( \"id\" , None ) label_string = info . get ( \"label_string\" , None ) tag_string = ( tag_method ( ** tag_attrs ) if tag_void else tag_method ( tag_content , ** tag_attrs ) ) if not label_string : self . widget_info [ f \" { input_id } - { tag } \" ] = self . wraper_func ( tag_string ) if callable ( self . wraper_func ) else tag_string else : label_attrs = info . get ( \"label_attrs\" , {}) or {} if not label_attrs and input_id : label_attrs [ \"for\" ] = input_id self . widget_info [ f \" { input_id } - { tag } \" ] = ( self . wraper_func ( label ( label_string , ** label_attrs ) + tag_string ) if callable ( self . wraper_func ) else label ( label_string , ** label_attrs ) + tag_string ) return self def include_dj_field ( self , dj_field ): if hasattr ( dj_field , \"field\" ) and hasattr ( dj_field . field , \"widget\" ): field_info = get_widget_info ( dj_field ) tag = field_info [ \"tag\" ] self . dj_field_info [ tag ] = field_info dj_attrs = self . dj_field_info [ tag ][ \"attrs\" ] dj_label = self . dj_field_info [ tag ][ \"label\" ] info = self . _make_info ( dj_attrs , dj_label , { \"for\" : dj_attrs . get ( \"id\" , None )}, ) self . _field_build ( tag , ** info ) else : raise ValueError ( \"MFF expects a Django Field or a Dict.\" ) self . dj_field = ( dj_field ,) return self def add_input ( self , label_string : str = None , label_attrs : dict [ str , str ] = None , ** input_attrs , ): \"\"\" <label for=\"xyz\">...</label> <input type=\"...\" id=\"xyz\" name=\"xyz\"> if \"\"\" info = self . _make_info ( input_attrs , label_string , label_attrs , ) return self . _field_build ( \"input\" , ** info ) def add_textarea ( self , textarea_content : str = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** textarea_attrs , ): _defaults = { \"textarea_rows\" : 8 , \"textarea_cols\" : 50 , } _defaults . update ( textarea_attrs ) info = self . _make_info ( _defaults , label_string , label_attrs , textarea_content ) return self . _field_build ( \"textarea\" , ** info ) def add_select_option ( self , option_values : list [ str ], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" content = \" \" . join ( [ option ( y , value = y , selected = True ) if x in selected_options_indexes else option ( y , value = y ) for x , y in enumerate ( option_values ) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info ) def add_select_optgroup ( self , optgroups : dict [ str , list [ str ]], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" optgroup_content = [] for x , y in enumerate ( optgroups . values ()): optgroup_content . append ( \"\" . join ( [ option ( v , value = v , selected = True ) if x in selected_options_indexes else option ( v , value = v ) for v in y ] ) ) content = \"\" . join ( [ optgroup ( k , ** { \"label\" : v }) for k , v in zip ( optgroup_content , optgroups . keys ()) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info ) def add_field_set ( self , legend_content : str , form_elements : list [ str ], label_string : str = None , label_attrs : str = None , ** fieldset_attrs , ): content = \"\" . join ([ legend ( legend_content ), * form_elements ]) info = self . _make_info ( fieldset_attrs , label_string , label_attrs , content ) return self . _field_build ( \"fieldset\" , ** info ) def add_data_list ( self , option_value_list : list [ str ], label_string : str = None , label_attrs : dict [ str , str ] = None , ** data_list_attrs , ): content = \"\" . join ([ option ( value = k ) for k in option_value_list ]) info = self . _make_info ( data_list_attrs , label_string , label_attrs , content ) return self . _field_build ( \"datalist\" , ** info ) def add_output ( self , label_string : str = None , label_attrs : dict [ str , str ] = None , ** output_attrs , ): info = self . _make_info ( output_attrs , label_string , label_attrs ) return self . _field_build ( \"output\" , ** info ) def add_custom_field ( self , * field_string , skip_wraper = False ): field_string = '' . join ( field_string ) if skip_wraper : self . widget_info [ 'custm-field' ] = field_string else : self . widget_info [ 'custm-field' ] = self . wraper_func ( field_string ) if callable ( self . wraper_func ) else field_string return self def render ( self , ) -> str : fields = \"\" if self . widget_info : fields = \"\" . join ( self . widget_info . values ()) state_error = { \"field_errors\" : \"\" , } if self . dj_field_info : tag = list ( self . dj_field_info . keys ())[ 0 ] if tag : err_list = [ div ( str ( e ), Class = \"invalid-feedback\" ) for e in self . dj_field_info [ tag ][ \"errors\" ] ] errors_html = div ( * err_list , Class = \"errors\" ) state_error = { \"field_errors\" : errors_html , } errors = ElementState ( \"div\" , s_state = \"field_errors\" ) error_string = ( errors . change_state ( state_error , ) . state_placeholder or str () ) self . form_field = fields + error_string return fields add_input ( label_string = None , label_attrs = None , ** input_attrs ) ... if Source code in src\\probo\\components\\forms\\probo_form.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def add_input ( self , label_string : str = None , label_attrs : dict [ str , str ] = None , ** input_attrs , ): \"\"\" <label for=\"xyz\">...</label> <input type=\"...\" id=\"xyz\" name=\"xyz\"> if \"\"\" info = self . _make_info ( input_attrs , label_string , label_attrs , ) return self . _field_build ( \"input\" , ** info ) add_select_optgroup ( optgroups , selected_options_indexes = None , label_string = None , label_attrs = None , ** select_attrs ) option Source code in src\\probo\\components\\forms\\probo_form.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def add_select_optgroup ( self , optgroups : dict [ str , list [ str ]], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" optgroup_content = [] for x , y in enumerate ( optgroups . values ()): optgroup_content . append ( \"\" . join ( [ option ( v , value = v , selected = True ) if x in selected_options_indexes else option ( v , value = v ) for v in y ] ) ) content = \"\" . join ( [ optgroup ( k , ** { \"label\" : v }) for k , v in zip ( optgroup_content , optgroups . keys ()) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info ) add_select_option ( option_values , selected_options_indexes = None , label_string = None , label_attrs = None , ** select_attrs ) option Source code in src\\probo\\components\\forms\\probo_form.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def add_select_option ( self , option_values : list [ str ], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" content = \" \" . join ( [ option ( y , value = y , selected = True ) if x in selected_options_indexes else option ( y , value = y ) for x , y in enumerate ( option_values ) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info ) get_widget_info ( django_bound_field ) Analyzes a Django BoundField and returns a clean dictionary of tag type, attributes, and values. Source code in src\\probo\\components\\forms\\probo_form.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def get_widget_info ( django_bound_field ) -> dict [ str , str ]: \"\"\" Analyzes a Django BoundField and returns a clean dictionary of tag type, attributes, and values. \"\"\" widget = django_bound_field . field . widget attrs = dict ( widget . attrs ) # 1. Base Attributes attrs [ \"name\" ] = django_bound_field . html_name attrs [ \"id\" ] = django_bound_field . id_for_label # 2. Value Handling val = django_bound_field . value () if val is not None : attrs [ \"value\" ] = val # 3. Required Handling if django_bound_field . field . required : attrs [ \"required\" ] = True # 4. Tag Determination logic tag = \"input\" choices = [] # Check for Select if getattr ( widget , \"allow_multiple_selected\" , None ) is not None : tag = \"select\" choices = getattr ( widget , \"choices\" , []) if widget . allow_multiple_selected : attrs [ \"multiple\" ] = True # Check for Textarea elif widget . __class__ . __name__ == \"Textarea\" : tag = \"textarea\" # Textarea content is value, not attribute if \"value\" in attrs : del attrs [ \"value\" ] # Check for Input Type elif hasattr ( widget , \"input_type\" ): attrs [ \"type\" ] = widget . input_type return { \"tag\" : tag , \"attrs\" : attrs , \"value\" : val , \"choices\" : choices , \"label\" : django_bound_field . label , \"errors\" : list ( django_bound_field . errors ), }","title":"probo_form"},{"location":"reference/probo/components/forms/probo_form/#probo_form","text":"","title":"probo_form"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboForm","text":"The orchestrator for rendering HTML forms. Manages CSRF tokens, field iteration, and validation integration. This class acts as the bridge between Django's backend form handling (via RDT) and probo's frontend rendering. It supports both automatic rendering of Django forms and manual construction of forms for static sites or other frameworks. Parameters: action ( str ) \u2013 The URL to submit the form to (e.g., \"/login/\"). *form_field_declarations ( tuple [ ProboFormField ] , default: () ) \u2013 Variable length list of manual field declarations. request_data ( RequestDataTransformer , default: None ) \u2013 The RDT instance wrapping the Django request. Required for auto-magic mode. method ( str , default: None ) \u2013 HTTP method (e.g., \"post\", \"get\"). If None, defaults based on context. manual ( bool , default: False ) \u2013 If True, bypasses RDT and uses manually provided fields/tokens. Defaults to False. use_htmx ( bool , default: True ) \u2013 If True, prepares the form for HTMX injection. Defaults to True. form_class ( Any , default: None ) \u2013 The Django Form class (used for validation logic if RDT is present). form_declaration ( Optional [ str ] , default: None ) \u2013 Optional identifier or string representation for the form declaration. csrf_token ( str , default: None ) \u2013 Manual CSRF token string. Used if RDT is missing or in manual mode. Attributes: handler ( FormHandler ) \u2013 The business logic handler for saving/validating data. Example","title":"ProboForm"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboForm--django-mode-auto","text":"rdt = RequestDataTransformer(request, MyForm) form = ProboForm(action=\".\", request_data=rdt) html = form.render()","title":"Django Mode (Auto)"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboForm--manual-mode","text":"email_field = ProboFormField(\"input\", 'email to contact with',Type=\"email\",value=\"\",name=\"email\",) form = ProboForm(\"/search\",email_field, method=\"get\", manual=True, csrf_token=\"xyz\") html = form.render() html -> email to contact with Source code in src\\probo\\components\\forms\\probo_form.py 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 class ProboForm : \"\"\" The orchestrator for rendering HTML forms. Manages CSRF tokens, field iteration, and validation integration. This class acts as the bridge between Django's backend form handling (via RDT) and probo's frontend rendering. It supports both automatic rendering of Django forms and manual construction of forms for static sites or other frameworks. Args: action (str): The URL to submit the form to (e.g., \"/login/\"). *form_field_declarations (tuple[ProboFormField]): Variable length list of manual field declarations. request_data (RequestDataTransformer, optional): The RDT instance wrapping the Django request. Required for auto-magic mode. method (str, optional): HTTP method (e.g., \"post\", \"get\"). If None, defaults based on context. manual (bool, optional): If True, bypasses RDT and uses manually provided fields/tokens. Defaults to False. use_htmx (bool, optional): If True, prepares the form for HTMX injection. Defaults to True. form_class (Any, optional): The Django Form class (used for validation logic if RDT is present). form_declaration (Optional[str], optional): Optional identifier or string representation for the form declaration. csrf_token (str, optional): Manual CSRF token string. Used if RDT is missing or in manual mode. Attributes: handler (FormHandler): The business logic handler for saving/validating data. Example: >>> # Django Mode (Auto) >>> rdt = RequestDataTransformer(request, MyForm) >>> form = ProboForm(action=\".\", request_data=rdt) >>> html = form.render() >>> # Manual Mode >>> email_field = ProboFormField(\"input\", 'email to contact with',Type=\"email\",value=\"\",name=\"email\",) >>> form = ProboForm(\"/search\",email_field, method=\"get\", manual=True, csrf_token=\"xyz\") >>> html = form.render() >>> html -> <form action=\"/search\" method=\"get\"><input type=\"hidden\" value=\"xyz\"/><label for=\"email\">email to contact with</label><input type=\"email\" name=\"email\" value=\"\"/> \"\"\" def __init__ ( self , action : str , * form_field_declarations : tuple [ ProboFormField ], request_data : Optional [ RequestDataTransformer ] = None , method : str = None , manual : bool = False , use_htmx : bool = True , form_class : Any = None , form_declaration : Optional [ str ] = None , override_button = False , override_button_attrs = None , csrf_token : str = None , ** attrs ): self . form_class = form_class self . request_data = request_data self . request_form_bool : bool = bool ( request_data ) self . is_handled = False self . use_htmx = use_htmx self . method = method if method else request_data . request_method if request_data else 'GET' self . action = action self . attrs = { 'action' : self . action , 'method' : self . method . lower (), 'enctype' : \"multipart/form-data\" , } self . attrs . update ( attrs ) self . override_button = override_button self . override_button_attrs = override_button_attrs self . handler = None self . is_valid = False self . form_declaration = form_declaration self . manual = manual self . submit_btn = None self . _manual_csrf = csrf_token self . fields = form_field_declarations if not manual and self . request_data : self . form_class = ( self . request_data . form_class if not self . form_class else self . form_class ) def get_csrf_token ( self ): if self . _manual_csrf : return self . _manual_csrf if self . request_data : return self . request_data . get_csrf_token () return \"\" def render ( self , ): token = self . get_csrf_token () csrf_field = Input ( type = \"hidden\" , name = \"csrfmiddlewaretoken\" , value = token ) fields_html = list ( self . fields ) if self . request_data and self . request_data . form : # Iterate over the Django Form Fields for field in self . request_data . form : # Wrap each Django field in MFF and render mff = ProboFormField ( dj_field = field ) fields_html . append ( mff . render ()) if self . form_declaration : fields_html . append ( self . form_declaration ) submit_btn = '' if not self . override_button : if self . override_button_attrs : submit_btn = button ( \"Submit\" , ** self . override_button_attrs ) else : submit_btn = button ( \"Submit\" , type = \"submit\" , Class = \"btn btn-lg\" ) return form ( csrf_field , * fields_html , submit_btn , ** self . attrs , # Safe default ) def save_to_db ( self , ): if self . request_form_bool : self . handler = FormHandler ( self . request_data ) self . is_handled = self . handler . form_handling () return self . is_handled","title":"Manual Mode"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboFormField","text":"A declarative renderer for individual form fields. Bridging Django BoundFields with probo Elements. This class handles the extraction of widget attributes (type, class, choices) from Django fields and renders them into semantic HTML using probo's functional tags. It supports both automatic extraction (from Django) and manual declaration (for static forms). Parameters: tag_name ( str , default: None ) \u2013 The HTML tag name (e.g., 'input', 'select', 'textarea'). field_label ( str , default: '' ) \u2013 The text label for the field. Defaults to \"\". content ( str , default: '' ) \u2013 Inner content for the element (used for textareas or custom containers). Defaults to \"\". dj_field ( BoundField , default: None ) \u2013 A Django BoundField object. If provided, attributes are extracted automatically. **attrs ( dict [ str , str ] , default: {} ) \u2013 Additional HTML attributes (e.g., id, class, placeholder, required). Attributes: info ( dict ) \u2013 The normalized dictionary containing tag type, attributes, value, and choices. Example","title":"ProboFormField"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboFormField--automatic-django","text":"mff = ProboFormField(dj_field=form['username'])","title":"Automatic (Django)"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboFormField--manual","text":"mff = ProboFormField( ... tag_name='input', ... type='email', ... name='email', ... field_label='Email Address' ... ) print(mff.render()) Email Address Source code in src\\probo\\components\\forms\\probo_form.py 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 class ProboFormField : \"\"\" A declarative renderer for individual form fields. Bridging Django BoundFields with probo Elements. This class handles the extraction of widget attributes (type, class, choices) from Django fields and renders them into semantic HTML using probo's functional tags. It supports both automatic extraction (from Django) and manual declaration (for static forms). Args: tag_name (str, optional): The HTML tag name (e.g., 'input', 'select', 'textarea'). field_label (str, optional): The text label for the field. Defaults to \"\". content (str, optional): Inner content for the element (used for textareas or custom containers). Defaults to \"\". dj_field (BoundField, optional): A Django BoundField object. If provided, attributes are extracted automatically. **attrs: Additional HTML attributes (e.g., id, class, placeholder, required). Attributes: info (dict): The normalized dictionary containing tag type, attributes, value, and choices. Example: >>> # Automatic (Django) >>> mff = ProboFormField(dj_field=form['username']) >>> >>> # Manual >>> mff = ProboFormField( ... tag_name='input', ... type='email', ... name='email', ... field_label='Email Address' ... ) >>> print(mff.render()) <label>Email Address</label><input type=\"email\" name=\"email\"/> \"\"\" def __init__ ( self , tag_name : str = None , field_label : str = \"\" , content : str = \"\" , label_attr : dict [ str , str ] = None , dj_field = None , wraper_func = None , ** attrs : dict [ str , str ], ): self . content = content self . wraper_func = wraper_func self . field_label = field_label self . attrs = attrs self . label_attr = label_attr or {} self . tag_name = tag_name self . widget_info : dict [ str , str ] = dict () self . form_field = str () self . dj_field = None self . dj_field_info = dict () self . dj_field = ( dj_field ,) if dj_field : self . include_dj_field ( dj_field ) if tag_name : info = self . _make_info ( self . attrs , self . field_label , { \"for\" : attrs . get ( \"id\" , None ), ** self . label_attr }, content ) self . _field_build ( tag_name , ** info ) def _make_info ( self , attrs : dict [ str , str ], label_string : str , label_attr : dict [ str , str ], content : str = None , ) -> dict [ str , str ]: return { \"attrs\" : { k . lower () . replace ( \"_\" , \"-\" ): v for k , v in attrs . items ()}, \"label_string\" : label_string , \"label_attr \" : label_attr , \"content\" : content , } def _field_build ( self , tag : str , ** info ): tag_info_dict = { \"input\" : { \"method\" : Input , \"void\" : True }, \"textarea\" : { \"method\" : textarea , \"void\" : False }, \"select\" : { \"method\" : select , \"void\" : False }, \"fieldset\" : { \"method\" : fieldset , \"void\" : False }, \"datalist\" : { \"method\" : datalist , \"void\" : False }, \"output\" : { \"method\" : output , \"void\" : False }, } valid_tag = tag in tag_info_dict if valid_tag : tag_method = tag_info_dict [ tag ][ \"method\" ] tag_void = tag_info_dict [ tag ][ \"void\" ] tag_content = info . get ( \"content\" , None ) tag_attrs = { x : y for x , y in info [ \"attrs\" ] . items ()} input_id = info [ \"attrs\" ] . get ( \"id\" , None ) label_string = info . get ( \"label_string\" , None ) tag_string = ( tag_method ( ** tag_attrs ) if tag_void else tag_method ( tag_content , ** tag_attrs ) ) if not label_string : self . widget_info [ f \" { input_id } - { tag } \" ] = self . wraper_func ( tag_string ) if callable ( self . wraper_func ) else tag_string else : label_attrs = info . get ( \"label_attrs\" , {}) or {} if not label_attrs and input_id : label_attrs [ \"for\" ] = input_id self . widget_info [ f \" { input_id } - { tag } \" ] = ( self . wraper_func ( label ( label_string , ** label_attrs ) + tag_string ) if callable ( self . wraper_func ) else label ( label_string , ** label_attrs ) + tag_string ) return self def include_dj_field ( self , dj_field ): if hasattr ( dj_field , \"field\" ) and hasattr ( dj_field . field , \"widget\" ): field_info = get_widget_info ( dj_field ) tag = field_info [ \"tag\" ] self . dj_field_info [ tag ] = field_info dj_attrs = self . dj_field_info [ tag ][ \"attrs\" ] dj_label = self . dj_field_info [ tag ][ \"label\" ] info = self . _make_info ( dj_attrs , dj_label , { \"for\" : dj_attrs . get ( \"id\" , None )}, ) self . _field_build ( tag , ** info ) else : raise ValueError ( \"MFF expects a Django Field or a Dict.\" ) self . dj_field = ( dj_field ,) return self def add_input ( self , label_string : str = None , label_attrs : dict [ str , str ] = None , ** input_attrs , ): \"\"\" <label for=\"xyz\">...</label> <input type=\"...\" id=\"xyz\" name=\"xyz\"> if \"\"\" info = self . _make_info ( input_attrs , label_string , label_attrs , ) return self . _field_build ( \"input\" , ** info ) def add_textarea ( self , textarea_content : str = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** textarea_attrs , ): _defaults = { \"textarea_rows\" : 8 , \"textarea_cols\" : 50 , } _defaults . update ( textarea_attrs ) info = self . _make_info ( _defaults , label_string , label_attrs , textarea_content ) return self . _field_build ( \"textarea\" , ** info ) def add_select_option ( self , option_values : list [ str ], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" content = \" \" . join ( [ option ( y , value = y , selected = True ) if x in selected_options_indexes else option ( y , value = y ) for x , y in enumerate ( option_values ) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info ) def add_select_optgroup ( self , optgroups : dict [ str , list [ str ]], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" optgroup_content = [] for x , y in enumerate ( optgroups . values ()): optgroup_content . append ( \"\" . join ( [ option ( v , value = v , selected = True ) if x in selected_options_indexes else option ( v , value = v ) for v in y ] ) ) content = \"\" . join ( [ optgroup ( k , ** { \"label\" : v }) for k , v in zip ( optgroup_content , optgroups . keys ()) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info ) def add_field_set ( self , legend_content : str , form_elements : list [ str ], label_string : str = None , label_attrs : str = None , ** fieldset_attrs , ): content = \"\" . join ([ legend ( legend_content ), * form_elements ]) info = self . _make_info ( fieldset_attrs , label_string , label_attrs , content ) return self . _field_build ( \"fieldset\" , ** info ) def add_data_list ( self , option_value_list : list [ str ], label_string : str = None , label_attrs : dict [ str , str ] = None , ** data_list_attrs , ): content = \"\" . join ([ option ( value = k ) for k in option_value_list ]) info = self . _make_info ( data_list_attrs , label_string , label_attrs , content ) return self . _field_build ( \"datalist\" , ** info ) def add_output ( self , label_string : str = None , label_attrs : dict [ str , str ] = None , ** output_attrs , ): info = self . _make_info ( output_attrs , label_string , label_attrs ) return self . _field_build ( \"output\" , ** info ) def add_custom_field ( self , * field_string , skip_wraper = False ): field_string = '' . join ( field_string ) if skip_wraper : self . widget_info [ 'custm-field' ] = field_string else : self . widget_info [ 'custm-field' ] = self . wraper_func ( field_string ) if callable ( self . wraper_func ) else field_string return self def render ( self , ) -> str : fields = \"\" if self . widget_info : fields = \"\" . join ( self . widget_info . values ()) state_error = { \"field_errors\" : \"\" , } if self . dj_field_info : tag = list ( self . dj_field_info . keys ())[ 0 ] if tag : err_list = [ div ( str ( e ), Class = \"invalid-feedback\" ) for e in self . dj_field_info [ tag ][ \"errors\" ] ] errors_html = div ( * err_list , Class = \"errors\" ) state_error = { \"field_errors\" : errors_html , } errors = ElementState ( \"div\" , s_state = \"field_errors\" ) error_string = ( errors . change_state ( state_error , ) . state_placeholder or str () ) self . form_field = fields + error_string return fields","title":"Manual"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboFormField.add_input","text":"... if Source code in src\\probo\\components\\forms\\probo_form.py 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 def add_input ( self , label_string : str = None , label_attrs : dict [ str , str ] = None , ** input_attrs , ): \"\"\" <label for=\"xyz\">...</label> <input type=\"...\" id=\"xyz\" name=\"xyz\"> if \"\"\" info = self . _make_info ( input_attrs , label_string , label_attrs , ) return self . _field_build ( \"input\" , ** info )","title":"add_input"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboFormField.add_select_optgroup","text":"option Source code in src\\probo\\components\\forms\\probo_form.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 def add_select_optgroup ( self , optgroups : dict [ str , list [ str ]], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" optgroup_content = [] for x , y in enumerate ( optgroups . values ()): optgroup_content . append ( \"\" . join ( [ option ( v , value = v , selected = True ) if x in selected_options_indexes else option ( v , value = v ) for v in y ] ) ) content = \"\" . join ( [ optgroup ( k , ** { \"label\" : v }) for k , v in zip ( optgroup_content , optgroups . keys ()) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info )","title":"add_select_optgroup"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.ProboFormField.add_select_option","text":"option Source code in src\\probo\\components\\forms\\probo_form.py 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 def add_select_option ( self , option_values : list [ str ], selected_options_indexes : list [ int ] = None , label_string : str = None , label_attrs : dict [ str , str ] = None , ** select_attrs , ): \"\"\"option\"\"\" content = \" \" . join ( [ option ( y , value = y , selected = True ) if x in selected_options_indexes else option ( y , value = y ) for x , y in enumerate ( option_values ) ] ) info = self . _make_info ( select_attrs , label_string , label_attrs , content ) return self . _field_build ( \"select\" , ** info )","title":"add_select_option"},{"location":"reference/probo/components/forms/probo_form/#probo.components.forms.probo_form.get_widget_info","text":"Analyzes a Django BoundField and returns a clean dictionary of tag type, attributes, and values. Source code in src\\probo\\components\\forms\\probo_form.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def get_widget_info ( django_bound_field ) -> dict [ str , str ]: \"\"\" Analyzes a Django BoundField and returns a clean dictionary of tag type, attributes, and values. \"\"\" widget = django_bound_field . field . widget attrs = dict ( widget . attrs ) # 1. Base Attributes attrs [ \"name\" ] = django_bound_field . html_name attrs [ \"id\" ] = django_bound_field . id_for_label # 2. Value Handling val = django_bound_field . value () if val is not None : attrs [ \"value\" ] = val # 3. Required Handling if django_bound_field . field . required : attrs [ \"required\" ] = True # 4. Tag Determination logic tag = \"input\" choices = [] # Check for Select if getattr ( widget , \"allow_multiple_selected\" , None ) is not None : tag = \"select\" choices = getattr ( widget , \"choices\" , []) if widget . allow_multiple_selected : attrs [ \"multiple\" ] = True # Check for Textarea elif widget . __class__ . __name__ == \"Textarea\" : tag = \"textarea\" # Textarea content is value, not attribute if \"value\" in attrs : del attrs [ \"value\" ] # Check for Input Type elif hasattr ( widget , \"input_type\" ): attrs [ \"type\" ] = widget . input_type return { \"tag\" : tag , \"attrs\" : attrs , \"value\" : val , \"choices\" : choices , \"label\" : django_bound_field . label , \"errors\" : list ( django_bound_field . errors ), }","title":"get_widget_info"},{"location":"reference/probo/components/state/component_state/","text":"component_state ComponentState The 'Brain' of the component system. Manages data storage (static/dynamic), logic gates (props), and data distribution to elements. It acts as a container for data and a controller for the rendering lifecycle. It resolves which data source (static vs dynamic) to use for each element and enforces security requirements via props validation. Parameters: s_data ( dict [ str , Any ] , default: None ) \u2013 Static data dictionary (defaults/fallbacks). d_data ( dict [ str , Any ] , default: None ) \u2013 Dynamic data dictionary (live data). Defaults to None. *elements_states ( tuple [ ElementState ] , default: () ) \u2013 Variable list of child ElementState objects managed by this state. incoming_props ( dict [ str , Any ] , default: None ) \u2013 Global context/props passed from the parent/view. Defaults to None. strict ( bool , default: False ) \u2013 If True, raises errors when required data keys are missing. Defaults to False. **props ( dict [ str , Any ] , default: {} ) \u2013 Local property requirements (e.g., requirement check against incoming_props). Attributes: resolved_state_elements ( dict ) \u2013 Map of state_id to resolved ElementState after processing. state_errors ( str ) \u2013 Error message if validation fails. Example Define elements es = ElementState('h1', s_state='title') Define State state = ComponentState( ... {'title': 'Hello World'}, ... {'title': 'Live Update'}, # d_data takes precedence ... es, ... strict=True ... ) ... print(state.resolve_template(es.placeholder)) Live Update Source code in src\\probo\\components\\state\\component_state.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 class ComponentState : \"\"\" The 'Brain' of the component system. Manages data storage (static/dynamic), logic gates (props), and data distribution to elements. It acts as a container for data and a controller for the rendering lifecycle. It resolves which data source (static vs dynamic) to use for each element and enforces security requirements via props validation. Args: s_data (dict[str, Any]): Static data dictionary (defaults/fallbacks). d_data (dict[str, Any], optional): Dynamic data dictionary (live data). Defaults to None. *elements_states (tuple[ElementState]): Variable list of child ElementState objects managed by this state. incoming_props (dict[str, Any], optional): Global context/props passed from the parent/view. Defaults to None. strict (bool, optional): If True, raises errors when required data keys are missing. Defaults to False. **props (dict[str, Any]): Local property requirements (e.g., requirement check against incoming_props). Attributes: resolved_state_elements (dict): Map of state_id to resolved ElementState after processing. state_errors (str): Error message if validation fails. Example: >>> # Define elements >>> es = ElementState('h1', s_state='title') >>> >>> # Define State >>> state = ComponentState( ... {'title': 'Hello World'}, ... {'title': 'Live Update'}, # d_data takes precedence ... es, ... strict=True ... ) ... print(state.resolve_template(es.placeholder)) <h1>Live Update</h1> \"\"\" def __init__ ( self , * elements_states : tuple [ \"ElementState\" ], s_data : dict [ str , Any ] = None , d_data : dict [ str , Any ] = None , incoming_props : dict [ str , Any ] = None , strict : bool = False , ** props : dict [ str , Any ], ) -> None : self . s_data = s_data or {} self . d_data = d_data or {} self . elements_states = elements_states self . resolved_state_elements = {} self . props = props self . strict = strict self . state_errors = None self . incoming_props = incoming_props or {} self . _should_render = True if elements_states : self . use_state () def _determine_state ( self , s_el , d_el ) -> tuple [ dict [ str , str ]]: \"\"\" generator from data available \"\"\" s_value = self . s_data . get ( s_el , None ) d_value = self . d_data . get ( d_el , None ) if self . strict : if not d_value and not s_value : raise KeyError ( \"[probo Strict] key missing in d_data (and no static fallback).\" ) return { s_el : s_value }, { d_el : d_value } def resolve_props ( self , prop : tuple [ dict [ str , str ]]) -> dict [ str , Any ] | None : \"\"\"Decides priority: Dynamic > Static.\"\"\" static_dict , dynamic_dict = prop s_val = list ( static_dict . values ())[ 0 ] d_val = list ( dynamic_dict . values ())[ 0 ] if d_val is not None and d_val : return dynamic_dict elif s_val is not None and s_val : return static_dict else : return None def validate_global_props ( self ) -> bool : \"\"\" Checks if local requirements (self.props) match the global context (incoming_props). Returns True if valid, False if mismatch found. \"\"\" self . _should_render = True if not self . props : return True # No requirements, always valid if not self . props and not self . incoming_props : return True # No requirements, always valid if not self . incoming_props : # Requirements exist, but no global props provided -> Fail self . state_errors = \"Missing Global Context\" if self . strict : raise ValueError ( f \"[probo Strict] { self . state_errors } \" ) return False for key , required_value in self . props . items (): # 1. Check Existence if key not in self . incoming_props : self . state_errors = f \"Missing required prop: ' { key } '\" if self . strict : raise ValueError ( f \"[probo Strict] { self . state_errors } \" ) return False # 2. Check Value Match # We assume strict equality here. You can relax this if needed. if self . incoming_props [ key ] != required_value : self . state_errors = ( f \"Prop Mismatch for ' { key } ': \" f \"Expected ' { required_value } ', got ' { self . incoming_props [ key ] } '\" ) return False return True def use_state ( self , ) -> Self : \"\"\" Replace <$ s=\"...\" d='None' i='None'>...</$> in children content with dynamic slot content \"\"\" props_check = self . validate_global_props () if not props_check : if self . strict : raise ValueError ( f \"[probo Strict]\u26a0\ufe0f Rendering Blocked: { self . state_errors } \" ) else : self . _should_render = False return self for el in self . elements_states : data = self . _determine_state ( el . s_state , el . d_state ) rsolved_data = self . resolve_props ( data ) if rsolved_data : resolved_el = el . change_state ( rsolved_data , props = self . incoming_props ) self . resolved_state_elements [ el . state_id ] = resolved_el else : self . resolved_state_elements [ el . state_id ] = el return self def remove_state_tag ( self , markup : str ) -> str : \"\"\" Removes all <$ ... > ... </$> state tags and keeps everything else intact. \"\"\" pattern = r \"<\\$\\s[^>]*>(.*?)</\\$>\" return re . sub ( pattern , r \"\\1\" , markup , flags = re . DOTALL ) def resolved_template ( self , template : str ) -> str : self . use_state () if hasattr ( template , 'render' ): template = template . render () if not self . _should_render : return str () if self . resolved_state_elements : for k , el in self . resolved_state_elements . items (): if el . placeholder in template : if el . state_placeholder is None or self . state_errors : # template = template.replace(el.placeholder, '') template = re . sub ( re . escape ( el . placeholder ), \"\" , template ) else : # template = template.replace(el.placeholder, el.state_placeholder) template = re . sub ( re . escape ( el . placeholder ), el . state_placeholder , template ) return self . remove_state_tag ( template ) remove_state_tag ( markup ) Removes all <$ ... > ... </$> state tags and keeps everything else intact. Source code in src\\probo\\components\\state\\component_state.py 152 153 154 155 156 157 def remove_state_tag ( self , markup : str ) -> str : \"\"\" Removes all <$ ... > ... </$> state tags and keeps everything else intact. \"\"\" pattern = r \"<\\$\\s[^>]*>(.*?)</\\$>\" return re . sub ( pattern , r \"\\1\" , markup , flags = re . DOTALL ) resolve_props ( prop ) Decides priority: Dynamic > Static. Source code in src\\probo\\components\\state\\component_state.py 78 79 80 81 82 83 84 85 86 87 88 def resolve_props ( self , prop : tuple [ dict [ str , str ]]) -> dict [ str , Any ] | None : \"\"\"Decides priority: Dynamic > Static.\"\"\" static_dict , dynamic_dict = prop s_val = list ( static_dict . values ())[ 0 ] d_val = list ( dynamic_dict . values ())[ 0 ] if d_val is not None and d_val : return dynamic_dict elif s_val is not None and s_val : return static_dict else : return None use_state () Replace <$ s=\"...\" d='None' i='None'>...</$> in children content with dynamic slot content Source code in src\\probo\\components\\state\\component_state.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def use_state ( self , ) -> Self : \"\"\" Replace <$ s=\"...\" d='None' i='None'>...</$> in children content with dynamic slot content \"\"\" props_check = self . validate_global_props () if not props_check : if self . strict : raise ValueError ( f \"[probo Strict]\u26a0\ufe0f Rendering Blocked: { self . state_errors } \" ) else : self . _should_render = False return self for el in self . elements_states : data = self . _determine_state ( el . s_state , el . d_state ) rsolved_data = self . resolve_props ( data ) if rsolved_data : resolved_el = el . change_state ( rsolved_data , props = self . incoming_props ) self . resolved_state_elements [ el . state_id ] = resolved_el else : self . resolved_state_elements [ el . state_id ] = el return self validate_global_props () Checks if local requirements (self.props) match the global context (incoming_props). Returns True if valid, False if mismatch found. Source code in src\\probo\\components\\state\\component_state.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def validate_global_props ( self ) -> bool : \"\"\" Checks if local requirements (self.props) match the global context (incoming_props). Returns True if valid, False if mismatch found. \"\"\" self . _should_render = True if not self . props : return True # No requirements, always valid if not self . props and not self . incoming_props : return True # No requirements, always valid if not self . incoming_props : # Requirements exist, but no global props provided -> Fail self . state_errors = \"Missing Global Context\" if self . strict : raise ValueError ( f \"[probo Strict] { self . state_errors } \" ) return False for key , required_value in self . props . items (): # 1. Check Existence if key not in self . incoming_props : self . state_errors = f \"Missing required prop: ' { key } '\" if self . strict : raise ValueError ( f \"[probo Strict] { self . state_errors } \" ) return False # 2. Check Value Match # We assume strict equality here. You can relax this if needed. if self . incoming_props [ key ] != required_value : self . state_errors = ( f \"Prop Mismatch for ' { key } ': \" f \"Expected ' { required_value } ', got ' { self . incoming_props [ key ] } '\" ) return False return True ElementState The 'Neuron' of the system. Defines how a specific HTML element binds to data and behaves under different conditions. It handles data resolution (choosing between static/dynamic sources), attribute binding (injecting data into attributes like 'href'), and logic gates (hiding if requirements aren't met). Parameters: element ( str ) \u2013 The HTML tag name (e.g., 'div', 'span'). s_state ( str , default: str () ) \u2013 Key to look up in s_data. Defaults to \"\". d_state ( str , default: None ) \u2013 Key to look up in d_data. Defaults to None. c_state ( str , default: str () ) \u2013 Constant content or fallback key. Defaults to \"\" (used when binding). is_custom ( bool , default: False ) \u2013 If True, bypasses standard HTML attribute validation. Defaults to False. props ( StateProps , default: None ) \u2013 Logic gate rules for visibility. Defaults to None. bind_to ( str , default: None ) \u2013 HTML attribute to inject resolved data into (e.g., 'src', 'href'). Defaults to None. inner_html ( Callable , default: None ) \u2013 A function defined by user to define inner html thus passing the data before rendering. Defaults to None. i_state ( bool , default: False ) \u2013 If True, treats resolved data as iterable and renders a list. Defaults to False. hide_dynamic ( bool , default: False ) \u2013 If True and d_state is missing, hides the element completely. Defaults to False. is_void_element ( bool , default: False ) \u2013 If True, renders as a self-closing tag. Defaults to False. **attrs \u2013 Static HTML attributes for the element (e.g., Class='btn'). Attributes: placeholder ( str ) \u2013 The unique <$ ... $> string used in templates. state_id ( str ) \u2013 Unique UUID for this element state. Example:print >>> # Simple text binding >>> es = ElementState('span', d_state='username') >>> >>> # Attribute binding >>> es_link = ElementState('a', d_state='url', bind_to='href', c_state='Click Me') >>> >>> # List rendering >>> es_list = ElementState('li', d_state='items', i_state=True) Source code in src\\probo\\components\\state\\component_state.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 class ElementState : \"\"\" The 'Neuron' of the system. Defines how a specific HTML element binds to data and behaves under different conditions. It handles data resolution (choosing between static/dynamic sources), attribute binding (injecting data into attributes like 'href'), and logic gates (hiding if requirements aren't met). Args: element (str): The HTML tag name (e.g., 'div', 'span'). s_state (str, optional): Key to look up in s_data. Defaults to \"\". d_state (str, optional): Key to look up in d_data. Defaults to None. c_state (str, optional): Constant content or fallback key. Defaults to \"\" (used when binding). is_custom (bool, optional): If True, bypasses standard HTML attribute validation. Defaults to False. props (StateProps, optional): Logic gate rules for visibility. Defaults to None. bind_to (str, optional): HTML attribute to inject resolved data into (e.g., 'src', 'href'). Defaults to None. inner_html (Callable, optional): A function defined by user to define inner html thus passing the data before rendering. Defaults to None. i_state (bool, optional): If True, treats resolved data as iterable and renders a list. Defaults to False. hide_dynamic (bool, optional): If True and d_state is missing, hides the element completely. Defaults to False. is_void_element (bool, optional): If True, renders as a self-closing tag. Defaults to False. **attrs: Static HTML attributes for the element (e.g., Class='btn'). Attributes: placeholder (str): The unique <$ ... $> string used in templates. state_id (str): Unique UUID for this element state. Example:print >>> # Simple text binding >>> es = ElementState('span', d_state='username') >>> >>> # Attribute binding >>> es_link = ElementState('a', d_state='url', bind_to='href', c_state='Click Me') >>> >>> # List rendering >>> es_list = ElementState('li', d_state='items', i_state=True) \"\"\" def __init__ ( self , element , s_state : str = str (), d_state : str = None , c_state = str (), is_custom = False , props : StateProps = None , bind_to = None , inner_html = None , i_state = False , hide_dynamic = False , is_void_element : bool = False , key_as_content = False , ** attrs , ): import uuid self . state_id = f \" { element } == { uuid . uuid4 () . hex } \" self . placeholder = ( Element () . custom_element ( \"$\" , content = Element () . custom_element ( element , str ( s_state ), is_void_element , ** attrs ) . element , s = s_state , d = d_state , c = c_state , i = bool ( i_state ), ) . element ) # <$ s=\"...\" d='None' i='None'>...</$> self . state_placeholder = None self . element = element self . s_state = s_state self . d_state = d_state self . c_state = c_state if c_state else None self . i_state = bool ( i_state ) self . attrs = ( { k . lower () . replace ( \"_\" , \"-\" ): v for k , v in attrs . items ()} if attrs else {} ) self . props = props or StateProps () self . props . element_state_id = self . state_id self . is_void_element = is_void_element self . hide_dynamic = hide_dynamic self . bind_to = bind_to self . is_custom = is_custom self . key_as_content = key_as_content self . inner_html = ( inner_html if callable ( inner_html ) else lambda x : str ( x ) if not isinstance ( x , tuple ) else str ( x [ 1 ]) ) if not self . is_custom : # Check if static attrs passed in __init__ are valid self . valid_element = ElementAttributeValidator ( f \"< { self . element } >\" , ** self . attrs ) . is_valid else : self . valid_element = True def change_state ( self , data : dict [ str , str ], props = dict ()): if not self . props . validator ( props ) . is_valid () or not self . valid_element : self . state_placeholder = None else : if not self . is_void_element : if self . bind_to and ( not self . c_state or self . bind_to not in self . attrs ): self . state_placeholder = None else : if self . key_as_content and not data : key = self . d_state if self . d_state else self . s_state print ( key ) if not key : self . state_placeholder = None if self . i_state : self . state_placeholder = \"\" . join ( [ Element () . custom_element ( self . element , self . inner_html ( d ), ** self . attrs ) . element for d in enumerate ( key ) ] ) else : self . state_placeholder = Element () . custom_element ( self . element , self . inner_html ( key ), ** self . attrs ) . element else : if self . hide_dynamic and self . d_state and self . d_state not in data : self . state_placeholder = None elif self . d_state and self . d_state in data : if self . i_state : self . state_placeholder = \"\" . join ( [ Element () . custom_element ( self . element , self . inner_html ( d ), ** self . attrs ) . element for d in enumerate ( data . get ( self . d_state )) ] ) else : self . state_placeholder = ( Element () . custom_element ( self . element , self . inner_html ( self . c_state ), ** self . bind_data_to ( str ( data . get ( self . d_state ))), ) . element if self . bind_to else Element () . custom_element ( self . element , self . inner_html ( data . get ( self . d_state )), ** self . attrs , ) . element ) elif self . s_state in data : if self . i_state : self . state_placeholder = \"\" . join ( [ Element () . custom_element ( self . element , self . inner_html ( s ), ** self . attrs ) . element for s in enumerate ( data . get ( self . s_state )) ] ) else : self . state_placeholder = ( Element () . custom_element ( self . element , self . inner_html ( self . c_state ), ** self . bind_data_to ( str ( data . get ( self . s_state ))), ) . element if self . bind_to else Element () . custom_element ( self . element , self . inner_html ( data . get ( self . s_state )), ** self . attrs , ) . element ) else : self . state_placeholder = None else : target_value = data . get ( self . s_state ) or data . get ( self . d_state ) self . state_placeholder = ( Element () . custom_element ( self . element , ** self . bind_data_to ( str ( target_value )) ) . element if self . bind_to else Element () . custom_element ( self . element , is_void_element = self . is_void_element , ** self . attrs ) . element ) return self def bind_data_to ( self , target_value ): if self . bind_to is None : return self . attrs else : if self . bind_to in self . attrs : render_attrs = self . attrs . copy () render_attrs [ self . bind_to ] = target_value return render_attrs return self . attrs def render ( self , ** data ) -> str | None : return self . change_state ( data ) . state_placeholder","title":"component_state"},{"location":"reference/probo/components/state/component_state/#component_state","text":"","title":"component_state"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState","text":"The 'Brain' of the component system. Manages data storage (static/dynamic), logic gates (props), and data distribution to elements. It acts as a container for data and a controller for the rendering lifecycle. It resolves which data source (static vs dynamic) to use for each element and enforces security requirements via props validation. Parameters: s_data ( dict [ str , Any ] , default: None ) \u2013 Static data dictionary (defaults/fallbacks). d_data ( dict [ str , Any ] , default: None ) \u2013 Dynamic data dictionary (live data). Defaults to None. *elements_states ( tuple [ ElementState ] , default: () ) \u2013 Variable list of child ElementState objects managed by this state. incoming_props ( dict [ str , Any ] , default: None ) \u2013 Global context/props passed from the parent/view. Defaults to None. strict ( bool , default: False ) \u2013 If True, raises errors when required data keys are missing. Defaults to False. **props ( dict [ str , Any ] , default: {} ) \u2013 Local property requirements (e.g., requirement check against incoming_props). Attributes: resolved_state_elements ( dict ) \u2013 Map of state_id to resolved ElementState after processing. state_errors ( str ) \u2013 Error message if validation fails. Example","title":"ComponentState"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState--define-elements","text":"es = ElementState('h1', s_state='title')","title":"Define elements"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState--define-state","text":"state = ComponentState( ... {'title': 'Hello World'}, ... {'title': 'Live Update'}, # d_data takes precedence ... es, ... strict=True ... ) ... print(state.resolve_template(es.placeholder))","title":"Define State"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState.remove_state_tag","text":"Removes all <$ ... > ... </$> state tags and keeps everything else intact. Source code in src\\probo\\components\\state\\component_state.py 152 153 154 155 156 157 def remove_state_tag ( self , markup : str ) -> str : \"\"\" Removes all <$ ... > ... </$> state tags and keeps everything else intact. \"\"\" pattern = r \"<\\$\\s[^>]*>(.*?)</\\$>\" return re . sub ( pattern , r \"\\1\" , markup , flags = re . DOTALL )","title":"remove_state_tag"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState.resolve_props","text":"Decides priority: Dynamic > Static. Source code in src\\probo\\components\\state\\component_state.py 78 79 80 81 82 83 84 85 86 87 88 def resolve_props ( self , prop : tuple [ dict [ str , str ]]) -> dict [ str , Any ] | None : \"\"\"Decides priority: Dynamic > Static.\"\"\" static_dict , dynamic_dict = prop s_val = list ( static_dict . values ())[ 0 ] d_val = list ( dynamic_dict . values ())[ 0 ] if d_val is not None and d_val : return dynamic_dict elif s_val is not None and s_val : return static_dict else : return None","title":"resolve_props"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState.use_state","text":"Replace <$ s=\"...\" d='None' i='None'>...</$> in children content with dynamic slot content Source code in src\\probo\\components\\state\\component_state.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 def use_state ( self , ) -> Self : \"\"\" Replace <$ s=\"...\" d='None' i='None'>...</$> in children content with dynamic slot content \"\"\" props_check = self . validate_global_props () if not props_check : if self . strict : raise ValueError ( f \"[probo Strict]\u26a0\ufe0f Rendering Blocked: { self . state_errors } \" ) else : self . _should_render = False return self for el in self . elements_states : data = self . _determine_state ( el . s_state , el . d_state ) rsolved_data = self . resolve_props ( data ) if rsolved_data : resolved_el = el . change_state ( rsolved_data , props = self . incoming_props ) self . resolved_state_elements [ el . state_id ] = resolved_el else : self . resolved_state_elements [ el . state_id ] = el return self","title":"use_state"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ComponentState.validate_global_props","text":"Checks if local requirements (self.props) match the global context (incoming_props). Returns True if valid, False if mismatch found. Source code in src\\probo\\components\\state\\component_state.py 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 def validate_global_props ( self ) -> bool : \"\"\" Checks if local requirements (self.props) match the global context (incoming_props). Returns True if valid, False if mismatch found. \"\"\" self . _should_render = True if not self . props : return True # No requirements, always valid if not self . props and not self . incoming_props : return True # No requirements, always valid if not self . incoming_props : # Requirements exist, but no global props provided -> Fail self . state_errors = \"Missing Global Context\" if self . strict : raise ValueError ( f \"[probo Strict] { self . state_errors } \" ) return False for key , required_value in self . props . items (): # 1. Check Existence if key not in self . incoming_props : self . state_errors = f \"Missing required prop: ' { key } '\" if self . strict : raise ValueError ( f \"[probo Strict] { self . state_errors } \" ) return False # 2. Check Value Match # We assume strict equality here. You can relax this if needed. if self . incoming_props [ key ] != required_value : self . state_errors = ( f \"Prop Mismatch for ' { key } ': \" f \"Expected ' { required_value } ', got ' { self . incoming_props [ key ] } '\" ) return False return True","title":"validate_global_props"},{"location":"reference/probo/components/state/component_state/#probo.components.state.component_state.ElementState","text":"The 'Neuron' of the system. Defines how a specific HTML element binds to data and behaves under different conditions. It handles data resolution (choosing between static/dynamic sources), attribute binding (injecting data into attributes like 'href'), and logic gates (hiding if requirements aren't met). Parameters: element ( str ) \u2013 The HTML tag name (e.g., 'div', 'span'). s_state ( str , default: str () ) \u2013 Key to look up in s_data. Defaults to \"\". d_state ( str , default: None ) \u2013 Key to look up in d_data. Defaults to None. c_state ( str , default: str () ) \u2013 Constant content or fallback key. Defaults to \"\" (used when binding). is_custom ( bool , default: False ) \u2013 If True, bypasses standard HTML attribute validation. Defaults to False. props ( StateProps , default: None ) \u2013 Logic gate rules for visibility. Defaults to None. bind_to ( str , default: None ) \u2013 HTML attribute to inject resolved data into (e.g., 'src', 'href'). Defaults to None. inner_html ( Callable , default: None ) \u2013 A function defined by user to define inner html thus passing the data before rendering. Defaults to None. i_state ( bool , default: False ) \u2013 If True, treats resolved data as iterable and renders a list. Defaults to False. hide_dynamic ( bool , default: False ) \u2013 If True and d_state is missing, hides the element completely. Defaults to False. is_void_element ( bool , default: False ) \u2013 If True, renders as a self-closing tag. Defaults to False. **attrs \u2013 Static HTML attributes for the element (e.g., Class='btn'). Attributes: placeholder ( str ) \u2013 The unique <$ ... $> string used in templates. state_id ( str ) \u2013 Unique UUID for this element state. Example:print >>> # Simple text binding >>> es = ElementState('span', d_state='username') >>> >>> # Attribute binding >>> es_link = ElementState('a', d_state='url', bind_to='href', c_state='Click Me') >>> >>> # List rendering >>> es_list = ElementState('li', d_state='items', i_state=True) Source code in src\\probo\\components\\state\\component_state.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 class ElementState : \"\"\" The 'Neuron' of the system. Defines how a specific HTML element binds to data and behaves under different conditions. It handles data resolution (choosing between static/dynamic sources), attribute binding (injecting data into attributes like 'href'), and logic gates (hiding if requirements aren't met). Args: element (str): The HTML tag name (e.g., 'div', 'span'). s_state (str, optional): Key to look up in s_data. Defaults to \"\". d_state (str, optional): Key to look up in d_data. Defaults to None. c_state (str, optional): Constant content or fallback key. Defaults to \"\" (used when binding). is_custom (bool, optional): If True, bypasses standard HTML attribute validation. Defaults to False. props (StateProps, optional): Logic gate rules for visibility. Defaults to None. bind_to (str, optional): HTML attribute to inject resolved data into (e.g., 'src', 'href'). Defaults to None. inner_html (Callable, optional): A function defined by user to define inner html thus passing the data before rendering. Defaults to None. i_state (bool, optional): If True, treats resolved data as iterable and renders a list. Defaults to False. hide_dynamic (bool, optional): If True and d_state is missing, hides the element completely. Defaults to False. is_void_element (bool, optional): If True, renders as a self-closing tag. Defaults to False. **attrs: Static HTML attributes for the element (e.g., Class='btn'). Attributes: placeholder (str): The unique <$ ... $> string used in templates. state_id (str): Unique UUID for this element state. Example:print >>> # Simple text binding >>> es = ElementState('span', d_state='username') >>> >>> # Attribute binding >>> es_link = ElementState('a', d_state='url', bind_to='href', c_state='Click Me') >>> >>> # List rendering >>> es_list = ElementState('li', d_state='items', i_state=True) \"\"\" def __init__ ( self , element , s_state : str = str (), d_state : str = None , c_state = str (), is_custom = False , props : StateProps = None , bind_to = None , inner_html = None , i_state = False , hide_dynamic = False , is_void_element : bool = False , key_as_content = False , ** attrs , ): import uuid self . state_id = f \" { element } == { uuid . uuid4 () . hex } \" self . placeholder = ( Element () . custom_element ( \"$\" , content = Element () . custom_element ( element , str ( s_state ), is_void_element , ** attrs ) . element , s = s_state , d = d_state , c = c_state , i = bool ( i_state ), ) . element ) # <$ s=\"...\" d='None' i='None'>...</$> self . state_placeholder = None self . element = element self . s_state = s_state self . d_state = d_state self . c_state = c_state if c_state else None self . i_state = bool ( i_state ) self . attrs = ( { k . lower () . replace ( \"_\" , \"-\" ): v for k , v in attrs . items ()} if attrs else {} ) self . props = props or StateProps () self . props . element_state_id = self . state_id self . is_void_element = is_void_element self . hide_dynamic = hide_dynamic self . bind_to = bind_to self . is_custom = is_custom self . key_as_content = key_as_content self . inner_html = ( inner_html if callable ( inner_html ) else lambda x : str ( x ) if not isinstance ( x , tuple ) else str ( x [ 1 ]) ) if not self . is_custom : # Check if static attrs passed in __init__ are valid self . valid_element = ElementAttributeValidator ( f \"< { self . element } >\" , ** self . attrs ) . is_valid else : self . valid_element = True def change_state ( self , data : dict [ str , str ], props = dict ()): if not self . props . validator ( props ) . is_valid () or not self . valid_element : self . state_placeholder = None else : if not self . is_void_element : if self . bind_to and ( not self . c_state or self . bind_to not in self . attrs ): self . state_placeholder = None else : if self . key_as_content and not data : key = self . d_state if self . d_state else self . s_state print ( key ) if not key : self . state_placeholder = None if self . i_state : self . state_placeholder = \"\" . join ( [ Element () . custom_element ( self . element , self . inner_html ( d ), ** self . attrs ) . element for d in enumerate ( key ) ] ) else : self . state_placeholder = Element () . custom_element ( self . element , self . inner_html ( key ), ** self . attrs ) . element else : if self . hide_dynamic and self . d_state and self . d_state not in data : self . state_placeholder = None elif self . d_state and self . d_state in data : if self . i_state : self . state_placeholder = \"\" . join ( [ Element () . custom_element ( self . element , self . inner_html ( d ), ** self . attrs ) . element for d in enumerate ( data . get ( self . d_state )) ] ) else : self . state_placeholder = ( Element () . custom_element ( self . element , self . inner_html ( self . c_state ), ** self . bind_data_to ( str ( data . get ( self . d_state ))), ) . element if self . bind_to else Element () . custom_element ( self . element , self . inner_html ( data . get ( self . d_state )), ** self . attrs , ) . element ) elif self . s_state in data : if self . i_state : self . state_placeholder = \"\" . join ( [ Element () . custom_element ( self . element , self . inner_html ( s ), ** self . attrs ) . element for s in enumerate ( data . get ( self . s_state )) ] ) else : self . state_placeholder = ( Element () . custom_element ( self . element , self . inner_html ( self . c_state ), ** self . bind_data_to ( str ( data . get ( self . s_state ))), ) . element if self . bind_to else Element () . custom_element ( self . element , self . inner_html ( data . get ( self . s_state )), ** self . attrs , ) . element ) else : self . state_placeholder = None else : target_value = data . get ( self . s_state ) or data . get ( self . d_state ) self . state_placeholder = ( Element () . custom_element ( self . element , ** self . bind_data_to ( str ( target_value )) ) . element if self . bind_to else Element () . custom_element ( self . element , is_void_element = self . is_void_element , ** self . attrs ) . element ) return self def bind_data_to ( self , target_value ): if self . bind_to is None : return self . attrs else : if self . bind_to in self . attrs : render_attrs = self . attrs . copy () render_attrs [ self . bind_to ] = target_value return render_attrs return self . attrs def render ( self , ** data ) -> str | None : return self . change_state ( data ) . state_placeholder","title":"ElementState"},{"location":"reference/probo/components/state/props/","text":"props StateProps dataclass A dataclass that holds a set of declarative rules (constraints) to validate against a component's incoming props. If all rules pass, the element is rendered. Source code in src\\probo\\components\\state\\props.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @dataclass class StateProps : \"\"\" A dataclass that holds a set of declarative rules (constraints) to validate against a component's incoming props. If all rules pass, the element is rendered. \"\"\" # Rule: Checks if props[key] == required_value # Example: {'status': 'published', 'is_active': True} prop_equals : Optional [ Dict [ str , Any ]] = field ( default_factory = dict ) # Rule: Checks if props[key] is IN allowed_values # Example: {'user_role': ['admin', 'editor']} prop_is_in : Optional [ Dict [ str , List [ Any ]]] = field ( default_factory = dict ) # Rule: Checks if props[key] is \"truthy\" (not None, False, 0, \"\", []) # Example: ['user', 'items_list'] prop_is_truthy : Optional [ List [ str ]] = field ( default_factory = list ) # Rule: Checks if props[key] (an object) has the listed attributes # Example: {'user': ['is_staff', 'email']} prop_has_attributes : Optional [ Dict [ str , List [ str ]]] = field ( default_factory = dict ) # Rule: Checks if props['user'] has a specific Django permission # Example: \"app_label.can_edit_post\" has_permissions : Optional [ list [ str ]] = field ( default_factory = list ) s_props : dict = field ( default_factory = dict ) element_state_id : str = field ( default_factory = str ) required : bool = field ( default_factory = bool ) display_it : bool = field ( default = True ) def get_prop ( self , prom ): return self . s_props . get ( prom , None ) def render_as_dict ( self , ) -> dict [ str , Any ]: return { \"prop_equals\" : self . prop_equals , \"prop_is_in\" : self . prop_is_in , \"prop_is_truthy\" : self . prop_is_truthy , \"prop_has_attributes\" : self . prop_has_attributes , \"has_permissions\" : self . has_permissions , \"s_props\" : self . s_props , \"element_state_id\" : self . element_state_id , \"required\" : self . required , \"display_it\" : self . display_it , } def validator ( self , props : dict ) -> StatePropsValidator : return StatePropsValidator ( rules = self , props = props ) StatePropsValidator Processes the rules defined in a StateProps object against a component's final props dictionary. Source code in src\\probo\\components\\state\\props.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class StatePropsValidator : \"\"\" Processes the rules defined in a StateProps object against a component's final props dictionary. \"\"\" def __init__ ( self , rules : \"StateProps\" , props : dict ) -> None : self . rules = rules self . props = props def is_valid ( self , ) -> bool : \"\"\" Checks if the component's props satisfy ALL defined rules. Returns True if all constraints pass, False otherwise. 'props' is the dictionary containing all component data, including 'user', 'session', etc. \"\"\" result = list () if not self . rules . display_it : return False # We run each check. If any single check fails, we stop # and return False immediately. if not self . _check_equals ( self . rules . prop_equals , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_is_in ( self . rules . prop_is_in , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_truthy ( self . rules . prop_is_truthy , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_has_attributes ( self . rules . prop_has_attributes , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_permissions ( self . rules . has_permissions , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_s_props ( self . rules . s_props , self . props ): result . append ( False ) else : result . append ( True ) if self . rules . required and not all ( result ): return False else : # If all checks passed return all ( result ) # --- Private Logic Methods --- def _check_equals ( self , rules_dict : Optional [ Dict [ str , Any ]], props : dict ) -> bool : \"\"\"Logic for: prop_equals\"\"\" if rules_dict : for key , required_value in rules_dict . items (): if key not in props : return False # The required prop doesn't even exist if props [ key ] != required_value : return False # The value does not match return True # All checks passed def _check_is_in ( self , rules_dict : Optional [ Dict [ str , List [ Any ]]], props : dict ) -> bool : \"\"\"Logic for: prop_is_in\"\"\" if rules_dict : for key , allowed_values in rules_dict . items (): if not isinstance ( allowed_values , ( list , set , tuple )): # Rule is misconfigured, fail safely return False if key not in props : return False # The required prop doesn't exist if props [ key ] not in allowed_values : return False # The value is not in the allowed list return True # All checks passed def _check_truthy ( self , rules_list : Optional [ List [ str ]], props : dict ) -> bool : \"\"\"Logic for: prop_is_truthy\"\"\" if rules_list : for key in rules_list : if key not in props : return False # The required prop doesn't exist if not props [ key ]: # Fails if prop is None, False, 0, \"\", [], {}, etc. return False return True # All checks passed def _check_has_attributes ( self , rules_dict : Optional [ Dict [ str , List [ str ]]], props : dict ) -> bool : \"\"\"Logic for: prop_has_attributes\"\"\" if rules_dict : for key , required_attrs in rules_dict . items (): if key not in props : return False # The required prop (object) doesn't exist obj_to_check = props [ key ] for attr_name in required_attrs : if not hasattr ( obj_to_check , attr_name ): return False # The object is missing a required attribute return True # All checks passed def _check_permissions ( self , permission_list : Optional [ list [ str ]], props : dict ) -> bool : \"\"\"Logic for: has_permission\"\"\" if not permission_list : return True # No permission rule was defined, so it passes # To check permissions, we MUST have a 'user' object in props if \"user\" not in props : return False # Cannot check permissions without a user user = props [ \"user\" ] # Check if the user object is a valid Django user (or mock) if not hasattr ( user , \"has_perm\" ): return False # Not a valid user object # The final check against Django's permission system if not all ( user . has_perm ( perm ) for perm in permission_list ): return False return True # User has the permission def _check_s_props ( self , s_props : dict , props : dict ) -> bool : if not s_props : return True # return self.props.items() <= props.items() def __exists_in_dict ( x ): status = list () for value in props . values (): # Check key if x == value : status . append ( True ) # Check nested dict else : # Check nested key or nested value status . append ( False ) return any ( status ) def valid_props ( props ): if not all ([ x in props for x in s_props ]): return False else : return all ([ __exists_in_dict ( x ) for x in s_props . values ()]) return valid_props ( props = props ) is_valid () Checks if the component's props satisfy ALL defined rules. Returns True if all constraints pass, False otherwise. 'props' is the dictionary containing all component data, including 'user', 'session', etc. Source code in src\\probo\\components\\state\\props.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def is_valid ( self , ) -> bool : \"\"\" Checks if the component's props satisfy ALL defined rules. Returns True if all constraints pass, False otherwise. 'props' is the dictionary containing all component data, including 'user', 'session', etc. \"\"\" result = list () if not self . rules . display_it : return False # We run each check. If any single check fails, we stop # and return False immediately. if not self . _check_equals ( self . rules . prop_equals , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_is_in ( self . rules . prop_is_in , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_truthy ( self . rules . prop_is_truthy , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_has_attributes ( self . rules . prop_has_attributes , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_permissions ( self . rules . has_permissions , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_s_props ( self . rules . s_props , self . props ): result . append ( False ) else : result . append ( True ) if self . rules . required and not all ( result ): return False else : # If all checks passed return all ( result )","title":"props"},{"location":"reference/probo/components/state/props/#props","text":"","title":"props"},{"location":"reference/probo/components/state/props/#probo.components.state.props.StateProps","text":"A dataclass that holds a set of declarative rules (constraints) to validate against a component's incoming props. If all rules pass, the element is rendered. Source code in src\\probo\\components\\state\\props.py 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 @dataclass class StateProps : \"\"\" A dataclass that holds a set of declarative rules (constraints) to validate against a component's incoming props. If all rules pass, the element is rendered. \"\"\" # Rule: Checks if props[key] == required_value # Example: {'status': 'published', 'is_active': True} prop_equals : Optional [ Dict [ str , Any ]] = field ( default_factory = dict ) # Rule: Checks if props[key] is IN allowed_values # Example: {'user_role': ['admin', 'editor']} prop_is_in : Optional [ Dict [ str , List [ Any ]]] = field ( default_factory = dict ) # Rule: Checks if props[key] is \"truthy\" (not None, False, 0, \"\", []) # Example: ['user', 'items_list'] prop_is_truthy : Optional [ List [ str ]] = field ( default_factory = list ) # Rule: Checks if props[key] (an object) has the listed attributes # Example: {'user': ['is_staff', 'email']} prop_has_attributes : Optional [ Dict [ str , List [ str ]]] = field ( default_factory = dict ) # Rule: Checks if props['user'] has a specific Django permission # Example: \"app_label.can_edit_post\" has_permissions : Optional [ list [ str ]] = field ( default_factory = list ) s_props : dict = field ( default_factory = dict ) element_state_id : str = field ( default_factory = str ) required : bool = field ( default_factory = bool ) display_it : bool = field ( default = True ) def get_prop ( self , prom ): return self . s_props . get ( prom , None ) def render_as_dict ( self , ) -> dict [ str , Any ]: return { \"prop_equals\" : self . prop_equals , \"prop_is_in\" : self . prop_is_in , \"prop_is_truthy\" : self . prop_is_truthy , \"prop_has_attributes\" : self . prop_has_attributes , \"has_permissions\" : self . has_permissions , \"s_props\" : self . s_props , \"element_state_id\" : self . element_state_id , \"required\" : self . required , \"display_it\" : self . display_it , } def validator ( self , props : dict ) -> StatePropsValidator : return StatePropsValidator ( rules = self , props = props )","title":"StateProps"},{"location":"reference/probo/components/state/props/#probo.components.state.props.StatePropsValidator","text":"Processes the rules defined in a StateProps object against a component's final props dictionary. Source code in src\\probo\\components\\state\\props.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 class StatePropsValidator : \"\"\" Processes the rules defined in a StateProps object against a component's final props dictionary. \"\"\" def __init__ ( self , rules : \"StateProps\" , props : dict ) -> None : self . rules = rules self . props = props def is_valid ( self , ) -> bool : \"\"\" Checks if the component's props satisfy ALL defined rules. Returns True if all constraints pass, False otherwise. 'props' is the dictionary containing all component data, including 'user', 'session', etc. \"\"\" result = list () if not self . rules . display_it : return False # We run each check. If any single check fails, we stop # and return False immediately. if not self . _check_equals ( self . rules . prop_equals , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_is_in ( self . rules . prop_is_in , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_truthy ( self . rules . prop_is_truthy , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_has_attributes ( self . rules . prop_has_attributes , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_permissions ( self . rules . has_permissions , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_s_props ( self . rules . s_props , self . props ): result . append ( False ) else : result . append ( True ) if self . rules . required and not all ( result ): return False else : # If all checks passed return all ( result ) # --- Private Logic Methods --- def _check_equals ( self , rules_dict : Optional [ Dict [ str , Any ]], props : dict ) -> bool : \"\"\"Logic for: prop_equals\"\"\" if rules_dict : for key , required_value in rules_dict . items (): if key not in props : return False # The required prop doesn't even exist if props [ key ] != required_value : return False # The value does not match return True # All checks passed def _check_is_in ( self , rules_dict : Optional [ Dict [ str , List [ Any ]]], props : dict ) -> bool : \"\"\"Logic for: prop_is_in\"\"\" if rules_dict : for key , allowed_values in rules_dict . items (): if not isinstance ( allowed_values , ( list , set , tuple )): # Rule is misconfigured, fail safely return False if key not in props : return False # The required prop doesn't exist if props [ key ] not in allowed_values : return False # The value is not in the allowed list return True # All checks passed def _check_truthy ( self , rules_list : Optional [ List [ str ]], props : dict ) -> bool : \"\"\"Logic for: prop_is_truthy\"\"\" if rules_list : for key in rules_list : if key not in props : return False # The required prop doesn't exist if not props [ key ]: # Fails if prop is None, False, 0, \"\", [], {}, etc. return False return True # All checks passed def _check_has_attributes ( self , rules_dict : Optional [ Dict [ str , List [ str ]]], props : dict ) -> bool : \"\"\"Logic for: prop_has_attributes\"\"\" if rules_dict : for key , required_attrs in rules_dict . items (): if key not in props : return False # The required prop (object) doesn't exist obj_to_check = props [ key ] for attr_name in required_attrs : if not hasattr ( obj_to_check , attr_name ): return False # The object is missing a required attribute return True # All checks passed def _check_permissions ( self , permission_list : Optional [ list [ str ]], props : dict ) -> bool : \"\"\"Logic for: has_permission\"\"\" if not permission_list : return True # No permission rule was defined, so it passes # To check permissions, we MUST have a 'user' object in props if \"user\" not in props : return False # Cannot check permissions without a user user = props [ \"user\" ] # Check if the user object is a valid Django user (or mock) if not hasattr ( user , \"has_perm\" ): return False # Not a valid user object # The final check against Django's permission system if not all ( user . has_perm ( perm ) for perm in permission_list ): return False return True # User has the permission def _check_s_props ( self , s_props : dict , props : dict ) -> bool : if not s_props : return True # return self.props.items() <= props.items() def __exists_in_dict ( x ): status = list () for value in props . values (): # Check key if x == value : status . append ( True ) # Check nested dict else : # Check nested key or nested value status . append ( False ) return any ( status ) def valid_props ( props ): if not all ([ x in props for x in s_props ]): return False else : return all ([ __exists_in_dict ( x ) for x in s_props . values ()]) return valid_props ( props = props )","title":"StatePropsValidator"},{"location":"reference/probo/components/state/props/#probo.components.state.props.StatePropsValidator.is_valid","text":"Checks if the component's props satisfy ALL defined rules. Returns True if all constraints pass, False otherwise. 'props' is the dictionary containing all component data, including 'user', 'session', etc. Source code in src\\probo\\components\\state\\props.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def is_valid ( self , ) -> bool : \"\"\" Checks if the component's props satisfy ALL defined rules. Returns True if all constraints pass, False otherwise. 'props' is the dictionary containing all component data, including 'user', 'session', etc. \"\"\" result = list () if not self . rules . display_it : return False # We run each check. If any single check fails, we stop # and return False immediately. if not self . _check_equals ( self . rules . prop_equals , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_is_in ( self . rules . prop_is_in , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_truthy ( self . rules . prop_is_truthy , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_has_attributes ( self . rules . prop_has_attributes , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_permissions ( self . rules . has_permissions , self . props ): result . append ( False ) else : result . append ( True ) if not self . _check_s_props ( self . rules . s_props , self . props ): result . append ( False ) else : result . append ( True ) if self . rules . required and not all ( result ): return False else : # If all checks passed return all ( result )","title":"is_valid"},{"location":"reference/probo/components/tag_classes/block_tags/","text":"block_tags A Bases: BaseHTMLElement , ElementNodeMixin Represents an A HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an A HTML <a> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:a = Element( ).set_attrs(**self.attributes).set_content(self.content).a().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . a () . element ) render () Blueprint:a = Element( ).set_attrs(**self.attributes).set_content(self.content).a().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 15 16 17 18 19 20 21 22 23 24 25 def render ( self ): ''' Blueprint:a = Element( ).set_attrs(**self.attributes).set_content(self.content).a().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . a () . element ) ABBR Bases: BaseHTMLElement , ElementNodeMixin Represents an ABBR HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class ABBR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ABBR HTML <abbr> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:abbr = Element( ).set_attrs(**self.attributes).set_content(self.content).abbr().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . abbr () . element ) render () Blueprint:abbr = Element( ).set_attrs(**self.attributes).set_content(self.content).abbr().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 34 35 36 37 38 39 40 41 42 43 44 def render ( self ): ''' Blueprint:abbr = Element( ).set_attrs(**self.attributes).set_content(self.content).abbr().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . abbr () . element ) ADDRESS Bases: BaseHTMLElement , ElementNodeMixin Represents an ADDRESS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class ADDRESS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ADDRESS HTML <address> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:address = Element( ).set_attrs(**self.attributes).set_content(self.content).address().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . address () . element ) render () Blueprint:address = Element( ).set_attrs(**self.attributes).set_content(self.content).address().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 53 54 55 56 57 58 59 60 61 62 63 def render ( self ): ''' Blueprint:address = Element( ).set_attrs(**self.attributes).set_content(self.content).address().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . address () . element ) ARTICLE Bases: BaseHTMLElement , ElementNodeMixin Represents an ARTICLE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class ARTICLE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ARTICLE HTML <article> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:article = Element( ).set_attrs(**self.attributes).set_content(self.content).article().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . article () . element ) render () Blueprint:article = Element( ).set_attrs(**self.attributes).set_content(self.content).article().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 72 73 74 75 76 77 78 79 80 81 82 def render ( self ): ''' Blueprint:article = Element( ).set_attrs(**self.attributes).set_content(self.content).article().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . article () . element ) ASIDE Bases: BaseHTMLElement , ElementNodeMixin Represents an ASIDE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class ASIDE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ASIDE HTML <aside> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:aside = Element( ).set_attrs(**self.attributes).set_content(self.content).aside().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . aside () . element ) render () Blueprint:aside = Element( ).set_attrs(**self.attributes).set_content(self.content).aside().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 91 92 93 94 95 96 97 98 99 100 101 def render ( self ): ''' Blueprint:aside = Element( ).set_attrs(**self.attributes).set_content(self.content).aside().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . aside () . element ) AUDIO Bases: BaseHTMLElement , ElementNodeMixin Represents an AUDIO HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class AUDIO ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an AUDIO HTML <audio> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:audio = Element( ).set_attrs(**self.attributes).set_content(self.content).audio().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . audio () . element ) render () Blueprint:audio = Element( ).set_attrs(**self.attributes).set_content(self.content).audio().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 110 111 112 113 114 115 116 117 118 119 120 def render ( self ): ''' Blueprint:audio = Element( ).set_attrs(**self.attributes).set_content(self.content).audio().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . audio () . element ) B Bases: BaseHTMLElement , ElementNodeMixin Represents an B HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class B ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an B HTML <b> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:b = Element( ).set_attrs(**self.attributes).set_content(self.content).b().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . b () . element ) render () Blueprint:b = Element( ).set_attrs(**self.attributes).set_content(self.content).b().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 129 130 131 132 133 134 135 136 137 138 139 def render ( self ): ''' Blueprint:b = Element( ).set_attrs(**self.attributes).set_content(self.content).b().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . b () . element ) BDI Bases: BaseHTMLElement , ElementNodeMixin Represents an BDI HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class BDI ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BDI HTML <bdi> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:bdi = Element( ).set_attrs(**self.attributes).set_content(self.content).bdi().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdi () . element ) render () Blueprint:bdi = Element( ).set_attrs(**self.attributes).set_content(self.content).bdi().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 148 149 150 151 152 153 154 155 156 157 158 def render ( self ): ''' Blueprint:bdi = Element( ).set_attrs(**self.attributes).set_content(self.content).bdi().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdi () . element ) BDO Bases: BaseHTMLElement , ElementNodeMixin Represents an BDO HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class BDO ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BDO HTML <bdo> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:bdo = Element( ).set_attrs(**self.attributes).set_content(self.content).bdo().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdo () . element ) render () Blueprint:bdo = Element( ).set_attrs(**self.attributes).set_content(self.content).bdo().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 167 168 169 170 171 172 173 174 175 176 177 def render ( self ): ''' Blueprint:bdo = Element( ).set_attrs(**self.attributes).set_content(self.content).bdo().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdo () . element ) BLOCKQUOTE Bases: BaseHTMLElement , ElementNodeMixin Represents an BLOCKQUOTE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class BLOCKQUOTE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BLOCKQUOTE HTML <blockquote> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:blockquote = Element( ).set_attrs(**self.attributes).set_content(self.content).blockquote().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . blockquote () . element ) render () Blueprint:blockquote = Element( ).set_attrs(**self.attributes).set_content(self.content).blockquote().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 186 187 188 189 190 191 192 193 194 195 196 def render ( self ): ''' Blueprint:blockquote = Element( ).set_attrs(**self.attributes).set_content(self.content).blockquote().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . blockquote () . element ) BODY Bases: BaseHTMLElement , ElementNodeMixin Represents an BODY HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class BODY ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BODY HTML <body> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:body = Element( ).set_attrs(**self.attributes).set_content(self.content).body().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . body () . element ) render () Blueprint:body = Element( ).set_attrs(**self.attributes).set_content(self.content).body().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 205 206 207 208 209 210 211 212 213 214 215 def render ( self ): ''' Blueprint:body = Element( ).set_attrs(**self.attributes).set_content(self.content).body().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . body () . element ) BUTTON Bases: BaseHTMLElement , ElementNodeMixin Represents an BUTTON HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class BUTTON ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BUTTON HTML <button> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:button = Element( ).set_attrs(**self.attributes).set_content(self.content).button().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . button () . element ) render () Blueprint:button = Element( ).set_attrs(**self.attributes).set_content(self.content).button().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 224 225 226 227 228 229 230 231 232 233 234 def render ( self ): ''' Blueprint:button = Element( ).set_attrs(**self.attributes).set_content(self.content).button().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . button () . element ) CANVAS Bases: BaseHTMLElement , ElementNodeMixin Represents an CANVAS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 class CANVAS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CANVAS HTML <canvas> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:canvas = Element( ).set_attrs(**self.attributes).set_content(self.content).canvas().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . canvas () . element ) render () Blueprint:canvas = Element( ).set_attrs(**self.attributes).set_content(self.content).canvas().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 243 244 245 246 247 248 249 250 251 252 253 def render ( self ): ''' Blueprint:canvas = Element( ).set_attrs(**self.attributes).set_content(self.content).canvas().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . canvas () . element ) CAPTION Bases: BaseHTMLElement , ElementNodeMixin Represents an CAPTION HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class CAPTION ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CAPTION HTML <caption> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:caption = Element( ).set_attrs(**self.attributes).set_content(self.content).caption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . caption () . element ) render () Blueprint:caption = Element( ).set_attrs(**self.attributes).set_content(self.content).caption().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 262 263 264 265 266 267 268 269 270 271 272 def render ( self ): ''' Blueprint:caption = Element( ).set_attrs(**self.attributes).set_content(self.content).caption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . caption () . element ) CITE Bases: BaseHTMLElement , ElementNodeMixin Represents an CITE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 class CITE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CITE HTML <cite> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:cite = Element( ).set_attrs(**self.attributes).set_content(self.content).cite().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . cite () . element ) render () Blueprint:cite = Element( ).set_attrs(**self.attributes).set_content(self.content).cite().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 281 282 283 284 285 286 287 288 289 290 291 def render ( self ): ''' Blueprint:cite = Element( ).set_attrs(**self.attributes).set_content(self.content).cite().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . cite () . element ) CODE Bases: BaseHTMLElement , ElementNodeMixin Represents an CODE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 class CODE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CODE HTML <code> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:code = Element( ).set_attrs(**self.attributes).set_content(self.content).code().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . code () . element ) render () Blueprint:code = Element( ).set_attrs(**self.attributes).set_content(self.content).code().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 300 301 302 303 304 305 306 307 308 309 310 def render ( self ): ''' Blueprint:code = Element( ).set_attrs(**self.attributes).set_content(self.content).code().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . code () . element ) COLGROUP Bases: BaseHTMLElement , ElementNodeMixin Represents an COLGROUP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class COLGROUP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an COLGROUP HTML <colgroup> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:colgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).colgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . colgroup () . element ) render () Blueprint:colgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).colgroup().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 319 320 321 322 323 324 325 326 327 328 329 def render ( self ): ''' Blueprint:colgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).colgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . colgroup () . element ) DATA Bases: BaseHTMLElement , ElementNodeMixin Represents an DATA HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class DATA ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DATA HTML <data> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:data = Element( ).set_attrs(**self.attributes).set_content(self.content).data().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . data () . element ) render () Blueprint:data = Element( ).set_attrs(**self.attributes).set_content(self.content).data().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 338 339 340 341 342 343 344 345 346 347 348 def render ( self ): ''' Blueprint:data = Element( ).set_attrs(**self.attributes).set_content(self.content).data().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . data () . element ) DATALIST Bases: BaseHTMLElement , ElementNodeMixin Represents an DATALIST HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 class DATALIST ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DATALIST HTML <datalist> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:datalist = Element( ).set_attrs(**self.attributes).set_content(self.content).datalist().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . datalist () . element ) render () Blueprint:datalist = Element( ).set_attrs(**self.attributes).set_content(self.content).datalist().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 357 358 359 360 361 362 363 364 365 366 367 def render ( self ): ''' Blueprint:datalist = Element( ).set_attrs(**self.attributes).set_content(self.content).datalist().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . datalist () . element ) DD Bases: BaseHTMLElement , ElementNodeMixin Represents an DD HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class DD ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DD HTML <dd> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dd = Element( ).set_attrs(**self.attributes).set_content(self.content).dd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dd () . element ) render () Blueprint:dd = Element( ).set_attrs(**self.attributes).set_content(self.content).dd().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 376 377 378 379 380 381 382 383 384 385 386 def render ( self ): ''' Blueprint:dd = Element( ).set_attrs(**self.attributes).set_content(self.content).dd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dd () . element ) DEFS Bases: BaseHTMLElement , ElementNodeMixin Represents an DEFS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 class DEFS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DEFS HTML <defs> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:defs = Element( ).set_attrs(**self.attributes).set_content(self.content).defs().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . defs () . element ) render () Blueprint:defs = Element( ).set_attrs(**self.attributes).set_content(self.content).defs().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 def render ( self ): ''' Blueprint:defs = Element( ).set_attrs(**self.attributes).set_content(self.content).defs().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . defs () . element ) DEL Bases: BaseHTMLElement , ElementNodeMixin Represents an DEL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 class DEL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DEL HTML <del> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:del = Element( ).set_attrs(**self.attributes).set_content(self.content).del().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Del () . element ) render () Blueprint:del = Element( ).set_attrs(**self.attributes).set_content(self.content).del().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 395 396 397 398 399 400 401 402 403 404 405 def render ( self ): ''' Blueprint:del = Element( ).set_attrs(**self.attributes).set_content(self.content).del().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Del () . element ) DETAILS Bases: BaseHTMLElement , ElementNodeMixin Represents an DETAILS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 class DETAILS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DETAILS HTML <details> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:details = Element( ).set_attrs(**self.attributes).set_content(self.content).details().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . details () . element ) render () Blueprint:details = Element( ).set_attrs(**self.attributes).set_content(self.content).details().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 414 415 416 417 418 419 420 421 422 423 424 def render ( self ): ''' Blueprint:details = Element( ).set_attrs(**self.attributes).set_content(self.content).details().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . details () . element ) DFN Bases: BaseHTMLElement , ElementNodeMixin Represents an DFN HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 class DFN ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DFN HTML <dfn> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dfn = Element( ).set_attrs(**self.attributes).set_content(self.content).dfn().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dfn () . element ) render () Blueprint:dfn = Element( ).set_attrs(**self.attributes).set_content(self.content).dfn().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 433 434 435 436 437 438 439 440 441 442 443 def render ( self ): ''' Blueprint:dfn = Element( ).set_attrs(**self.attributes).set_content(self.content).dfn().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dfn () . element ) DIALOG Bases: BaseHTMLElement , ElementNodeMixin Represents an DIALOG HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 class DIALOG ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DIALOG HTML <dialog> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dialog = Element( ).set_attrs(**self.attributes).set_content(self.content).dialog().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dialog () . element ) render () Blueprint:dialog = Element( ).set_attrs(**self.attributes).set_content(self.content).dialog().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 452 453 454 455 456 457 458 459 460 461 462 def render ( self ): ''' Blueprint:dialog = Element( ).set_attrs(**self.attributes).set_content(self.content).dialog().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dialog () . element ) DIV Bases: BaseHTMLElement , ElementNodeMixin Represents an DIV HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 class DIV ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DIV HTML <div> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:div = Element( ).set_attrs(**self.attributes).set_content(self.content).div().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . div () . element ) render () Blueprint:div = Element( ).set_attrs(**self.attributes).set_content(self.content).div().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 471 472 473 474 475 476 477 478 479 480 481 def render ( self ): ''' Blueprint:div = Element( ).set_attrs(**self.attributes).set_content(self.content).div().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . div () . element ) DL Bases: BaseHTMLElement , ElementNodeMixin Represents an DL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 class DL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DL HTML <dl> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dl = Element( ).set_attrs(**self.attributes).set_content(self.content).dl().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dl () . element ) render () Blueprint:dl = Element( ).set_attrs(**self.attributes).set_content(self.content).dl().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 490 491 492 493 494 495 496 497 498 499 500 def render ( self ): ''' Blueprint:dl = Element( ).set_attrs(**self.attributes).set_content(self.content).dl().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dl () . element ) DT Bases: BaseHTMLElement , ElementNodeMixin Represents an DT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 class DT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DT HTML <dt> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dt = Element( ).set_attrs(**self.attributes).set_content(self.content).dt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dt () . element ) render () Blueprint:dt = Element( ).set_attrs(**self.attributes).set_content(self.content).dt().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 509 510 511 512 513 514 515 516 517 518 519 def render ( self ): ''' Blueprint:dt = Element( ).set_attrs(**self.attributes).set_content(self.content).dt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dt () . element ) EM Bases: BaseHTMLElement , ElementNodeMixin Represents an EM HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 class EM ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an EM HTML <em> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:em = Element( ).set_attrs(**self.attributes).set_content(self.content).em().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . em () . element ) render () Blueprint:em = Element( ).set_attrs(**self.attributes).set_content(self.content).em().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 528 529 530 531 532 533 534 535 536 537 538 def render ( self ): ''' Blueprint:em = Element( ).set_attrs(**self.attributes).set_content(self.content).em().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . em () . element ) FIELDSET Bases: BaseHTMLElement , ElementNodeMixin Represents an FIELDSET HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 class FIELDSET ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FIELDSET HTML <fieldset> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:fieldset = Element( ).set_attrs(**self.attributes).set_content(self.content).fieldset().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . fieldset () . element ) render () Blueprint:fieldset = Element( ).set_attrs(**self.attributes).set_content(self.content).fieldset().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 547 548 549 550 551 552 553 554 555 556 557 def render ( self ): ''' Blueprint:fieldset = Element( ).set_attrs(**self.attributes).set_content(self.content).fieldset().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . fieldset () . element ) FIGCAPTION Bases: BaseHTMLElement , ElementNodeMixin Represents an FIGCAPTION HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 class FIGCAPTION ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FIGCAPTION HTML <figcaption> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:figcaption = Element( ).set_attrs(**self.attributes).set_content(self.content).figcaption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figcaption () . element ) render () Blueprint:figcaption = Element( ).set_attrs(**self.attributes).set_content(self.content).figcaption().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 566 567 568 569 570 571 572 573 574 575 576 def render ( self ): ''' Blueprint:figcaption = Element( ).set_attrs(**self.attributes).set_content(self.content).figcaption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figcaption () . element ) FIGURE Bases: BaseHTMLElement , ElementNodeMixin Represents an FIGURE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 class FIGURE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FIGURE HTML <figure> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:figure = Element( ).set_attrs(**self.attributes).set_content(self.content).figure().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figure () . element ) render () Blueprint:figure = Element( ).set_attrs(**self.attributes).set_content(self.content).figure().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 585 586 587 588 589 590 591 592 593 594 595 def render ( self ): ''' Blueprint:figure = Element( ).set_attrs(**self.attributes).set_content(self.content).figure().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figure () . element ) FOOTER Bases: BaseHTMLElement , ElementNodeMixin Represents an FOOTER HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 class FOOTER ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FOOTER HTML <footer> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:footer = Element( ).set_attrs(**self.attributes).set_content(self.content).footer().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . footer () . element ) render () Blueprint:footer = Element( ).set_attrs(**self.attributes).set_content(self.content).footer().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 604 605 606 607 608 609 610 611 612 613 614 def render ( self ): ''' Blueprint:footer = Element( ).set_attrs(**self.attributes).set_content(self.content).footer().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . footer () . element ) FORM Bases: BaseHTMLElement , ElementNodeMixin Represents an FORM HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 class FORM ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FORM HTML <form> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:form = Element( ).set_attrs(**self.attributes).set_content(self.content).form().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . form () . element ) render () Blueprint:form = Element( ).set_attrs(**self.attributes).set_content(self.content).form().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 623 624 625 626 627 628 629 630 631 632 633 def render ( self ): ''' Blueprint:form = Element( ).set_attrs(**self.attributes).set_content(self.content).form().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . form () . element ) G Bases: BaseHTMLElement , ElementNodeMixin Represents an G HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 class G ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an G HTML <g> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:g = Element( ).set_attrs(**self.attributes).set_content(self.content).g().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . g () . element ) render () Blueprint:g = Element( ).set_attrs(**self.attributes).set_content(self.content).g().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 def render ( self ): ''' Blueprint:g = Element( ).set_attrs(**self.attributes).set_content(self.content).g().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . g () . element ) H1 Bases: BaseHTMLElement , ElementNodeMixin Represents an H1 HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 class H1 ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an H1 HTML <h1> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:h1 = Element( ).set_attrs(**self.attributes).set_content(self.content).h1().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h1 () . element ) render () Blueprint:h1 = Element( ).set_attrs(**self.attributes).set_content(self.content).h1().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 642 643 644 645 646 647 648 649 650 651 652 def render ( self ): ''' Blueprint:h1 = Element( ).set_attrs(**self.attributes).set_content(self.content).h1().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h1 () . element ) H2 Bases: BaseHTMLElement , ElementNodeMixin Represents an H2 HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 655 656 657 658 659 660 661 662 663 664 665 666 667 668 669 670 671 class H2 ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an H2 HTML <h2> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:h2 = Element( ).set_attrs(**self.attributes).set_content(self.content).h2().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h2 () . element ) render () Blueprint:h2 = Element( ).set_attrs(**self.attributes).set_content(self.content).h2().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 661 662 663 664 665 666 667 668 669 670 671 def render ( self ): ''' Blueprint:h2 = Element( ).set_attrs(**self.attributes).set_content(self.content).h2().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h2 () . element ) H3 Bases: BaseHTMLElement , ElementNodeMixin Represents an H3 HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 674 675 676 677 678 679 680 681 682 683 684 685 686 687 688 689 690 class H3 ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an H3 HTML <h3> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:h3 = Element( ).set_attrs(**self.attributes).set_content(self.content).h3().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h3 () . element ) render () Blueprint:h3 = Element( ).set_attrs(**self.attributes).set_content(self.content).h3().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 680 681 682 683 684 685 686 687 688 689 690 def render ( self ): ''' Blueprint:h3 = Element( ).set_attrs(**self.attributes).set_content(self.content).h3().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h3 () . element ) H4 Bases: BaseHTMLElement , ElementNodeMixin Represents an H4 HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 693 694 695 696 697 698 699 700 701 702 703 704 705 706 707 708 709 class H4 ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an H4 HTML <h4> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:h4 = Element( ).set_attrs(**self.attributes).set_content(self.content).h4().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h4 () . element ) render () Blueprint:h4 = Element( ).set_attrs(**self.attributes).set_content(self.content).h4().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 699 700 701 702 703 704 705 706 707 708 709 def render ( self ): ''' Blueprint:h4 = Element( ).set_attrs(**self.attributes).set_content(self.content).h4().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h4 () . element ) H5 Bases: BaseHTMLElement , ElementNodeMixin Represents an H5 HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 712 713 714 715 716 717 718 719 720 721 722 723 724 725 726 727 728 class H5 ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an H5 HTML <h5> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:h5 = Element( ).set_attrs(**self.attributes).set_content(self.content).h5().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h5 () . element ) render () Blueprint:h5 = Element( ).set_attrs(**self.attributes).set_content(self.content).h5().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 718 719 720 721 722 723 724 725 726 727 728 def render ( self ): ''' Blueprint:h5 = Element( ).set_attrs(**self.attributes).set_content(self.content).h5().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h5 () . element ) H6 Bases: BaseHTMLElement , ElementNodeMixin Represents an H6 HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 731 732 733 734 735 736 737 738 739 740 741 742 743 744 745 746 747 class H6 ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an H6 HTML <h6> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:h6 = Element( ).set_attrs(**self.attributes).set_content(self.content).h6().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h6 () . element ) render () Blueprint:h6 = Element( ).set_attrs(**self.attributes).set_content(self.content).h6().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 737 738 739 740 741 742 743 744 745 746 747 def render ( self ): ''' Blueprint:h6 = Element( ).set_attrs(**self.attributes).set_content(self.content).h6().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h6 () . element ) HEAD Bases: BaseHTMLElement , ElementNodeMixin Represents an HEAD HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 class HEAD ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HEAD HTML <head> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:head = Element( ).set_attrs(**self.attributes).set_content(self.content).head().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . head () . element ) render () Blueprint:head = Element( ).set_attrs(**self.attributes).set_content(self.content).head().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 756 757 758 759 760 761 762 763 764 765 766 def render ( self ): ''' Blueprint:head = Element( ).set_attrs(**self.attributes).set_content(self.content).head().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . head () . element ) HEADER Bases: BaseHTMLElement , ElementNodeMixin Represents an HEADER HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 class HEADER ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HEADER HTML <header> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:header = Element( ).set_attrs(**self.attributes).set_content(self.content).header().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . header () . element ) render () Blueprint:header = Element( ).set_attrs(**self.attributes).set_content(self.content).header().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 775 776 777 778 779 780 781 782 783 784 785 def render ( self ): ''' Blueprint:header = Element( ).set_attrs(**self.attributes).set_content(self.content).header().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . header () . element ) HGROUP Bases: BaseHTMLElement , ElementNodeMixin Represents an HGROUP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 class HGROUP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HGROUP HTML <hgroup> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:hgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).hgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . hgroup () . element ) render () Blueprint:hgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).hgroup().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 794 795 796 797 798 799 800 801 802 803 804 def render ( self ): ''' Blueprint:hgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).hgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . hgroup () . element ) HTML Bases: BaseHTMLElement , ElementNodeMixin Represents an HTML HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 class HTML ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HTML HTML <html> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:html = Element( ).set_attrs(**self.attributes).set_content(self.content).html().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . html () . element ) render () Blueprint:html = Element( ).set_attrs(**self.attributes).set_content(self.content).html().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 813 814 815 816 817 818 819 820 821 822 823 def render ( self ): ''' Blueprint:html = Element( ).set_attrs(**self.attributes).set_content(self.content).html().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . html () . element ) I Bases: BaseHTMLElement , ElementNodeMixin Represents an I HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 class I ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an I HTML <i> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:i = Element( ).set_attrs(**self.attributes).set_content(self.content).i().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . i () . element ) render () Blueprint:i = Element( ).set_attrs(**self.attributes).set_content(self.content).i().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 832 833 834 835 836 837 838 839 840 841 842 def render ( self ): ''' Blueprint:i = Element( ).set_attrs(**self.attributes).set_content(self.content).i().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . i () . element ) IFRAME Bases: BaseHTMLElement , ElementNodeMixin Represents an IFRAME HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 class IFRAME ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an IFRAME HTML <iframe> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:iframe = Element( ).set_attrs(**self.attributes).set_content(self.content).iframe().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . iframe () . element ) render () Blueprint:iframe = Element( ).set_attrs(**self.attributes).set_content(self.content).iframe().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 851 852 853 854 855 856 857 858 859 860 861 def render ( self ): ''' Blueprint:iframe = Element( ).set_attrs(**self.attributes).set_content(self.content).iframe().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . iframe () . element ) INS Bases: BaseHTMLElement , ElementNodeMixin Represents an INS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 class INS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an INS HTML <ins> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:ins = Element( ).set_attrs(**self.attributes).set_content(self.content).ins().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ins () . element ) render () Blueprint:ins = Element( ).set_attrs(**self.attributes).set_content(self.content).ins().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 870 871 872 873 874 875 876 877 878 879 880 def render ( self ): ''' Blueprint:ins = Element( ).set_attrs(**self.attributes).set_content(self.content).ins().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ins () . element ) KBD Bases: BaseHTMLElement , ElementNodeMixin Represents an KBD HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 class KBD ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an KBD HTML <kbd> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:kbd = Element( ).set_attrs(**self.attributes).set_content(self.content).kbd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . kbd () . element ) render () Blueprint:kbd = Element( ).set_attrs(**self.attributes).set_content(self.content).kbd().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 889 890 891 892 893 894 895 896 897 898 899 def render ( self ): ''' Blueprint:kbd = Element( ).set_attrs(**self.attributes).set_content(self.content).kbd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . kbd () . element ) LABEL Bases: BaseHTMLElement , ElementNodeMixin Represents an LABEL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 class LABEL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LABEL HTML <label> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:label = Element( ).set_attrs(**self.attributes).set_content(self.content).label().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . label () . element ) render () Blueprint:label = Element( ).set_attrs(**self.attributes).set_content(self.content).label().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 908 909 910 911 912 913 914 915 916 917 918 def render ( self ): ''' Blueprint:label = Element( ).set_attrs(**self.attributes).set_content(self.content).label().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . label () . element ) LEGEND Bases: BaseHTMLElement , ElementNodeMixin Represents an LEGEND HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 class LEGEND ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LEGEND HTML <legend> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:legend = Element( ).set_attrs(**self.attributes).set_content(self.content).legend().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . legend () . element ) render () Blueprint:legend = Element( ).set_attrs(**self.attributes).set_content(self.content).legend().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 927 928 929 930 931 932 933 934 935 936 937 def render ( self ): ''' Blueprint:legend = Element( ).set_attrs(**self.attributes).set_content(self.content).legend().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . legend () . element ) LI Bases: BaseHTMLElement , ElementNodeMixin Represents an LI HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 class LI ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LI HTML <li> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:li = Element( ).set_attrs(**self.attributes).set_content(self.content).li().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . li () . element ) render () Blueprint:li = Element( ).set_attrs(**self.attributes).set_content(self.content).li().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 946 947 948 949 950 951 952 953 954 955 956 def render ( self ): ''' Blueprint:li = Element( ).set_attrs(**self.attributes).set_content(self.content).li().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . li () . element ) MAIN Bases: BaseHTMLElement , ElementNodeMixin Represents an MAIN HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 class MAIN ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MAIN HTML <main> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:main = Element( ).set_attrs(**self.attributes).set_content(self.content).main().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . main () . element ) render () Blueprint:main = Element( ).set_attrs(**self.attributes).set_content(self.content).main().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 965 966 967 968 969 970 971 972 973 974 975 def render ( self ): ''' Blueprint:main = Element( ).set_attrs(**self.attributes).set_content(self.content).main().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . main () . element ) MAP Bases: BaseHTMLElement , ElementNodeMixin Represents an MAP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 class MAP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MAP HTML <map> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:map = Element( ).set_attrs(**self.attributes).set_content(self.content).map().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Map () . element ) render () Blueprint:map = Element( ).set_attrs(**self.attributes).set_content(self.content).map().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 def render ( self ): ''' Blueprint:map = Element( ).set_attrs(**self.attributes).set_content(self.content).map().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Map () . element ) MARK Bases: BaseHTMLElement , ElementNodeMixin Represents an MARK HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 class MARK ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MARK HTML <mark> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:mark = Element( ).set_attrs(**self.attributes).set_content(self.content).mark().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . mark () . element ) render () Blueprint:mark = Element( ).set_attrs(**self.attributes).set_content(self.content).mark().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 def render ( self ): ''' Blueprint:mark = Element( ).set_attrs(**self.attributes).set_content(self.content).mark().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . mark () . element ) MATH Bases: BaseHTMLElement , ElementNodeMixin Represents an MATH HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 class MATH ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MATH HTML <math> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:math = Element( ).set_attrs(**self.attributes).set_content(self.content).math().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . math () . element ) render () Blueprint:math = Element( ).set_attrs(**self.attributes).set_content(self.content).math().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 984 985 986 987 988 989 990 991 992 993 994 def render ( self ): ''' Blueprint:math = Element( ).set_attrs(**self.attributes).set_content(self.content).math().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . math () . element ) MENU Bases: BaseHTMLElement , ElementNodeMixin Represents an MENU HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 class MENU ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MENU HTML <menu> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:menu = Element( ).set_attrs(**self.attributes).set_content(self.content).menu().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . menu () . element ) render () Blueprint:menu = Element( ).set_attrs(**self.attributes).set_content(self.content).menu().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 def render ( self ): ''' Blueprint:menu = Element( ).set_attrs(**self.attributes).set_content(self.content).menu().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . menu () . element ) METER Bases: BaseHTMLElement , ElementNodeMixin Represents an METER HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 class METER ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an METER HTML <meter> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:meter = Element( ).set_attrs(**self.attributes).set_content(self.content).meter().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . meter () . element ) render () Blueprint:meter = Element( ).set_attrs(**self.attributes).set_content(self.content).meter().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 def render ( self ): ''' Blueprint:meter = Element( ).set_attrs(**self.attributes).set_content(self.content).meter().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . meter () . element ) NAV Bases: BaseHTMLElement , ElementNodeMixin Represents an NAV HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 class NAV ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an NAV HTML <nav> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:nav = Element( ).set_attrs(**self.attributes).set_content(self.content).nav().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . nav () . element ) render () Blueprint:nav = Element( ).set_attrs(**self.attributes).set_content(self.content).nav().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 def render ( self ): ''' Blueprint:nav = Element( ).set_attrs(**self.attributes).set_content(self.content).nav().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . nav () . element ) NOSCRIPT Bases: BaseHTMLElement , ElementNodeMixin Represents an NOSCRIPT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 class NOSCRIPT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an NOSCRIPT HTML <noscript> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:noscript = Element( ).set_attrs(**self.attributes).set_content(self.content).noscript().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . noscript () . element ) render () Blueprint:noscript = Element( ).set_attrs(**self.attributes).set_content(self.content).noscript().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 def render ( self ): ''' Blueprint:noscript = Element( ).set_attrs(**self.attributes).set_content(self.content).noscript().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . noscript () . element ) OBJECT Bases: BaseHTMLElement , ElementNodeMixin Represents an OBJECT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 class OBJECT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OBJECT HTML <object> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:object = Element( ).set_attrs(**self.attributes).set_content(self.content).object().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . object () . element ) render () Blueprint:object = Element( ).set_attrs(**self.attributes).set_content(self.content).object().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 def render ( self ): ''' Blueprint:object = Element( ).set_attrs(**self.attributes).set_content(self.content).object().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . object () . element ) OL Bases: BaseHTMLElement , ElementNodeMixin Represents an OL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 class OL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OL HTML <ol> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:ol = Element( ).set_attrs(**self.attributes).set_content(self.content).ol().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ol () . element ) render () Blueprint:ol = Element( ).set_attrs(**self.attributes).set_content(self.content).ol().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 def render ( self ): ''' Blueprint:ol = Element( ).set_attrs(**self.attributes).set_content(self.content).ol().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ol () . element ) OPTGROUP Bases: BaseHTMLElement , ElementNodeMixin Represents an OPTGROUP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 class OPTGROUP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OPTGROUP HTML <optgroup> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:optgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).optgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . optgroup () . element ) render () Blueprint:optgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).optgroup().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 def render ( self ): ''' Blueprint:optgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).optgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . optgroup () . element ) OPTION Bases: BaseHTMLElement , ElementNodeMixin Represents an OPTION HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 class OPTION ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OPTION HTML <option> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:option = Element( ).set_attrs(**self.attributes).set_content(self.content).option().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . option () . element ) render () Blueprint:option = Element( ).set_attrs(**self.attributes).set_content(self.content).option().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 def render ( self ): ''' Blueprint:option = Element( ).set_attrs(**self.attributes).set_content(self.content).option().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . option () . element ) OUTPUT Bases: BaseHTMLElement , ElementNodeMixin Represents an OUTPUT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 class OUTPUT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OUTPUT HTML <output> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:output = Element( ).set_attrs(**self.attributes).set_content(self.content).output().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . output () . element ) render () Blueprint:output = Element( ).set_attrs(**self.attributes).set_content(self.content).output().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 def render ( self ): ''' Blueprint:output = Element( ).set_attrs(**self.attributes).set_content(self.content).output().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . output () . element ) P Bases: BaseHTMLElement , ElementNodeMixin Represents an P HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 class P ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an P HTML <p> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:p = Element( ).set_attrs(**self.attributes).set_content(self.content).p().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . p () . element ) render () Blueprint:p = Element( ).set_attrs(**self.attributes).set_content(self.content).p().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 def render ( self ): ''' Blueprint:p = Element( ).set_attrs(**self.attributes).set_content(self.content).p().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . p () . element ) PICTURE Bases: BaseHTMLElement , ElementNodeMixin Represents an PICTURE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 class PICTURE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PICTURE HTML <picture> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:picture = Element( ).set_attrs(**self.attributes).set_content(self.content).picture().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . picture () . element ) render () Blueprint:picture = Element( ).set_attrs(**self.attributes).set_content(self.content).picture().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 def render ( self ): ''' Blueprint:picture = Element( ).set_attrs(**self.attributes).set_content(self.content).picture().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . picture () . element ) PORTAL Bases: BaseHTMLElement , ElementNodeMixin Represents an PORTAL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 class PORTAL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PORTAL HTML <portal> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:portal = Element( ).set_attrs(**self.attributes).set_content(self.content).portal().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . portal () . element ) render () Blueprint:portal = Element( ).set_attrs(**self.attributes).set_content(self.content).portal().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 def render ( self ): ''' Blueprint:portal = Element( ).set_attrs(**self.attributes).set_content(self.content).portal().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . portal () . element ) PRE Bases: BaseHTMLElement , ElementNodeMixin Represents an PRE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 class PRE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PRE HTML <pre> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:pre = Element( ).set_attrs(**self.attributes).set_content(self.content).pre().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . pre () . element ) render () Blueprint:pre = Element( ).set_attrs(**self.attributes).set_content(self.content).pre().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 def render ( self ): ''' Blueprint:pre = Element( ).set_attrs(**self.attributes).set_content(self.content).pre().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . pre () . element ) PROGRESS Bases: BaseHTMLElement , ElementNodeMixin Represents an PROGRESS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 class PROGRESS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PROGRESS HTML <progress> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:progress = Element( ).set_attrs(**self.attributes).set_content(self.content).progress().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . progress () . element ) render () Blueprint:progress = Element( ).set_attrs(**self.attributes).set_content(self.content).progress().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 def render ( self ): ''' Blueprint:progress = Element( ).set_attrs(**self.attributes).set_content(self.content).progress().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . progress () . element ) Q Bases: BaseHTMLElement , ElementNodeMixin Represents an Q HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 class Q ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an Q HTML <q> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:q = Element( ).set_attrs(**self.attributes).set_content(self.content).q().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . q () . element ) render () Blueprint:q = Element( ).set_attrs(**self.attributes).set_content(self.content).q().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 def render ( self ): ''' Blueprint:q = Element( ).set_attrs(**self.attributes).set_content(self.content).q().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . q () . element ) RP Bases: BaseHTMLElement , ElementNodeMixin Represents an RP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 class RP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RP HTML <rp> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:rp = Element( ).set_attrs(**self.attributes).set_content(self.content).rp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rp () . element ) render () Blueprint:rp = Element( ).set_attrs(**self.attributes).set_content(self.content).rp().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 def render ( self ): ''' Blueprint:rp = Element( ).set_attrs(**self.attributes).set_content(self.content).rp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rp () . element ) RT Bases: BaseHTMLElement , ElementNodeMixin Represents an RT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 class RT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RT HTML <rt> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:rt = Element( ).set_attrs(**self.attributes).set_content(self.content).rt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rt () . element ) render () Blueprint:rt = Element( ).set_attrs(**self.attributes).set_content(self.content).rt().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 def render ( self ): ''' Blueprint:rt = Element( ).set_attrs(**self.attributes).set_content(self.content).rt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rt () . element ) RUBY Bases: BaseHTMLElement , ElementNodeMixin Represents an RUBY HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 class RUBY ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RUBY HTML <ruby> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:ruby = Element( ).set_attrs(**self.attributes).set_content(self.content).ruby().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ruby () . element ) render () Blueprint:ruby = Element( ).set_attrs(**self.attributes).set_content(self.content).ruby().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 def render ( self ): ''' Blueprint:ruby = Element( ).set_attrs(**self.attributes).set_content(self.content).ruby().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ruby () . element ) S Bases: BaseHTMLElement , ElementNodeMixin Represents an S HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 class S ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an S HTML <s> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:s = Element( ).set_attrs(**self.attributes).set_content(self.content).s().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . s () . element ) render () Blueprint:s = Element( ).set_attrs(**self.attributes).set_content(self.content).s().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 def render ( self ): ''' Blueprint:s = Element( ).set_attrs(**self.attributes).set_content(self.content).s().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . s () . element ) SAMP Bases: BaseHTMLElement , ElementNodeMixin Represents an SAMP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 class SAMP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an SAMP HTML <samp> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:samp = Element( ).set_attrs(**self.attributes).set_content(self.content).samp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . samp () . element ) render () Blueprint:samp = Element( ).set_attrs(**self.attributes).set_content(self.content).samp().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 def render ( self ): ''' Blueprint:samp = Element( ).set_attrs(**self.attributes).set_content(self.content).samp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . samp () . element ) SCRIPT Bases: BaseHTMLElement , ElementNodeMixin Represents an SCRIPT HTML","title":"block_tags"},{"location":"reference/probo/components/tag_classes/block_tags/#block_tags","text":"","title":"block_tags"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.A","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an A HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class A ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an A HTML <a> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:a = Element( ).set_attrs(**self.attributes).set_content(self.content).a().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . a () . element )","title":"A"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.A.render","text":"Blueprint:a = Element( ).set_attrs(**self.attributes).set_content(self.content).a().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 15 16 17 18 19 20 21 22 23 24 25 def render ( self ): ''' Blueprint:a = Element( ).set_attrs(**self.attributes).set_content(self.content).a().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . a () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ABBR","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an ABBR HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class ABBR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ABBR HTML <abbr> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:abbr = Element( ).set_attrs(**self.attributes).set_content(self.content).abbr().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . abbr () . element )","title":"ABBR"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ABBR.render","text":"Blueprint:abbr = Element( ).set_attrs(**self.attributes).set_content(self.content).abbr().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 34 35 36 37 38 39 40 41 42 43 44 def render ( self ): ''' Blueprint:abbr = Element( ).set_attrs(**self.attributes).set_content(self.content).abbr().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . abbr () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ADDRESS","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an ADDRESS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class ADDRESS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ADDRESS HTML <address> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:address = Element( ).set_attrs(**self.attributes).set_content(self.content).address().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . address () . element )","title":"ADDRESS"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ADDRESS.render","text":"Blueprint:address = Element( ).set_attrs(**self.attributes).set_content(self.content).address().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 53 54 55 56 57 58 59 60 61 62 63 def render ( self ): ''' Blueprint:address = Element( ).set_attrs(**self.attributes).set_content(self.content).address().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . address () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ARTICLE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an ARTICLE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 class ARTICLE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ARTICLE HTML <article> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:article = Element( ).set_attrs(**self.attributes).set_content(self.content).article().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . article () . element )","title":"ARTICLE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ARTICLE.render","text":"Blueprint:article = Element( ).set_attrs(**self.attributes).set_content(self.content).article().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 72 73 74 75 76 77 78 79 80 81 82 def render ( self ): ''' Blueprint:article = Element( ).set_attrs(**self.attributes).set_content(self.content).article().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . article () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ASIDE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an ASIDE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 class ASIDE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an ASIDE HTML <aside> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:aside = Element( ).set_attrs(**self.attributes).set_content(self.content).aside().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . aside () . element )","title":"ASIDE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.ASIDE.render","text":"Blueprint:aside = Element( ).set_attrs(**self.attributes).set_content(self.content).aside().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 91 92 93 94 95 96 97 98 99 100 101 def render ( self ): ''' Blueprint:aside = Element( ).set_attrs(**self.attributes).set_content(self.content).aside().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . aside () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.AUDIO","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an AUDIO HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 class AUDIO ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an AUDIO HTML <audio> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:audio = Element( ).set_attrs(**self.attributes).set_content(self.content).audio().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . audio () . element )","title":"AUDIO"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.AUDIO.render","text":"Blueprint:audio = Element( ).set_attrs(**self.attributes).set_content(self.content).audio().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 110 111 112 113 114 115 116 117 118 119 120 def render ( self ): ''' Blueprint:audio = Element( ).set_attrs(**self.attributes).set_content(self.content).audio().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . audio () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.B","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an B HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class B ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an B HTML <b> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:b = Element( ).set_attrs(**self.attributes).set_content(self.content).b().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . b () . element )","title":"B"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.B.render","text":"Blueprint:b = Element( ).set_attrs(**self.attributes).set_content(self.content).b().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 129 130 131 132 133 134 135 136 137 138 139 def render ( self ): ''' Blueprint:b = Element( ).set_attrs(**self.attributes).set_content(self.content).b().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . b () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BDI","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BDI HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 class BDI ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BDI HTML <bdi> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:bdi = Element( ).set_attrs(**self.attributes).set_content(self.content).bdi().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdi () . element )","title":"BDI"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BDI.render","text":"Blueprint:bdi = Element( ).set_attrs(**self.attributes).set_content(self.content).bdi().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 148 149 150 151 152 153 154 155 156 157 158 def render ( self ): ''' Blueprint:bdi = Element( ).set_attrs(**self.attributes).set_content(self.content).bdi().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdi () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BDO","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BDO HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 class BDO ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BDO HTML <bdo> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:bdo = Element( ).set_attrs(**self.attributes).set_content(self.content).bdo().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdo () . element )","title":"BDO"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BDO.render","text":"Blueprint:bdo = Element( ).set_attrs(**self.attributes).set_content(self.content).bdo().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 167 168 169 170 171 172 173 174 175 176 177 def render ( self ): ''' Blueprint:bdo = Element( ).set_attrs(**self.attributes).set_content(self.content).bdo().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . bdo () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BLOCKQUOTE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BLOCKQUOTE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 class BLOCKQUOTE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BLOCKQUOTE HTML <blockquote> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:blockquote = Element( ).set_attrs(**self.attributes).set_content(self.content).blockquote().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . blockquote () . element )","title":"BLOCKQUOTE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BLOCKQUOTE.render","text":"Blueprint:blockquote = Element( ).set_attrs(**self.attributes).set_content(self.content).blockquote().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 186 187 188 189 190 191 192 193 194 195 196 def render ( self ): ''' Blueprint:blockquote = Element( ).set_attrs(**self.attributes).set_content(self.content).blockquote().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . blockquote () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BODY","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BODY HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 class BODY ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BODY HTML <body> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:body = Element( ).set_attrs(**self.attributes).set_content(self.content).body().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . body () . element )","title":"BODY"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BODY.render","text":"Blueprint:body = Element( ).set_attrs(**self.attributes).set_content(self.content).body().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 205 206 207 208 209 210 211 212 213 214 215 def render ( self ): ''' Blueprint:body = Element( ).set_attrs(**self.attributes).set_content(self.content).body().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . body () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BUTTON","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BUTTON HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 class BUTTON ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BUTTON HTML <button> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:button = Element( ).set_attrs(**self.attributes).set_content(self.content).button().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . button () . element )","title":"BUTTON"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.BUTTON.render","text":"Blueprint:button = Element( ).set_attrs(**self.attributes).set_content(self.content).button().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 224 225 226 227 228 229 230 231 232 233 234 def render ( self ): ''' Blueprint:button = Element( ).set_attrs(**self.attributes).set_content(self.content).button().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . button () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CANVAS","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an CANVAS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 class CANVAS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CANVAS HTML <canvas> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:canvas = Element( ).set_attrs(**self.attributes).set_content(self.content).canvas().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . canvas () . element )","title":"CANVAS"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CANVAS.render","text":"Blueprint:canvas = Element( ).set_attrs(**self.attributes).set_content(self.content).canvas().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 243 244 245 246 247 248 249 250 251 252 253 def render ( self ): ''' Blueprint:canvas = Element( ).set_attrs(**self.attributes).set_content(self.content).canvas().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . canvas () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CAPTION","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an CAPTION HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 class CAPTION ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CAPTION HTML <caption> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:caption = Element( ).set_attrs(**self.attributes).set_content(self.content).caption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . caption () . element )","title":"CAPTION"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CAPTION.render","text":"Blueprint:caption = Element( ).set_attrs(**self.attributes).set_content(self.content).caption().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 262 263 264 265 266 267 268 269 270 271 272 def render ( self ): ''' Blueprint:caption = Element( ).set_attrs(**self.attributes).set_content(self.content).caption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . caption () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CITE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an CITE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 class CITE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CITE HTML <cite> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:cite = Element( ).set_attrs(**self.attributes).set_content(self.content).cite().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . cite () . element )","title":"CITE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CITE.render","text":"Blueprint:cite = Element( ).set_attrs(**self.attributes).set_content(self.content).cite().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 281 282 283 284 285 286 287 288 289 290 291 def render ( self ): ''' Blueprint:cite = Element( ).set_attrs(**self.attributes).set_content(self.content).cite().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . cite () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CODE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an CODE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 class CODE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CODE HTML <code> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:code = Element( ).set_attrs(**self.attributes).set_content(self.content).code().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . code () . element )","title":"CODE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.CODE.render","text":"Blueprint:code = Element( ).set_attrs(**self.attributes).set_content(self.content).code().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 300 301 302 303 304 305 306 307 308 309 310 def render ( self ): ''' Blueprint:code = Element( ).set_attrs(**self.attributes).set_content(self.content).code().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . code () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.COLGROUP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an COLGROUP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 class COLGROUP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an COLGROUP HTML <colgroup> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:colgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).colgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . colgroup () . element )","title":"COLGROUP"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.COLGROUP.render","text":"Blueprint:colgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).colgroup().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 319 320 321 322 323 324 325 326 327 328 329 def render ( self ): ''' Blueprint:colgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).colgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . colgroup () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DATA","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DATA HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 class DATA ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DATA HTML <data> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:data = Element( ).set_attrs(**self.attributes).set_content(self.content).data().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . data () . element )","title":"DATA"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DATA.render","text":"Blueprint:data = Element( ).set_attrs(**self.attributes).set_content(self.content).data().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 338 339 340 341 342 343 344 345 346 347 348 def render ( self ): ''' Blueprint:data = Element( ).set_attrs(**self.attributes).set_content(self.content).data().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . data () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DATALIST","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DATALIST HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 class DATALIST ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DATALIST HTML <datalist> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:datalist = Element( ).set_attrs(**self.attributes).set_content(self.content).datalist().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . datalist () . element )","title":"DATALIST"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DATALIST.render","text":"Blueprint:datalist = Element( ).set_attrs(**self.attributes).set_content(self.content).datalist().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 357 358 359 360 361 362 363 364 365 366 367 def render ( self ): ''' Blueprint:datalist = Element( ).set_attrs(**self.attributes).set_content(self.content).datalist().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . datalist () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DD","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DD HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class DD ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DD HTML <dd> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dd = Element( ).set_attrs(**self.attributes).set_content(self.content).dd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dd () . element )","title":"DD"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DD.render","text":"Blueprint:dd = Element( ).set_attrs(**self.attributes).set_content(self.content).dd().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 376 377 378 379 380 381 382 383 384 385 386 def render ( self ): ''' Blueprint:dd = Element( ).set_attrs(**self.attributes).set_content(self.content).dd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dd () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DEFS","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DEFS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1966 1967 1968 1969 1970 1971 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 class DEFS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DEFS HTML <defs> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:defs = Element( ).set_attrs(**self.attributes).set_content(self.content).defs().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . defs () . element )","title":"DEFS"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DEFS.render","text":"Blueprint:defs = Element( ).set_attrs(**self.attributes).set_content(self.content).defs().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1972 1973 1974 1975 1976 1977 1978 1979 1980 1981 1982 def render ( self ): ''' Blueprint:defs = Element( ).set_attrs(**self.attributes).set_content(self.content).defs().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . defs () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DEL","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DEL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 class DEL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DEL HTML <del> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:del = Element( ).set_attrs(**self.attributes).set_content(self.content).del().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Del () . element )","title":"DEL"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DEL.render","text":"Blueprint:del = Element( ).set_attrs(**self.attributes).set_content(self.content).del().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 395 396 397 398 399 400 401 402 403 404 405 def render ( self ): ''' Blueprint:del = Element( ).set_attrs(**self.attributes).set_content(self.content).del().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Del () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DETAILS","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DETAILS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 class DETAILS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DETAILS HTML <details> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:details = Element( ).set_attrs(**self.attributes).set_content(self.content).details().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . details () . element )","title":"DETAILS"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DETAILS.render","text":"Blueprint:details = Element( ).set_attrs(**self.attributes).set_content(self.content).details().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 414 415 416 417 418 419 420 421 422 423 424 def render ( self ): ''' Blueprint:details = Element( ).set_attrs(**self.attributes).set_content(self.content).details().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . details () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DFN","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DFN HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 class DFN ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DFN HTML <dfn> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dfn = Element( ).set_attrs(**self.attributes).set_content(self.content).dfn().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dfn () . element )","title":"DFN"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DFN.render","text":"Blueprint:dfn = Element( ).set_attrs(**self.attributes).set_content(self.content).dfn().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 433 434 435 436 437 438 439 440 441 442 443 def render ( self ): ''' Blueprint:dfn = Element( ).set_attrs(**self.attributes).set_content(self.content).dfn().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dfn () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DIALOG","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DIALOG HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 class DIALOG ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DIALOG HTML <dialog> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dialog = Element( ).set_attrs(**self.attributes).set_content(self.content).dialog().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dialog () . element )","title":"DIALOG"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DIALOG.render","text":"Blueprint:dialog = Element( ).set_attrs(**self.attributes).set_content(self.content).dialog().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 452 453 454 455 456 457 458 459 460 461 462 def render ( self ): ''' Blueprint:dialog = Element( ).set_attrs(**self.attributes).set_content(self.content).dialog().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dialog () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DIV","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DIV HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 class DIV ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DIV HTML <div> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:div = Element( ).set_attrs(**self.attributes).set_content(self.content).div().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . div () . element )","title":"DIV"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DIV.render","text":"Blueprint:div = Element( ).set_attrs(**self.attributes).set_content(self.content).div().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 471 472 473 474 475 476 477 478 479 480 481 def render ( self ): ''' Blueprint:div = Element( ).set_attrs(**self.attributes).set_content(self.content).div().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . div () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DL","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 class DL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DL HTML <dl> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dl = Element( ).set_attrs(**self.attributes).set_content(self.content).dl().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dl () . element )","title":"DL"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DL.render","text":"Blueprint:dl = Element( ).set_attrs(**self.attributes).set_content(self.content).dl().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 490 491 492 493 494 495 496 497 498 499 500 def render ( self ): ''' Blueprint:dl = Element( ).set_attrs(**self.attributes).set_content(self.content).dl().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dl () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 class DT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DT HTML <dt> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:dt = Element( ).set_attrs(**self.attributes).set_content(self.content).dt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dt () . element )","title":"DT"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.DT.render","text":"Blueprint:dt = Element( ).set_attrs(**self.attributes).set_content(self.content).dt().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 509 510 511 512 513 514 515 516 517 518 519 def render ( self ): ''' Blueprint:dt = Element( ).set_attrs(**self.attributes).set_content(self.content).dt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . dt () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.EM","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an EM HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 class EM ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an EM HTML <em> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:em = Element( ).set_attrs(**self.attributes).set_content(self.content).em().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . em () . element )","title":"EM"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.EM.render","text":"Blueprint:em = Element( ).set_attrs(**self.attributes).set_content(self.content).em().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 528 529 530 531 532 533 534 535 536 537 538 def render ( self ): ''' Blueprint:em = Element( ).set_attrs(**self.attributes).set_content(self.content).em().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . em () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FIELDSET","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an FIELDSET HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 class FIELDSET ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FIELDSET HTML <fieldset> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:fieldset = Element( ).set_attrs(**self.attributes).set_content(self.content).fieldset().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . fieldset () . element )","title":"FIELDSET"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FIELDSET.render","text":"Blueprint:fieldset = Element( ).set_attrs(**self.attributes).set_content(self.content).fieldset().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 547 548 549 550 551 552 553 554 555 556 557 def render ( self ): ''' Blueprint:fieldset = Element( ).set_attrs(**self.attributes).set_content(self.content).fieldset().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . fieldset () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FIGCAPTION","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an FIGCAPTION HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 class FIGCAPTION ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FIGCAPTION HTML <figcaption> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:figcaption = Element( ).set_attrs(**self.attributes).set_content(self.content).figcaption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figcaption () . element )","title":"FIGCAPTION"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FIGCAPTION.render","text":"Blueprint:figcaption = Element( ).set_attrs(**self.attributes).set_content(self.content).figcaption().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 566 567 568 569 570 571 572 573 574 575 576 def render ( self ): ''' Blueprint:figcaption = Element( ).set_attrs(**self.attributes).set_content(self.content).figcaption().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figcaption () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FIGURE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an FIGURE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 class FIGURE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FIGURE HTML <figure> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:figure = Element( ).set_attrs(**self.attributes).set_content(self.content).figure().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figure () . element )","title":"FIGURE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FIGURE.render","text":"Blueprint:figure = Element( ).set_attrs(**self.attributes).set_content(self.content).figure().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 585 586 587 588 589 590 591 592 593 594 595 def render ( self ): ''' Blueprint:figure = Element( ).set_attrs(**self.attributes).set_content(self.content).figure().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . figure () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FOOTER","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an FOOTER HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 class FOOTER ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FOOTER HTML <footer> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:footer = Element( ).set_attrs(**self.attributes).set_content(self.content).footer().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . footer () . element )","title":"FOOTER"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FOOTER.render","text":"Blueprint:footer = Element( ).set_attrs(**self.attributes).set_content(self.content).footer().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 604 605 606 607 608 609 610 611 612 613 614 def render ( self ): ''' Blueprint:footer = Element( ).set_attrs(**self.attributes).set_content(self.content).footer().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . footer () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FORM","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an FORM HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 class FORM ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an FORM HTML <form> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:form = Element( ).set_attrs(**self.attributes).set_content(self.content).form().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . form () . element )","title":"FORM"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.FORM.render","text":"Blueprint:form = Element( ).set_attrs(**self.attributes).set_content(self.content).form().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 623 624 625 626 627 628 629 630 631 632 633 def render ( self ): ''' Blueprint:form = Element( ).set_attrs(**self.attributes).set_content(self.content).form().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . form () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.G","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an G HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1947 1948 1949 1950 1951 1952 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 class G ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an G HTML <g> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:g = Element( ).set_attrs(**self.attributes).set_content(self.content).g().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . g () . element )","title":"G"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.G.render","text":"Blueprint:g = Element( ).set_attrs(**self.attributes).set_content(self.content).g().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1953 1954 1955 1956 1957 1958 1959 1960 1961 1962 1963 def render ( self ): ''' Blueprint:g = Element( ).set_attrs(**self.attributes).set_content(self.content).g().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . g () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H1","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an H1 HTML","title":"H1"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H1.render","text":"Blueprint:h1 = Element( ).set_attrs(**self.attributes).set_content(self.content).h1().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 642 643 644 645 646 647 648 649 650 651 652 def render ( self ): ''' Blueprint:h1 = Element( ).set_attrs(**self.attributes).set_content(self.content).h1().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h1 () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H2","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an H2 HTML","title":"H2"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H2.render","text":"Blueprint:h2 = Element( ).set_attrs(**self.attributes).set_content(self.content).h2().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 661 662 663 664 665 666 667 668 669 670 671 def render ( self ): ''' Blueprint:h2 = Element( ).set_attrs(**self.attributes).set_content(self.content).h2().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h2 () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H3","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an H3 HTML","title":"H3"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H3.render","text":"Blueprint:h3 = Element( ).set_attrs(**self.attributes).set_content(self.content).h3().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 680 681 682 683 684 685 686 687 688 689 690 def render ( self ): ''' Blueprint:h3 = Element( ).set_attrs(**self.attributes).set_content(self.content).h3().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h3 () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H4","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an H4 HTML","title":"H4"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H4.render","text":"Blueprint:h4 = Element( ).set_attrs(**self.attributes).set_content(self.content).h4().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 699 700 701 702 703 704 705 706 707 708 709 def render ( self ): ''' Blueprint:h4 = Element( ).set_attrs(**self.attributes).set_content(self.content).h4().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h4 () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H5","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an H5 HTML","title":"H5"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H5.render","text":"Blueprint:h5 = Element( ).set_attrs(**self.attributes).set_content(self.content).h5().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 718 719 720 721 722 723 724 725 726 727 728 def render ( self ): ''' Blueprint:h5 = Element( ).set_attrs(**self.attributes).set_content(self.content).h5().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h5 () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H6","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an H6 HTML","title":"H6"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.H6.render","text":"Blueprint:h6 = Element( ).set_attrs(**self.attributes).set_content(self.content).h6().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 737 738 739 740 741 742 743 744 745 746 747 def render ( self ): ''' Blueprint:h6 = Element( ).set_attrs(**self.attributes).set_content(self.content).h6().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . h6 () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HEAD","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an HEAD HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 750 751 752 753 754 755 756 757 758 759 760 761 762 763 764 765 766 class HEAD ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HEAD HTML <head> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:head = Element( ).set_attrs(**self.attributes).set_content(self.content).head().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . head () . element )","title":"HEAD"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HEAD.render","text":"Blueprint:head = Element( ).set_attrs(**self.attributes).set_content(self.content).head().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 756 757 758 759 760 761 762 763 764 765 766 def render ( self ): ''' Blueprint:head = Element( ).set_attrs(**self.attributes).set_content(self.content).head().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . head () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HEADER","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an HEADER HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 769 770 771 772 773 774 775 776 777 778 779 780 781 782 783 784 785 class HEADER ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HEADER HTML <header> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:header = Element( ).set_attrs(**self.attributes).set_content(self.content).header().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . header () . element )","title":"HEADER"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HEADER.render","text":"Blueprint:header = Element( ).set_attrs(**self.attributes).set_content(self.content).header().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 775 776 777 778 779 780 781 782 783 784 785 def render ( self ): ''' Blueprint:header = Element( ).set_attrs(**self.attributes).set_content(self.content).header().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . header () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HGROUP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an HGROUP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 788 789 790 791 792 793 794 795 796 797 798 799 800 801 802 803 804 class HGROUP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HGROUP HTML <hgroup> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:hgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).hgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . hgroup () . element )","title":"HGROUP"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HGROUP.render","text":"Blueprint:hgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).hgroup().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 794 795 796 797 798 799 800 801 802 803 804 def render ( self ): ''' Blueprint:hgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).hgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . hgroup () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HTML","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an HTML HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 807 808 809 810 811 812 813 814 815 816 817 818 819 820 821 822 823 class HTML ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HTML HTML <html> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:html = Element( ).set_attrs(**self.attributes).set_content(self.content).html().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . html () . element )","title":"HTML"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.HTML.render","text":"Blueprint:html = Element( ).set_attrs(**self.attributes).set_content(self.content).html().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 813 814 815 816 817 818 819 820 821 822 823 def render ( self ): ''' Blueprint:html = Element( ).set_attrs(**self.attributes).set_content(self.content).html().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . html () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.I","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an I HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 826 827 828 829 830 831 832 833 834 835 836 837 838 839 840 841 842 class I ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an I HTML <i> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:i = Element( ).set_attrs(**self.attributes).set_content(self.content).i().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . i () . element )","title":"I"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.I.render","text":"Blueprint:i = Element( ).set_attrs(**self.attributes).set_content(self.content).i().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 832 833 834 835 836 837 838 839 840 841 842 def render ( self ): ''' Blueprint:i = Element( ).set_attrs(**self.attributes).set_content(self.content).i().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . i () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.IFRAME","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an IFRAME HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 845 846 847 848 849 850 851 852 853 854 855 856 857 858 859 860 861 class IFRAME ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an IFRAME HTML <iframe> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:iframe = Element( ).set_attrs(**self.attributes).set_content(self.content).iframe().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . iframe () . element )","title":"IFRAME"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.IFRAME.render","text":"Blueprint:iframe = Element( ).set_attrs(**self.attributes).set_content(self.content).iframe().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 851 852 853 854 855 856 857 858 859 860 861 def render ( self ): ''' Blueprint:iframe = Element( ).set_attrs(**self.attributes).set_content(self.content).iframe().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . iframe () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.INS","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an INS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 864 865 866 867 868 869 870 871 872 873 874 875 876 877 878 879 880 class INS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an INS HTML <ins> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:ins = Element( ).set_attrs(**self.attributes).set_content(self.content).ins().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ins () . element )","title":"INS"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.INS.render","text":"Blueprint:ins = Element( ).set_attrs(**self.attributes).set_content(self.content).ins().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 870 871 872 873 874 875 876 877 878 879 880 def render ( self ): ''' Blueprint:ins = Element( ).set_attrs(**self.attributes).set_content(self.content).ins().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ins () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.KBD","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an KBD HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 883 884 885 886 887 888 889 890 891 892 893 894 895 896 897 898 899 class KBD ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an KBD HTML <kbd> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:kbd = Element( ).set_attrs(**self.attributes).set_content(self.content).kbd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . kbd () . element )","title":"KBD"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.KBD.render","text":"Blueprint:kbd = Element( ).set_attrs(**self.attributes).set_content(self.content).kbd().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 889 890 891 892 893 894 895 896 897 898 899 def render ( self ): ''' Blueprint:kbd = Element( ).set_attrs(**self.attributes).set_content(self.content).kbd().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . kbd () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.LABEL","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an LABEL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 902 903 904 905 906 907 908 909 910 911 912 913 914 915 916 917 918 class LABEL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LABEL HTML <label> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:label = Element( ).set_attrs(**self.attributes).set_content(self.content).label().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . label () . element )","title":"LABEL"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.LABEL.render","text":"Blueprint:label = Element( ).set_attrs(**self.attributes).set_content(self.content).label().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 908 909 910 911 912 913 914 915 916 917 918 def render ( self ): ''' Blueprint:label = Element( ).set_attrs(**self.attributes).set_content(self.content).label().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . label () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.LEGEND","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an LEGEND HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 921 922 923 924 925 926 927 928 929 930 931 932 933 934 935 936 937 class LEGEND ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LEGEND HTML <legend> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:legend = Element( ).set_attrs(**self.attributes).set_content(self.content).legend().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . legend () . element )","title":"LEGEND"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.LEGEND.render","text":"Blueprint:legend = Element( ).set_attrs(**self.attributes).set_content(self.content).legend().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 927 928 929 930 931 932 933 934 935 936 937 def render ( self ): ''' Blueprint:legend = Element( ).set_attrs(**self.attributes).set_content(self.content).legend().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . legend () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.LI","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an LI HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 940 941 942 943 944 945 946 947 948 949 950 951 952 953 954 955 956 class LI ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LI HTML <li> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:li = Element( ).set_attrs(**self.attributes).set_content(self.content).li().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . li () . element )","title":"LI"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.LI.render","text":"Blueprint:li = Element( ).set_attrs(**self.attributes).set_content(self.content).li().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 946 947 948 949 950 951 952 953 954 955 956 def render ( self ): ''' Blueprint:li = Element( ).set_attrs(**self.attributes).set_content(self.content).li().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . li () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MAIN","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an MAIN HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 959 960 961 962 963 964 965 966 967 968 969 970 971 972 973 974 975 class MAIN ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MAIN HTML <main> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:main = Element( ).set_attrs(**self.attributes).set_content(self.content).main().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . main () . element )","title":"MAIN"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MAIN.render","text":"Blueprint:main = Element( ).set_attrs(**self.attributes).set_content(self.content).main().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 965 966 967 968 969 970 971 972 973 974 975 def render ( self ): ''' Blueprint:main = Element( ).set_attrs(**self.attributes).set_content(self.content).main().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . main () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MAP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an MAP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 997 998 999 1000 1001 1002 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 class MAP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MAP HTML <map> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:map = Element( ).set_attrs(**self.attributes).set_content(self.content).map().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Map () . element )","title":"MAP"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MAP.render","text":"Blueprint:map = Element( ).set_attrs(**self.attributes).set_content(self.content).map().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1003 1004 1005 1006 1007 1008 1009 1010 1011 1012 1013 def render ( self ): ''' Blueprint:map = Element( ).set_attrs(**self.attributes).set_content(self.content).map().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . Map () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MARK","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an MARK HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1016 1017 1018 1019 1020 1021 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 class MARK ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MARK HTML <mark> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:mark = Element( ).set_attrs(**self.attributes).set_content(self.content).mark().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . mark () . element )","title":"MARK"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MARK.render","text":"Blueprint:mark = Element( ).set_attrs(**self.attributes).set_content(self.content).mark().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1022 1023 1024 1025 1026 1027 1028 1029 1030 1031 1032 def render ( self ): ''' Blueprint:mark = Element( ).set_attrs(**self.attributes).set_content(self.content).mark().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . mark () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MATH","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an MATH HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 978 979 980 981 982 983 984 985 986 987 988 989 990 991 992 993 994 class MATH ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MATH HTML <math> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:math = Element( ).set_attrs(**self.attributes).set_content(self.content).math().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . math () . element )","title":"MATH"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MATH.render","text":"Blueprint:math = Element( ).set_attrs(**self.attributes).set_content(self.content).math().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 984 985 986 987 988 989 990 991 992 993 994 def render ( self ): ''' Blueprint:math = Element( ).set_attrs(**self.attributes).set_content(self.content).math().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . math () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MENU","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an MENU HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1035 1036 1037 1038 1039 1040 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 class MENU ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an MENU HTML <menu> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:menu = Element( ).set_attrs(**self.attributes).set_content(self.content).menu().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . menu () . element )","title":"MENU"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.MENU.render","text":"Blueprint:menu = Element( ).set_attrs(**self.attributes).set_content(self.content).menu().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1041 1042 1043 1044 1045 1046 1047 1048 1049 1050 1051 def render ( self ): ''' Blueprint:menu = Element( ).set_attrs(**self.attributes).set_content(self.content).menu().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . menu () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.METER","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an METER HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1054 1055 1056 1057 1058 1059 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 class METER ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an METER HTML <meter> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:meter = Element( ).set_attrs(**self.attributes).set_content(self.content).meter().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . meter () . element )","title":"METER"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.METER.render","text":"Blueprint:meter = Element( ).set_attrs(**self.attributes).set_content(self.content).meter().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1060 1061 1062 1063 1064 1065 1066 1067 1068 1069 1070 def render ( self ): ''' Blueprint:meter = Element( ).set_attrs(**self.attributes).set_content(self.content).meter().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . meter () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.NAV","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an NAV HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1073 1074 1075 1076 1077 1078 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 class NAV ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an NAV HTML <nav> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:nav = Element( ).set_attrs(**self.attributes).set_content(self.content).nav().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . nav () . element )","title":"NAV"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.NAV.render","text":"Blueprint:nav = Element( ).set_attrs(**self.attributes).set_content(self.content).nav().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1079 1080 1081 1082 1083 1084 1085 1086 1087 1088 1089 def render ( self ): ''' Blueprint:nav = Element( ).set_attrs(**self.attributes).set_content(self.content).nav().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . nav () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.NOSCRIPT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an NOSCRIPT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1092 1093 1094 1095 1096 1097 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 class NOSCRIPT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an NOSCRIPT HTML <noscript> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:noscript = Element( ).set_attrs(**self.attributes).set_content(self.content).noscript().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . noscript () . element )","title":"NOSCRIPT"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.NOSCRIPT.render","text":"Blueprint:noscript = Element( ).set_attrs(**self.attributes).set_content(self.content).noscript().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1098 1099 1100 1101 1102 1103 1104 1105 1106 1107 1108 def render ( self ): ''' Blueprint:noscript = Element( ).set_attrs(**self.attributes).set_content(self.content).noscript().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . noscript () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OBJECT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an OBJECT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1111 1112 1113 1114 1115 1116 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 class OBJECT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OBJECT HTML <object> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:object = Element( ).set_attrs(**self.attributes).set_content(self.content).object().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . object () . element )","title":"OBJECT"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OBJECT.render","text":"Blueprint:object = Element( ).set_attrs(**self.attributes).set_content(self.content).object().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1117 1118 1119 1120 1121 1122 1123 1124 1125 1126 1127 def render ( self ): ''' Blueprint:object = Element( ).set_attrs(**self.attributes).set_content(self.content).object().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . object () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OL","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an OL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1130 1131 1132 1133 1134 1135 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 class OL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OL HTML <ol> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:ol = Element( ).set_attrs(**self.attributes).set_content(self.content).ol().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ol () . element )","title":"OL"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OL.render","text":"Blueprint:ol = Element( ).set_attrs(**self.attributes).set_content(self.content).ol().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1136 1137 1138 1139 1140 1141 1142 1143 1144 1145 1146 def render ( self ): ''' Blueprint:ol = Element( ).set_attrs(**self.attributes).set_content(self.content).ol().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ol () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OPTGROUP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an OPTGROUP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1149 1150 1151 1152 1153 1154 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 class OPTGROUP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OPTGROUP HTML <optgroup> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:optgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).optgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . optgroup () . element )","title":"OPTGROUP"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OPTGROUP.render","text":"Blueprint:optgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).optgroup().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1155 1156 1157 1158 1159 1160 1161 1162 1163 1164 1165 def render ( self ): ''' Blueprint:optgroup = Element( ).set_attrs(**self.attributes).set_content(self.content).optgroup().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . optgroup () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OPTION","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an OPTION HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1168 1169 1170 1171 1172 1173 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 class OPTION ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OPTION HTML <option> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:option = Element( ).set_attrs(**self.attributes).set_content(self.content).option().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . option () . element )","title":"OPTION"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OPTION.render","text":"Blueprint:option = Element( ).set_attrs(**self.attributes).set_content(self.content).option().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1174 1175 1176 1177 1178 1179 1180 1181 1182 1183 1184 def render ( self ): ''' Blueprint:option = Element( ).set_attrs(**self.attributes).set_content(self.content).option().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . option () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OUTPUT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an OUTPUT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1187 1188 1189 1190 1191 1192 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 class OUTPUT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an OUTPUT HTML <output> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:output = Element( ).set_attrs(**self.attributes).set_content(self.content).output().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . output () . element )","title":"OUTPUT"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.OUTPUT.render","text":"Blueprint:output = Element( ).set_attrs(**self.attributes).set_content(self.content).output().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1193 1194 1195 1196 1197 1198 1199 1200 1201 1202 1203 def render ( self ): ''' Blueprint:output = Element( ).set_attrs(**self.attributes).set_content(self.content).output().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . output () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.P","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an P HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1206 1207 1208 1209 1210 1211 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 class P ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an P HTML <p> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:p = Element( ).set_attrs(**self.attributes).set_content(self.content).p().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . p () . element )","title":"P"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.P.render","text":"Blueprint:p = Element( ).set_attrs(**self.attributes).set_content(self.content).p().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1212 1213 1214 1215 1216 1217 1218 1219 1220 1221 1222 def render ( self ): ''' Blueprint:p = Element( ).set_attrs(**self.attributes).set_content(self.content).p().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . p () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PICTURE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an PICTURE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1244 1245 1246 1247 1248 1249 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 class PICTURE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PICTURE HTML <picture> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:picture = Element( ).set_attrs(**self.attributes).set_content(self.content).picture().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . picture () . element )","title":"PICTURE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PICTURE.render","text":"Blueprint:picture = Element( ).set_attrs(**self.attributes).set_content(self.content).picture().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1250 1251 1252 1253 1254 1255 1256 1257 1258 1259 1260 def render ( self ): ''' Blueprint:picture = Element( ).set_attrs(**self.attributes).set_content(self.content).picture().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . picture () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PORTAL","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an PORTAL HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1225 1226 1227 1228 1229 1230 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 class PORTAL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PORTAL HTML <portal> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:portal = Element( ).set_attrs(**self.attributes).set_content(self.content).portal().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . portal () . element )","title":"PORTAL"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PORTAL.render","text":"Blueprint:portal = Element( ).set_attrs(**self.attributes).set_content(self.content).portal().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1231 1232 1233 1234 1235 1236 1237 1238 1239 1240 1241 def render ( self ): ''' Blueprint:portal = Element( ).set_attrs(**self.attributes).set_content(self.content).portal().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . portal () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PRE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an PRE HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1263 1264 1265 1266 1267 1268 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 class PRE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PRE HTML <pre> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:pre = Element( ).set_attrs(**self.attributes).set_content(self.content).pre().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . pre () . element )","title":"PRE"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PRE.render","text":"Blueprint:pre = Element( ).set_attrs(**self.attributes).set_content(self.content).pre().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1269 1270 1271 1272 1273 1274 1275 1276 1277 1278 1279 def render ( self ): ''' Blueprint:pre = Element( ).set_attrs(**self.attributes).set_content(self.content).pre().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . pre () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PROGRESS","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an PROGRESS HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1282 1283 1284 1285 1286 1287 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 class PROGRESS ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PROGRESS HTML <progress> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:progress = Element( ).set_attrs(**self.attributes).set_content(self.content).progress().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . progress () . element )","title":"PROGRESS"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.PROGRESS.render","text":"Blueprint:progress = Element( ).set_attrs(**self.attributes).set_content(self.content).progress().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1288 1289 1290 1291 1292 1293 1294 1295 1296 1297 1298 def render ( self ): ''' Blueprint:progress = Element( ).set_attrs(**self.attributes).set_content(self.content).progress().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . progress () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.Q","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an Q HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1301 1302 1303 1304 1305 1306 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 class Q ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an Q HTML <q> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:q = Element( ).set_attrs(**self.attributes).set_content(self.content).q().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . q () . element )","title":"Q"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.Q.render","text":"Blueprint:q = Element( ).set_attrs(**self.attributes).set_content(self.content).q().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1307 1308 1309 1310 1311 1312 1313 1314 1315 1316 1317 def render ( self ): ''' Blueprint:q = Element( ).set_attrs(**self.attributes).set_content(self.content).q().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . q () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.RP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an RP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1320 1321 1322 1323 1324 1325 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 class RP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RP HTML <rp> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:rp = Element( ).set_attrs(**self.attributes).set_content(self.content).rp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rp () . element )","title":"RP"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.RP.render","text":"Blueprint:rp = Element( ).set_attrs(**self.attributes).set_content(self.content).rp().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1326 1327 1328 1329 1330 1331 1332 1333 1334 1335 1336 def render ( self ): ''' Blueprint:rp = Element( ).set_attrs(**self.attributes).set_content(self.content).rp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rp () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.RT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an RT HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1339 1340 1341 1342 1343 1344 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 class RT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RT HTML <rt> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:rt = Element( ).set_attrs(**self.attributes).set_content(self.content).rt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rt () . element )","title":"RT"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.RT.render","text":"Blueprint:rt = Element( ).set_attrs(**self.attributes).set_content(self.content).rt().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1345 1346 1347 1348 1349 1350 1351 1352 1353 1354 1355 def render ( self ): ''' Blueprint:rt = Element( ).set_attrs(**self.attributes).set_content(self.content).rt().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . rt () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.RUBY","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an RUBY HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1358 1359 1360 1361 1362 1363 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 class RUBY ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RUBY HTML <ruby> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:ruby = Element( ).set_attrs(**self.attributes).set_content(self.content).ruby().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ruby () . element )","title":"RUBY"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.RUBY.render","text":"Blueprint:ruby = Element( ).set_attrs(**self.attributes).set_content(self.content).ruby().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1364 1365 1366 1367 1368 1369 1370 1371 1372 1373 1374 def render ( self ): ''' Blueprint:ruby = Element( ).set_attrs(**self.attributes).set_content(self.content).ruby().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . ruby () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.S","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an S HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1377 1378 1379 1380 1381 1382 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 class S ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an S HTML <s> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:s = Element( ).set_attrs(**self.attributes).set_content(self.content).s().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . s () . element )","title":"S"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.S.render","text":"Blueprint:s = Element( ).set_attrs(**self.attributes).set_content(self.content).s().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1383 1384 1385 1386 1387 1388 1389 1390 1391 1392 1393 def render ( self ): ''' Blueprint:s = Element( ).set_attrs(**self.attributes).set_content(self.content).s().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . s () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.SAMP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an SAMP HTML element. Source code in src\\probo\\components\\tag_classes\\block_tags.py 1396 1397 1398 1399 1400 1401 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 class SAMP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an SAMP HTML <samp> element.\"\"\" def __init__ ( self , * content , ** attrs ): super () . __init__ ( * content , ** attrs ) def render ( self ): ''' Blueprint:samp = Element( ).set_attrs(**self.attributes).set_content(self.content).samp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . samp () . element )","title":"SAMP"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.SAMP.render","text":"Blueprint:samp = Element( ).set_attrs(**self.attributes).set_content(self.content).samp().element Source code in src\\probo\\components\\tag_classes\\block_tags.py 1402 1403 1404 1405 1406 1407 1408 1409 1410 1411 1412 def render ( self ): ''' Blueprint:samp = Element( ).set_attrs(**self.attributes).set_content(self.content).samp().element''' return ( Element () . set_attrs ( ** self . attributes ) . set_content ( self . _get_rendered_content ()) . samp () . element )","title":"render"},{"location":"reference/probo/components/tag_classes/block_tags/#probo.components.tag_classes.block_tags.SCRIPT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an SCRIPT HTML","title":"SCRIPT"},{"location":"reference/probo/components/tag_classes/self_closing/","text":"self_closing AREA Bases: BaseHTMLElement , ElementNodeMixin Represents an AREA HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 19 20 21 22 23 24 25 26 class AREA ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an AREA HTML <area> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . area () . element BASE Bases: BaseHTMLElement , ElementNodeMixin Represents an BASE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 29 30 31 32 33 34 35 36 class BASE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BASE HTML <base> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . base () . element BR Bases: BaseHTMLElement , ElementNodeMixin Represents an BR HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 39 40 41 42 43 44 45 46 class BR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BR HTML <br> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . br () . element CIRCLE Bases: BaseHTMLElement , ElementNodeMixin Represents an CIRCLE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 169 170 171 172 173 174 175 176 class CIRCLE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CIRCLE HTML <circle> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . circle () . element COL Bases: BaseHTMLElement , ElementNodeMixin Represents an COL HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 49 50 51 52 53 54 55 56 class COL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an COL HTML <col> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . col () . element DOCTYPE Bases: BaseHTMLElement , ElementNodeMixin Represents an DOCTYPE HTML <!> line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 9 10 11 12 13 14 15 16 class DOCTYPE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DOCTYPE HTML <!> line break element (self-closing).\"\"\" def __init__ ( self , content = None , ** kwargs ): super () . __init__ ( content , ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . doctype () . element EMBED Bases: BaseHTMLElement , ElementNodeMixin Represents an EMBED HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 59 60 61 62 63 64 65 66 class EMBED ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an EMBED HTML <embed> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . embed () . element HR Bases: BaseHTMLElement , ElementNodeMixin Represents an HR HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 69 70 71 72 73 74 75 76 class HR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HR HTML <hr> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . hr () . element IMG Bases: BaseHTMLElement , ElementNodeMixin Represents an IMG HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 79 80 81 82 83 84 85 86 class IMG ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an IMG HTML <img> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . img () . element INPUT Bases: BaseHTMLElement , ElementNodeMixin Represents an INPUT HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 89 90 91 92 93 94 95 96 class INPUT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an INPUT HTML <input> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . input () . element LINE Bases: BaseHTMLElement , ElementNodeMixin Represents an LINE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 189 190 191 192 193 194 195 196 class LINE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LINE HTML <line> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . line () . element LINK Bases: BaseHTMLElement , ElementNodeMixin Represents an LINK HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 99 100 101 102 103 104 105 106 class LINK ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LINK HTML <link> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . link () . element META Bases: BaseHTMLElement , ElementNodeMixin Represents an META HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 109 110 111 112 113 114 115 116 class META ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an META HTML <meta> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . meta () . element PARAM Bases: BaseHTMLElement , ElementNodeMixin Represents an PARAM HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 119 120 121 122 123 124 125 126 class PARAM ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PARAM HTML <param> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . param () . element PATH Bases: BaseHTMLElement , ElementNodeMixin Represents an PATH HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 159 160 161 162 163 164 165 166 class PATH ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PATH HTML <path> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . path () . element POLYGON Bases: BaseHTMLElement , ElementNodeMixin Represents an POLYGON HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 209 210 211 212 213 214 215 216 class POLYGON ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an POLYGON HTML <polygon> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . polygon () . element POLYLINE Bases: BaseHTMLElement , ElementNodeMixin Represents an POLYLINE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 199 200 201 202 203 204 205 206 class POLYLINE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an POLYLINE HTML <polyline> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . polyline () . element RECT Bases: BaseHTMLElement , ElementNodeMixin Represents an RECT HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 179 180 181 182 183 184 185 186 class RECT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RECT HTML <rect> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . rect () . element SOURCE Bases: BaseHTMLElement , ElementNodeMixin Represents an SOURCE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 129 130 131 132 133 134 135 136 class SOURCE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an SOURCE HTML <source> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . source () . element STOP Bases: BaseHTMLElement , ElementNodeMixin Represents an STOP HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 229 230 231 232 233 234 235 236 class STOP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an STOP HTML <stop> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . stop () . element TRACK Bases: BaseHTMLElement , ElementNodeMixin Represents an TRACK HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 139 140 141 142 143 144 145 146 class TRACK ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an TRACK HTML <track> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . track () . element USE Bases: BaseHTMLElement , ElementNodeMixin Represents an USE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 219 220 221 222 223 224 225 226 class USE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an USE HTML <use> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . use () . element WBR Bases: BaseHTMLElement , ElementNodeMixin Represents an WBR HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 149 150 151 152 153 154 155 156 class WBR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an WBR HTML <wbr> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . wbr () . element","title":"self_closing"},{"location":"reference/probo/components/tag_classes/self_closing/#self_closing","text":"","title":"self_closing"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.AREA","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an AREA HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 19 20 21 22 23 24 25 26 class AREA ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an AREA HTML <area> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . area () . element","title":"AREA"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.BASE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BASE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 29 30 31 32 33 34 35 36 class BASE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BASE HTML <base> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . base () . element","title":"BASE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.BR","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an BR HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 39 40 41 42 43 44 45 46 class BR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an BR HTML <br> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . br () . element","title":"BR"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.CIRCLE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an CIRCLE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 169 170 171 172 173 174 175 176 class CIRCLE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an CIRCLE HTML <circle> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . circle () . element","title":"CIRCLE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.COL","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an COL HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 49 50 51 52 53 54 55 56 class COL ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an COL HTML <col> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . col () . element","title":"COL"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.DOCTYPE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an DOCTYPE HTML <!> line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 9 10 11 12 13 14 15 16 class DOCTYPE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an DOCTYPE HTML <!> line break element (self-closing).\"\"\" def __init__ ( self , content = None , ** kwargs ): super () . __init__ ( content , ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . doctype () . element","title":"DOCTYPE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.EMBED","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an EMBED HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 59 60 61 62 63 64 65 66 class EMBED ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an EMBED HTML <embed> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . embed () . element","title":"EMBED"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.HR","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an HR HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 69 70 71 72 73 74 75 76 class HR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an HR HTML <hr> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . hr () . element","title":"HR"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.IMG","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an IMG HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 79 80 81 82 83 84 85 86 class IMG ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an IMG HTML <img> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . img () . element","title":"IMG"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.INPUT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an INPUT HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 89 90 91 92 93 94 95 96 class INPUT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an INPUT HTML <input> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . input () . element","title":"INPUT"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.LINE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an LINE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 189 190 191 192 193 194 195 196 class LINE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LINE HTML <line> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . line () . element","title":"LINE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.LINK","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an LINK HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 99 100 101 102 103 104 105 106 class LINK ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an LINK HTML <link> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . link () . element","title":"LINK"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.META","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an META HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 109 110 111 112 113 114 115 116 class META ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an META HTML <meta> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . meta () . element","title":"META"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.PARAM","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an PARAM HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 119 120 121 122 123 124 125 126 class PARAM ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PARAM HTML <param> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . param () . element","title":"PARAM"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.PATH","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an PATH HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 159 160 161 162 163 164 165 166 class PATH ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an PATH HTML <path> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . path () . element","title":"PATH"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.POLYGON","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an POLYGON HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 209 210 211 212 213 214 215 216 class POLYGON ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an POLYGON HTML <polygon> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . polygon () . element","title":"POLYGON"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.POLYLINE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an POLYLINE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 199 200 201 202 203 204 205 206 class POLYLINE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an POLYLINE HTML <polyline> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . polyline () . element","title":"POLYLINE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.RECT","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an RECT HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 179 180 181 182 183 184 185 186 class RECT ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an RECT HTML <rect> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . rect () . element","title":"RECT"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.SOURCE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an SOURCE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 129 130 131 132 133 134 135 136 class SOURCE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an SOURCE HTML <source> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . source () . element","title":"SOURCE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.STOP","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an STOP HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 229 230 231 232 233 234 235 236 class STOP ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an STOP HTML <stop> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . stop () . element","title":"STOP"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.TRACK","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an TRACK HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 139 140 141 142 143 144 145 146 class TRACK ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an TRACK HTML <track> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . track () . element","title":"TRACK"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.USE","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an USE HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 219 220 221 222 223 224 225 226 class USE ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an USE HTML <use> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . use () . element","title":"USE"},{"location":"reference/probo/components/tag_classes/self_closing/#probo.components.tag_classes.self_closing.WBR","text":"Bases: BaseHTMLElement , ElementNodeMixin Represents an WBR HTML line break element (self-closing). Source code in src\\probo\\components\\tag_classes\\self_closing.py 149 150 151 152 153 154 155 156 class WBR ( BaseHTMLElement , ElementNodeMixin ,): \"\"\"Represents an WBR HTML <wbr> line break element (self-closing).\"\"\" def __init__ ( self , ** kwargs ): super () . __init__ ( ** kwargs ) # Self-closing tags don't have content def render ( self ): return Element () . set_attrs ( ** self . attributes ) . wbr () . element","title":"WBR"},{"location":"reference/probo/components/tag_functions/block_tags/","text":"block_tags Del ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 107 108 109 def Del ( * content , ** attrs ): \"\"\"Represents an HTML <del> element.\"\"\" return block_tags . DEL ( * content , ** attrs ) . render () Map ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 267 268 269 def Map ( * content , ** attrs ): \"\"\"Represents an HTML <map> element.\"\"\" return block_tags . MAP ( * content , ** attrs ) . render () Object ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 297 298 299 def Object ( * content , ** attrs ): \"\"\"Represents an HTML <object> element.\"\"\" return block_tags . OBJECT ( * content , ** attrs ) . render () a ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 7 8 9 def a ( * content , ** attrs ): \"\"\"Represents an HTML <a> element.\"\"\" return block_tags . A ( * content , ** attrs ) . render () abbr ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 12 13 14 def abbr ( * content , ** attrs ): \"\"\"Represents an HTML <abbr> element.\"\"\" return block_tags . ABBR ( * content , ** attrs ) . render () address ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 17 18 19 def address ( * content , ** attrs ): \"\"\"Represents an HTML <address> element.\"\"\" return block_tags . ADDRESS ( * content , ** attrs ) . render () article ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 22 23 24 def article ( * content , ** attrs ): \"\"\"Represents an HTML <article> element.\"\"\" return block_tags . ARTICLE ( * content , ** attrs ) . render () aside ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 27 28 29 def aside ( * content , ** attrs ): \"\"\"Represents an HTML <aside> element.\"\"\" return block_tags . ASIDE ( * content , ** attrs ) . render () audio ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 32 33 34 def audio ( * content , ** attrs ): \"\"\"Represents an HTML <audio> element.\"\"\" return block_tags . AUDIO ( * content , ** attrs ) . render () b ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 37 38 39 def b ( * content , ** attrs ): \"\"\"Represents an HTML <b> element.\"\"\" return block_tags . B ( * content , ** attrs ) . render () bdi ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 42 43 44 def bdi ( * content , ** attrs ): \"\"\"Represents an HTML <bdi> element.\"\"\" return block_tags . BDI ( * content , ** attrs ) . render () bdo ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 47 48 49 def bdo ( * content , ** attrs ): \"\"\"Represents an HTML <bdo> element.\"\"\" return block_tags . BDO ( * content , ** attrs ) . render () blockquote ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 52 53 54 def blockquote ( * content , ** attrs ): \"\"\"Represents an HTML <blockquote> element.\"\"\" return block_tags . BLOCKQUOTE ( * content , ** attrs ) . render () body ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 57 58 59 def body ( * content , ** attrs ): \"\"\"Represents an HTML <body> element.\"\"\" return block_tags . BODY ( * content , ** attrs ) . render () button ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 62 63 64 def button ( * content , ** attrs ): \"\"\"Represents an HTML <button> element.\"\"\" return block_tags . BUTTON ( * content , ** attrs ) . render () canvas ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 67 68 69 def canvas ( * content , ** attrs ): \"\"\"Represents an HTML <canvas> element.\"\"\" return block_tags . CANVAS ( * content , ** attrs ) . render () caption ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 72 73 74 def caption ( * content , ** attrs ): \"\"\"Represents an HTML <caption> element.\"\"\" return block_tags . CAPTION ( * content , ** attrs ) . render () cite ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 77 78 79 def cite ( * content , ** attrs ): \"\"\"Represents an HTML <cite> element.\"\"\" return block_tags . CITE ( * content , ** attrs ) . render () code ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 82 83 84 def code ( * content , ** attrs ): \"\"\"Represents an HTML <code> element.\"\"\" return block_tags . CODE ( * content , ** attrs ) . render () colgroup ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 87 88 89 def colgroup ( * content , ** attrs ): \"\"\"Represents an HTML <colgroup> element.\"\"\" return block_tags . COLGROUP ( * content , ** attrs ) . render () data ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 92 93 94 def data ( * content , ** attrs ): \"\"\"Represents an HTML <data> element.\"\"\" return block_tags . DATA ( * content , ** attrs ) . render () datalist ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 97 98 99 def datalist ( * content , ** attrs ): \"\"\"Represents an HTML <datalist> element.\"\"\" return block_tags . DATALIST ( * content , ** attrs ) . render () dd ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 102 103 104 def dd ( * content , ** attrs ): \"\"\"Represents an HTML <dd> element.\"\"\" return block_tags . DD ( * content , ** attrs ) . render () defs ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 522 523 524 def defs ( * content , ** attrs ): \"\"\"Represents an HTML <defs> element.\"\"\" return block_tags . DEFS ( * content , ** attrs ) . render () details ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 112 113 114 def details ( * content , ** attrs ): \"\"\"Represents an HTML <details> element.\"\"\" return block_tags . DETAILS ( * content , ** attrs ) . render () dfn ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 117 118 119 def dfn ( * content , ** attrs ): \"\"\"Represents an HTML <dfn> element.\"\"\" return block_tags . DFN ( * content , ** attrs ) . render () dialog ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 122 123 124 def dialog ( * content , ** attrs ): \"\"\"Represents an HTML <dialog> element.\"\"\" return block_tags . DIALOG ( * content , ** attrs ) . render () div ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 127 128 129 def div ( * content , ** attrs ): \"\"\"Represents an HTML <div> element.\"\"\" return block_tags . DIV ( * content , ** attrs ) . render () dl ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 132 133 134 def dl ( * content , ** attrs ): \"\"\"Represents an HTML <dl> element.\"\"\" return block_tags . DL ( * content , ** attrs ) . render () dt ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 137 138 139 def dt ( * content , ** attrs ): \"\"\"Represents an HTML <dt> element.\"\"\" return block_tags . DT ( * content , ** attrs ) . render () em ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 142 143 144 def em ( * content , ** attrs ): \"\"\"Represents an HTML <em> element.\"\"\" return block_tags . EM ( * content , ** attrs ) . render () fieldset ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 147 148 149 def fieldset ( * content , ** attrs ): \"\"\"Represents an HTML <fieldset> element.\"\"\" return block_tags . FIELDSET ( * content , ** attrs ) . render () figcaption ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 152 153 154 def figcaption ( * content , ** attrs ): \"\"\"Represents an HTML <figcaption> element.\"\"\" return block_tags . FIGCAPTION ( * content , ** attrs ) . render () figure ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 157 158 159 def figure ( * content , ** attrs ): \"\"\"Represents an HTML <figure> element.\"\"\" return block_tags . FIGURE ( * content , ** attrs ) . render () footer ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 162 163 164 def footer ( * content , ** attrs ): \"\"\"Represents an HTML <footer> element.\"\"\" return block_tags . FOOTER ( * content , ** attrs ) . render () form ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 167 168 169 def form ( * content , ** attrs ): \"\"\"Represents an HTML <form> element.\"\"\" return block_tags . FORM ( * content , ** attrs ) . render () g ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 517 518 519 def g ( * content , ** attrs ): \"\"\"Represents an HTML <g> element.\"\"\" return block_tags . G ( * content , ** attrs ) . render () h1 ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 172 173 174 def h1 ( * content , ** attrs ): \"\"\"Represents an HTML <h1> element.\"\"\" return block_tags . H1 ( * content , ** attrs ) . render () h2 ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 177 178 179 def h2 ( * content , ** attrs ): \"\"\"Represents an HTML <h2> element.\"\"\" return block_tags . H2 ( * content , ** attrs ) . render () h3 ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 182 183 184 def h3 ( * content , ** attrs ): \"\"\"Represents an HTML <h3> element.\"\"\" return block_tags . H3 ( * content , ** attrs ) . render () h4 ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 187 188 189 def h4 ( * content , ** attrs ): \"\"\"Represents an HTML <h4> element.\"\"\" return block_tags . H4 ( * content , ** attrs ) . render () h5 ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 192 193 194 def h5 ( * content , ** attrs ): \"\"\"Represents an HTML <h5> element.\"\"\" return block_tags . H5 ( * content , ** attrs ) . render () h6 ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 197 198 199 def h6 ( * content , ** attrs ): \"\"\"Represents an HTML <h6> element.\"\"\" return block_tags . H6 ( * content , ** attrs ) . render () head ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 202 203 204 def head ( * content , ** attrs ): \"\"\"Represents an HTML <head> element.\"\"\" return block_tags . HEAD ( * content , ** attrs ) . render () header ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 207 208 209 def header ( * content , ** attrs ): \"\"\"Represents an HTML <header> element.\"\"\" return block_tags . HEADER ( * content , ** attrs ) . render () hgroup ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 212 213 214 def hgroup ( * content , ** attrs ): \"\"\"Represents an HTML <hgroup> element.\"\"\" return block_tags . HGROUP ( * content , ** attrs ) . render () html ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 217 218 219 def html ( * content , ** attrs ): \"\"\"Represents an HTML <html> element.\"\"\" return block_tags . HTML ( * content , ** attrs ) . render () i ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 222 223 224 def i ( * content , ** attrs ): \"\"\"Represents an HTML <i> element.\"\"\" return block_tags . I ( * content , ** attrs ) . render () iframe ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 227 228 229 def iframe ( * content , ** attrs ): \"\"\"Represents an HTML <iframe> element.\"\"\" return block_tags . IFRAME ( * content , ** attrs ) . render () ins ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 232 233 234 def ins ( * content , ** attrs ): \"\"\"Represents an HTML <ins> element.\"\"\" return block_tags . INS ( * content , ** attrs ) . render () kbd ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 237 238 239 def kbd ( * content , ** attrs ): \"\"\"Represents an HTML <kbd> element.\"\"\" return block_tags . KBD ( * content , ** attrs ) . render () label ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 242 243 244 def label ( * content , ** attrs ): \"\"\"Represents an HTML <label> element.\"\"\" return block_tags . LABEL ( * content , ** attrs ) . render () legend ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 247 248 249 def legend ( * content , ** attrs ): \"\"\"Represents an HTML <legend> element.\"\"\" return block_tags . LEGEND ( * content , ** attrs ) . render () li ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 252 253 254 def li ( * content , ** attrs ): \"\"\"Represents an HTML <li> element.\"\"\" return block_tags . LI ( * content , ** attrs ) . render () main ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 257 258 259 def main ( * content , ** attrs ): \"\"\"Represents an HTML <main> element.\"\"\" return block_tags . MAIN ( * content , ** attrs ) . render () mark ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 272 273 274 def mark ( * content , ** attrs ): \"\"\"Represents an HTML <mark> element.\"\"\" return block_tags . MARK ( * content , ** attrs ) . render () math ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 262 263 264 def math ( * content , ** attrs ): \"\"\"Represents an HTML <math> element.\"\"\" return block_tags . MATH ( * content , ** attrs ) . render () menu ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 277 278 279 def menu ( * content , ** attrs ): \"\"\"Represents an HTML <menu> element.\"\"\" return block_tags . MENU ( * content , ** attrs ) . render () meter ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 282 283 284 def meter ( * content , ** attrs ): \"\"\"Represents an HTML <meter> element.\"\"\" return block_tags . METER ( * content , ** attrs ) . render () nav ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 287 288 289 def nav ( * content , ** attrs ): \"\"\"Represents an HTML <nav> element.\"\"\" return block_tags . NAV ( * content , ** attrs ) . render () noscript ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 292 293 294 def noscript ( * content , ** attrs ): \"\"\"Represents an HTML <noscript> element.\"\"\" return block_tags . NOSCRIPT ( * content , ** attrs ) . render () ol ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 302 303 304 def ol ( * content , ** attrs ): \"\"\"Represents an HTML <ol> element.\"\"\" return block_tags . OL ( * content , ** attrs ) . render () optgroup ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 307 308 309 def optgroup ( * content , ** attrs ): \"\"\"Represents an HTML <optgroup> element.\"\"\" return block_tags . OPTGROUP ( * content , ** attrs ) . render () option ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 312 313 314 def option ( * content , ** attrs ): \"\"\"Represents an HTML <option> element.\"\"\" return block_tags . OPTION ( * content , ** attrs ) . render () output ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 317 318 319 def output ( * content , ** attrs ): \"\"\"Represents an HTML <output> element.\"\"\" return block_tags . OUTPUT ( * content , ** attrs ) . render () p ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 322 323 324 def p ( * content , ** attrs ): \"\"\"Represents an HTML <p> element.\"\"\" return block_tags . P ( * content , ** attrs ) . render () picture ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 332 333 334 def picture ( * content , ** attrs ): \"\"\"Represents an HTML <picture> element.\"\"\" return block_tags . PICTURE ( * content , ** attrs ) . render () portal ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 327 328 329 def portal ( * content , ** attrs ): \"\"\"Represents an HTML <portal> element.\"\"\" return block_tags . PORTAL ( * content , ** attrs ) . render () pre ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 337 338 339 def pre ( * content , ** attrs ): \"\"\"Represents an HTML <pre> element.\"\"\" return block_tags . PRE ( * content , ** attrs ) . render () progress ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 342 343 344 def progress ( * content , ** attrs ): \"\"\"Represents an HTML <progress> element.\"\"\" return block_tags . PROGRESS ( * content , ** attrs ) . render () q ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 347 348 349 def q ( * content , ** attrs ): \"\"\"Represents an HTML <q> element.\"\"\" return block_tags . Q ( * content , ** attrs ) . render () rp ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 352 353 354 def rp ( * content , ** attrs ): \"\"\"Represents an HTML <rp> element.\"\"\" return block_tags . RP ( * content , ** attrs ) . render () rt ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 357 358 359 def rt ( * content , ** attrs ): \"\"\"Represents an HTML <rt> element.\"\"\" return block_tags . RT ( * content , ** attrs ) . render () ruby ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 362 363 364 def ruby ( * content , ** attrs ): \"\"\"Represents an HTML <ruby> element.\"\"\" return block_tags . RUBY ( * content , ** attrs ) . render () s ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 367 368 369 def s ( * content , ** attrs ): \"\"\"Represents an HTML <s> element.\"\"\" return block_tags . S ( * content , ** attrs ) . render () samp ( * content , ** attrs ) Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 372 373 374 def samp ( * content , ** attrs ): \"\"\"Represents an HTML <samp> element.\"\"\" return block_tags . SAMP ( * content , ** attrs ) . render () script ( * content , ** attrs ) Represents an HTML","title":"block_tags"},{"location":"reference/probo/components/tag_functions/block_tags/#block_tags","text":"","title":"block_tags"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.Del","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 107 108 109 def Del ( * content , ** attrs ): \"\"\"Represents an HTML <del> element.\"\"\" return block_tags . DEL ( * content , ** attrs ) . render ()","title":"Del"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.Map","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 267 268 269 def Map ( * content , ** attrs ): \"\"\"Represents an HTML <map> element.\"\"\" return block_tags . MAP ( * content , ** attrs ) . render ()","title":"Map"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.Object","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 297 298 299 def Object ( * content , ** attrs ): \"\"\"Represents an HTML <object> element.\"\"\" return block_tags . OBJECT ( * content , ** attrs ) . render ()","title":"Object"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.a","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 7 8 9 def a ( * content , ** attrs ): \"\"\"Represents an HTML <a> element.\"\"\" return block_tags . A ( * content , ** attrs ) . render ()","title":"a"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.abbr","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 12 13 14 def abbr ( * content , ** attrs ): \"\"\"Represents an HTML <abbr> element.\"\"\" return block_tags . ABBR ( * content , ** attrs ) . render ()","title":"abbr"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.address","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 17 18 19 def address ( * content , ** attrs ): \"\"\"Represents an HTML <address> element.\"\"\" return block_tags . ADDRESS ( * content , ** attrs ) . render ()","title":"address"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.article","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 22 23 24 def article ( * content , ** attrs ): \"\"\"Represents an HTML <article> element.\"\"\" return block_tags . ARTICLE ( * content , ** attrs ) . render ()","title":"article"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.aside","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 27 28 29 def aside ( * content , ** attrs ): \"\"\"Represents an HTML <aside> element.\"\"\" return block_tags . ASIDE ( * content , ** attrs ) . render ()","title":"aside"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.audio","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 32 33 34 def audio ( * content , ** attrs ): \"\"\"Represents an HTML <audio> element.\"\"\" return block_tags . AUDIO ( * content , ** attrs ) . render ()","title":"audio"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.b","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 37 38 39 def b ( * content , ** attrs ): \"\"\"Represents an HTML <b> element.\"\"\" return block_tags . B ( * content , ** attrs ) . render ()","title":"b"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.bdi","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 42 43 44 def bdi ( * content , ** attrs ): \"\"\"Represents an HTML <bdi> element.\"\"\" return block_tags . BDI ( * content , ** attrs ) . render ()","title":"bdi"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.bdo","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 47 48 49 def bdo ( * content , ** attrs ): \"\"\"Represents an HTML <bdo> element.\"\"\" return block_tags . BDO ( * content , ** attrs ) . render ()","title":"bdo"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.blockquote","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 52 53 54 def blockquote ( * content , ** attrs ): \"\"\"Represents an HTML <blockquote> element.\"\"\" return block_tags . BLOCKQUOTE ( * content , ** attrs ) . render ()","title":"blockquote"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.body","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 57 58 59 def body ( * content , ** attrs ): \"\"\"Represents an HTML <body> element.\"\"\" return block_tags . BODY ( * content , ** attrs ) . render ()","title":"body"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.button","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 62 63 64 def button ( * content , ** attrs ): \"\"\"Represents an HTML <button> element.\"\"\" return block_tags . BUTTON ( * content , ** attrs ) . render ()","title":"button"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.canvas","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 67 68 69 def canvas ( * content , ** attrs ): \"\"\"Represents an HTML <canvas> element.\"\"\" return block_tags . CANVAS ( * content , ** attrs ) . render ()","title":"canvas"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.caption","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 72 73 74 def caption ( * content , ** attrs ): \"\"\"Represents an HTML <caption> element.\"\"\" return block_tags . CAPTION ( * content , ** attrs ) . render ()","title":"caption"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.cite","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 77 78 79 def cite ( * content , ** attrs ): \"\"\"Represents an HTML <cite> element.\"\"\" return block_tags . CITE ( * content , ** attrs ) . render ()","title":"cite"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.code","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 82 83 84 def code ( * content , ** attrs ): \"\"\"Represents an HTML <code> element.\"\"\" return block_tags . CODE ( * content , ** attrs ) . render ()","title":"code"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.colgroup","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 87 88 89 def colgroup ( * content , ** attrs ): \"\"\"Represents an HTML <colgroup> element.\"\"\" return block_tags . COLGROUP ( * content , ** attrs ) . render ()","title":"colgroup"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.data","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 92 93 94 def data ( * content , ** attrs ): \"\"\"Represents an HTML <data> element.\"\"\" return block_tags . DATA ( * content , ** attrs ) . render ()","title":"data"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.datalist","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 97 98 99 def datalist ( * content , ** attrs ): \"\"\"Represents an HTML <datalist> element.\"\"\" return block_tags . DATALIST ( * content , ** attrs ) . render ()","title":"datalist"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.dd","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 102 103 104 def dd ( * content , ** attrs ): \"\"\"Represents an HTML <dd> element.\"\"\" return block_tags . DD ( * content , ** attrs ) . render ()","title":"dd"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.defs","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 522 523 524 def defs ( * content , ** attrs ): \"\"\"Represents an HTML <defs> element.\"\"\" return block_tags . DEFS ( * content , ** attrs ) . render ()","title":"defs"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.details","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 112 113 114 def details ( * content , ** attrs ): \"\"\"Represents an HTML <details> element.\"\"\" return block_tags . DETAILS ( * content , ** attrs ) . render ()","title":"details"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.dfn","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 117 118 119 def dfn ( * content , ** attrs ): \"\"\"Represents an HTML <dfn> element.\"\"\" return block_tags . DFN ( * content , ** attrs ) . render ()","title":"dfn"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.dialog","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 122 123 124 def dialog ( * content , ** attrs ): \"\"\"Represents an HTML <dialog> element.\"\"\" return block_tags . DIALOG ( * content , ** attrs ) . render ()","title":"dialog"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.div","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 127 128 129 def div ( * content , ** attrs ): \"\"\"Represents an HTML <div> element.\"\"\" return block_tags . DIV ( * content , ** attrs ) . render ()","title":"div"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.dl","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 132 133 134 def dl ( * content , ** attrs ): \"\"\"Represents an HTML <dl> element.\"\"\" return block_tags . DL ( * content , ** attrs ) . render ()","title":"dl"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.dt","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 137 138 139 def dt ( * content , ** attrs ): \"\"\"Represents an HTML <dt> element.\"\"\" return block_tags . DT ( * content , ** attrs ) . render ()","title":"dt"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.em","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 142 143 144 def em ( * content , ** attrs ): \"\"\"Represents an HTML <em> element.\"\"\" return block_tags . EM ( * content , ** attrs ) . render ()","title":"em"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.fieldset","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 147 148 149 def fieldset ( * content , ** attrs ): \"\"\"Represents an HTML <fieldset> element.\"\"\" return block_tags . FIELDSET ( * content , ** attrs ) . render ()","title":"fieldset"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.figcaption","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 152 153 154 def figcaption ( * content , ** attrs ): \"\"\"Represents an HTML <figcaption> element.\"\"\" return block_tags . FIGCAPTION ( * content , ** attrs ) . render ()","title":"figcaption"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.figure","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 157 158 159 def figure ( * content , ** attrs ): \"\"\"Represents an HTML <figure> element.\"\"\" return block_tags . FIGURE ( * content , ** attrs ) . render ()","title":"figure"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.footer","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 162 163 164 def footer ( * content , ** attrs ): \"\"\"Represents an HTML <footer> element.\"\"\" return block_tags . FOOTER ( * content , ** attrs ) . render ()","title":"footer"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.form","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 167 168 169 def form ( * content , ** attrs ): \"\"\"Represents an HTML <form> element.\"\"\" return block_tags . FORM ( * content , ** attrs ) . render ()","title":"form"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.g","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 517 518 519 def g ( * content , ** attrs ): \"\"\"Represents an HTML <g> element.\"\"\" return block_tags . G ( * content , ** attrs ) . render ()","title":"g"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.h1","text":"Represents an HTML","title":"h1"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.h2","text":"Represents an HTML","title":"h2"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.h3","text":"Represents an HTML","title":"h3"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.h4","text":"Represents an HTML","title":"h4"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.h5","text":"Represents an HTML","title":"h5"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.h6","text":"Represents an HTML","title":"h6"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.head","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 202 203 204 def head ( * content , ** attrs ): \"\"\"Represents an HTML <head> element.\"\"\" return block_tags . HEAD ( * content , ** attrs ) . render ()","title":"head"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.header","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 207 208 209 def header ( * content , ** attrs ): \"\"\"Represents an HTML <header> element.\"\"\" return block_tags . HEADER ( * content , ** attrs ) . render ()","title":"header"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.hgroup","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 212 213 214 def hgroup ( * content , ** attrs ): \"\"\"Represents an HTML <hgroup> element.\"\"\" return block_tags . HGROUP ( * content , ** attrs ) . render ()","title":"hgroup"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.html","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 217 218 219 def html ( * content , ** attrs ): \"\"\"Represents an HTML <html> element.\"\"\" return block_tags . HTML ( * content , ** attrs ) . render ()","title":"html"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.i","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 222 223 224 def i ( * content , ** attrs ): \"\"\"Represents an HTML <i> element.\"\"\" return block_tags . I ( * content , ** attrs ) . render ()","title":"i"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.iframe","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 227 228 229 def iframe ( * content , ** attrs ): \"\"\"Represents an HTML <iframe> element.\"\"\" return block_tags . IFRAME ( * content , ** attrs ) . render ()","title":"iframe"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.ins","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 232 233 234 def ins ( * content , ** attrs ): \"\"\"Represents an HTML <ins> element.\"\"\" return block_tags . INS ( * content , ** attrs ) . render ()","title":"ins"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.kbd","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 237 238 239 def kbd ( * content , ** attrs ): \"\"\"Represents an HTML <kbd> element.\"\"\" return block_tags . KBD ( * content , ** attrs ) . render ()","title":"kbd"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.label","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 242 243 244 def label ( * content , ** attrs ): \"\"\"Represents an HTML <label> element.\"\"\" return block_tags . LABEL ( * content , ** attrs ) . render ()","title":"label"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.legend","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 247 248 249 def legend ( * content , ** attrs ): \"\"\"Represents an HTML <legend> element.\"\"\" return block_tags . LEGEND ( * content , ** attrs ) . render ()","title":"legend"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.li","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 252 253 254 def li ( * content , ** attrs ): \"\"\"Represents an HTML <li> element.\"\"\" return block_tags . LI ( * content , ** attrs ) . render ()","title":"li"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.main","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 257 258 259 def main ( * content , ** attrs ): \"\"\"Represents an HTML <main> element.\"\"\" return block_tags . MAIN ( * content , ** attrs ) . render ()","title":"main"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.mark","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 272 273 274 def mark ( * content , ** attrs ): \"\"\"Represents an HTML <mark> element.\"\"\" return block_tags . MARK ( * content , ** attrs ) . render ()","title":"mark"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.math","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 262 263 264 def math ( * content , ** attrs ): \"\"\"Represents an HTML <math> element.\"\"\" return block_tags . MATH ( * content , ** attrs ) . render ()","title":"math"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.menu","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 277 278 279 def menu ( * content , ** attrs ): \"\"\"Represents an HTML <menu> element.\"\"\" return block_tags . MENU ( * content , ** attrs ) . render ()","title":"menu"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.meter","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 282 283 284 def meter ( * content , ** attrs ): \"\"\"Represents an HTML <meter> element.\"\"\" return block_tags . METER ( * content , ** attrs ) . render ()","title":"meter"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.nav","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 287 288 289 def nav ( * content , ** attrs ): \"\"\"Represents an HTML <nav> element.\"\"\" return block_tags . NAV ( * content , ** attrs ) . render ()","title":"nav"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.noscript","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 292 293 294 def noscript ( * content , ** attrs ): \"\"\"Represents an HTML <noscript> element.\"\"\" return block_tags . NOSCRIPT ( * content , ** attrs ) . render ()","title":"noscript"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.ol","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 302 303 304 def ol ( * content , ** attrs ): \"\"\"Represents an HTML <ol> element.\"\"\" return block_tags . OL ( * content , ** attrs ) . render ()","title":"ol"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.optgroup","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 307 308 309 def optgroup ( * content , ** attrs ): \"\"\"Represents an HTML <optgroup> element.\"\"\" return block_tags . OPTGROUP ( * content , ** attrs ) . render ()","title":"optgroup"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.option","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 312 313 314 def option ( * content , ** attrs ): \"\"\"Represents an HTML <option> element.\"\"\" return block_tags . OPTION ( * content , ** attrs ) . render ()","title":"option"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.output","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 317 318 319 def output ( * content , ** attrs ): \"\"\"Represents an HTML <output> element.\"\"\" return block_tags . OUTPUT ( * content , ** attrs ) . render ()","title":"output"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.p","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 322 323 324 def p ( * content , ** attrs ): \"\"\"Represents an HTML <p> element.\"\"\" return block_tags . P ( * content , ** attrs ) . render ()","title":"p"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.picture","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 332 333 334 def picture ( * content , ** attrs ): \"\"\"Represents an HTML <picture> element.\"\"\" return block_tags . PICTURE ( * content , ** attrs ) . render ()","title":"picture"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.portal","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 327 328 329 def portal ( * content , ** attrs ): \"\"\"Represents an HTML <portal> element.\"\"\" return block_tags . PORTAL ( * content , ** attrs ) . render ()","title":"portal"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.pre","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 337 338 339 def pre ( * content , ** attrs ): \"\"\"Represents an HTML <pre> element.\"\"\" return block_tags . PRE ( * content , ** attrs ) . render ()","title":"pre"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.progress","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 342 343 344 def progress ( * content , ** attrs ): \"\"\"Represents an HTML <progress> element.\"\"\" return block_tags . PROGRESS ( * content , ** attrs ) . render ()","title":"progress"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.q","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 347 348 349 def q ( * content , ** attrs ): \"\"\"Represents an HTML <q> element.\"\"\" return block_tags . Q ( * content , ** attrs ) . render ()","title":"q"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.rp","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 352 353 354 def rp ( * content , ** attrs ): \"\"\"Represents an HTML <rp> element.\"\"\" return block_tags . RP ( * content , ** attrs ) . render ()","title":"rp"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.rt","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 357 358 359 def rt ( * content , ** attrs ): \"\"\"Represents an HTML <rt> element.\"\"\" return block_tags . RT ( * content , ** attrs ) . render ()","title":"rt"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.ruby","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 362 363 364 def ruby ( * content , ** attrs ): \"\"\"Represents an HTML <ruby> element.\"\"\" return block_tags . RUBY ( * content , ** attrs ) . render ()","title":"ruby"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.s","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 367 368 369 def s ( * content , ** attrs ): \"\"\"Represents an HTML <s> element.\"\"\" return block_tags . S ( * content , ** attrs ) . render ()","title":"s"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.samp","text":"Represents an HTML element. Source code in src\\probo\\components\\tag_functions\\block_tags.py 372 373 374 def samp ( * content , ** attrs ): \"\"\"Represents an HTML <samp> element.\"\"\" return block_tags . SAMP ( * content , ** attrs ) . render ()","title":"samp"},{"location":"reference/probo/components/tag_functions/block_tags/#probo.components.tag_functions.block_tags.script","text":"Represents an HTML","title":"script"},{"location":"reference/probo/components/tag_functions/self_closing/","text":"self_closing Input ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 48 49 50 def Input ( ** attrs ): \"\"\"Represents an HTML <input/> line break element (self-closing).\"\"\" return self_closing . INPUT ( ** attrs ) . render () area ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 13 14 15 def area ( ** attrs ): \"\"\"Represents an HTML <area/> line break element (self-closing).\"\"\" return self_closing . AREA ( ** attrs ) . render () base ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 18 19 20 def base ( ** attrs ): \"\"\"Represents an HTML <base/> line break element (self-closing).\"\"\" return self_closing . BASE ( ** attrs ) . render () br ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 23 24 25 def br ( ** attrs ): \"\"\"Represents an HTML <br/> line break element (self-closing).\"\"\" return self_closing . BR ( ** attrs ) . render () circle ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 88 89 90 def circle ( ** attrs ): \"\"\"Represents an HTML <circle/> line break element (self-closing).\"\"\" return self_closing . CIRCLE ( ** attrs ) . render () col ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 28 29 30 def col ( ** attrs ): \"\"\"Represents an HTML <col/> line break element (self-closing).\"\"\" return self_closing . COL ( ** attrs ) . render () doctype ( content = None , ** attrs ) Represents an HTML <!DOCTYPE> line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 7 8 9 def doctype ( content = None , ** attrs ): \"\"\"Represents an HTML <!DOCTYPE> line break element (self-closing).\"\"\" return self_closing . DOCTYPE ( content , ** attrs ) . render () embed ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 33 34 35 def embed ( ** attrs ): \"\"\"Represents an HTML <embed/> line break element (self-closing).\"\"\" return self_closing . EMBED ( ** attrs ) . render () hr ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 38 39 40 def hr ( ** attrs ): \"\"\"Represents an HTML <hr/> line break element (self-closing).\"\"\" return self_closing . HR ( ** attrs ) . render () img ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 43 44 45 def img ( ** attrs ): \"\"\"Represents an HTML <img/> line break element (self-closing).\"\"\" return self_closing . IMG ( ** attrs ) . render () line ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 98 99 100 def line ( ** attrs ): \"\"\"Represents an HTML <line/> line break element (self-closing).\"\"\" return self_closing . LINE ( ** attrs ) . render () link ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 53 54 55 def link ( ** attrs ): \"\"\"Represents an HTML <link/> line break element (self-closing).\"\"\" return self_closing . LINK ( ** attrs ) . render () meta ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 58 59 60 def meta ( ** attrs ): \"\"\"Represents an HTML <meta/> line break element (self-closing).\"\"\" return self_closing . META ( ** attrs ) . render () param ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 63 64 65 def param ( ** attrs ): \"\"\"Represents an HTML <param/> line break element (self-closing).\"\"\" return self_closing . PARAM ( ** attrs ) . render () path ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 83 84 85 def path ( ** attrs ): \"\"\"Represents an HTML <path/> line break element (self-closing).\"\"\" return self_closing . PATH ( ** attrs ) . render () polygon ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 108 109 110 def polygon ( ** attrs ): \"\"\"Represents an HTML <polygon/> line break element (self-closing).\"\"\" return self_closing . POLYGON ( ** attrs ) . render () polyline ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 103 104 105 def polyline ( ** attrs ): \"\"\"Represents an HTML <polyline/> line break element (self-closing).\"\"\" return self_closing . POLYLINE ( ** attrs ) . render () rect ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 93 94 95 def rect ( ** attrs ): \"\"\"Represents an HTML <rect/> line break element (self-closing).\"\"\" return self_closing . RECT ( ** attrs ) . render () source ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 68 69 70 def source ( ** attrs ): \"\"\"Represents an HTML <source/> line break element (self-closing).\"\"\" return self_closing . SOURCE ( ** attrs ) . render () stop ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 118 119 120 def stop ( ** attrs ): \"\"\"Represents an HTML <stop/> line break element (self-closing).\"\"\" return self_closing . STOP ( ** attrs ) . render () track ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 73 74 75 def track ( ** attrs ): \"\"\"Represents an HTML <track/> line break element (self-closing).\"\"\" return self_closing . TRACK ( ** attrs ) . render () use ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 113 114 115 def use ( ** attrs ): \"\"\"Represents an HTML <use/> line break element (self-closing).\"\"\" return self_closing . USE ( ** attrs ) . render () wbr ( ** attrs ) Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 78 79 80 def wbr ( ** attrs ): \"\"\"Represents an HTML <wbr/> line break element (self-closing).\"\"\" return self_closing . WBR ( ** attrs ) . render ()","title":"self_closing"},{"location":"reference/probo/components/tag_functions/self_closing/#self_closing","text":"","title":"self_closing"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.Input","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 48 49 50 def Input ( ** attrs ): \"\"\"Represents an HTML <input/> line break element (self-closing).\"\"\" return self_closing . INPUT ( ** attrs ) . render ()","title":"Input"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.area","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 13 14 15 def area ( ** attrs ): \"\"\"Represents an HTML <area/> line break element (self-closing).\"\"\" return self_closing . AREA ( ** attrs ) . render ()","title":"area"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.base","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 18 19 20 def base ( ** attrs ): \"\"\"Represents an HTML <base/> line break element (self-closing).\"\"\" return self_closing . BASE ( ** attrs ) . render ()","title":"base"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.br","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 23 24 25 def br ( ** attrs ): \"\"\"Represents an HTML <br/> line break element (self-closing).\"\"\" return self_closing . BR ( ** attrs ) . render ()","title":"br"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.circle","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 88 89 90 def circle ( ** attrs ): \"\"\"Represents an HTML <circle/> line break element (self-closing).\"\"\" return self_closing . CIRCLE ( ** attrs ) . render ()","title":"circle"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.col","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 28 29 30 def col ( ** attrs ): \"\"\"Represents an HTML <col/> line break element (self-closing).\"\"\" return self_closing . COL ( ** attrs ) . render ()","title":"col"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.doctype","text":"Represents an HTML <!DOCTYPE> line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 7 8 9 def doctype ( content = None , ** attrs ): \"\"\"Represents an HTML <!DOCTYPE> line break element (self-closing).\"\"\" return self_closing . DOCTYPE ( content , ** attrs ) . render ()","title":"doctype"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.embed","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 33 34 35 def embed ( ** attrs ): \"\"\"Represents an HTML <embed/> line break element (self-closing).\"\"\" return self_closing . EMBED ( ** attrs ) . render ()","title":"embed"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.hr","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 38 39 40 def hr ( ** attrs ): \"\"\"Represents an HTML <hr/> line break element (self-closing).\"\"\" return self_closing . HR ( ** attrs ) . render ()","title":"hr"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.img","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 43 44 45 def img ( ** attrs ): \"\"\"Represents an HTML <img/> line break element (self-closing).\"\"\" return self_closing . IMG ( ** attrs ) . render ()","title":"img"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.line","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 98 99 100 def line ( ** attrs ): \"\"\"Represents an HTML <line/> line break element (self-closing).\"\"\" return self_closing . LINE ( ** attrs ) . render ()","title":"line"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.link","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 53 54 55 def link ( ** attrs ): \"\"\"Represents an HTML <link/> line break element (self-closing).\"\"\" return self_closing . LINK ( ** attrs ) . render ()","title":"link"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.meta","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 58 59 60 def meta ( ** attrs ): \"\"\"Represents an HTML <meta/> line break element (self-closing).\"\"\" return self_closing . META ( ** attrs ) . render ()","title":"meta"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.param","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 63 64 65 def param ( ** attrs ): \"\"\"Represents an HTML <param/> line break element (self-closing).\"\"\" return self_closing . PARAM ( ** attrs ) . render ()","title":"param"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.path","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 83 84 85 def path ( ** attrs ): \"\"\"Represents an HTML <path/> line break element (self-closing).\"\"\" return self_closing . PATH ( ** attrs ) . render ()","title":"path"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.polygon","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 108 109 110 def polygon ( ** attrs ): \"\"\"Represents an HTML <polygon/> line break element (self-closing).\"\"\" return self_closing . POLYGON ( ** attrs ) . render ()","title":"polygon"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.polyline","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 103 104 105 def polyline ( ** attrs ): \"\"\"Represents an HTML <polyline/> line break element (self-closing).\"\"\" return self_closing . POLYLINE ( ** attrs ) . render ()","title":"polyline"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.rect","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 93 94 95 def rect ( ** attrs ): \"\"\"Represents an HTML <rect/> line break element (self-closing).\"\"\" return self_closing . RECT ( ** attrs ) . render ()","title":"rect"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.source","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 68 69 70 def source ( ** attrs ): \"\"\"Represents an HTML <source/> line break element (self-closing).\"\"\" return self_closing . SOURCE ( ** attrs ) . render ()","title":"source"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.stop","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 118 119 120 def stop ( ** attrs ): \"\"\"Represents an HTML <stop/> line break element (self-closing).\"\"\" return self_closing . STOP ( ** attrs ) . render ()","title":"stop"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.track","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 73 74 75 def track ( ** attrs ): \"\"\"Represents an HTML <track/> line break element (self-closing).\"\"\" return self_closing . TRACK ( ** attrs ) . render ()","title":"track"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.use","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 113 114 115 def use ( ** attrs ): \"\"\"Represents an HTML <use/> line break element (self-closing).\"\"\" return self_closing . USE ( ** attrs ) . render ()","title":"use"},{"location":"reference/probo/components/tag_functions/self_closing/#probo.components.tag_functions.self_closing.wbr","text":"Represents an HTML line break element (self-closing). Source code in src\\probo\\components\\tag_functions\\self_closing.py 78 79 80 def wbr ( ** attrs ): \"\"\"Represents an HTML <wbr/> line break element (self-closing).\"\"\" return self_closing . WBR ( ** attrs ) . render ()","title":"wbr"},{"location":"reference/probo/context/context_logic/","text":"context_logic DynamicData dataclass data class to define and get dynamic data (from user or db) with custom manipulation plug in function for rendering components Source code in src\\probo\\context\\context_logic.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 @dataclass class DynamicData : \"\"\" data class to define and get dynamic data (from user or db) with custom manipulation plug in function for rendering components \"\"\" data_obj : Optional [ object ] = None processor : Optional [ Callable [[ Any ], Dict ]] = None dynamic_data : dict [ str , Any ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\" This runs AUTOMATICALLY immediately after __init__. It processes the data_obj and populates dynamic_data instantly. \"\"\" if self . processor and callable ( self . processor ) and self . data_obj : self . dynamic_data = self . processor ( self . data_obj ) elif isinstance ( self . data_obj , dict ): self . dynamic_data = self . data_obj def get ( self , Value ): \"\"\" Retrieves a value from the processed dynamic data. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . dynamic_data . get ( Value , None ) # Optional: Keep this if you want a \"Safe Accessor\" that ensures a Dict return type @property def data ( self ) -> Dict : \"\"\" Safely accesses the full dynamic data dictionary. Returns: Dict: The dynamic data dictionary, ensuring a dict type is returned even if empty. \"\"\" return self . dynamic_data or {} data property Safely accesses the full dynamic data dictionary. Returns: Dict ( Dict ) \u2013 The dynamic data dictionary, ensuring a dict type is returned even if empty. __post_init__ () This runs AUTOMATICALLY immediately after init . It processes the data_obj and populates dynamic_data instantly. Source code in src\\probo\\context\\context_logic.py 402 403 404 405 406 407 408 409 410 def __post_init__ ( self ): \"\"\" This runs AUTOMATICALLY immediately after __init__. It processes the data_obj and populates dynamic_data instantly. \"\"\" if self . processor and callable ( self . processor ) and self . data_obj : self . dynamic_data = self . processor ( self . data_obj ) elif isinstance ( self . data_obj , dict ): self . dynamic_data = self . data_obj get ( Value ) Retrieves a value from the processed dynamic data. Parameters: Value ( str ) \u2013 The key to look up. Returns: Any \u2013 The value associated with the key, or None if not found. Source code in src\\probo\\context\\context_logic.py 412 413 414 415 416 417 418 419 420 421 422 def get ( self , Value ): \"\"\" Retrieves a value from the processed dynamic data. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . dynamic_data . get ( Value , None ) StaticData dataclass data class to define and get statiic data for rendering components Source code in src\\probo\\context\\context_logic.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 @dataclass class StaticData : \"\"\" data class to define and get statiic data for rendering components \"\"\" static_data : dict [ str , Any ] def get ( self , Value ): \"\"\" Retrieves a value from the static data dictionary. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . static_data . get ( Value , None ) get ( Value ) Retrieves a value from the static data dictionary. Parameters: Value ( str ) \u2013 The key to look up. Returns: Any \u2013 The value associated with the key, or None if not found. Source code in src\\probo\\context\\context_logic.py 380 381 382 383 384 385 386 387 388 389 390 def get ( self , Value ): \"\"\" Retrieves a value from the static data dictionary. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . static_data . get ( Value , None ) TemplateComponentMap Template Components Map is the cordinator that serves the right component to spesific view Source code in src\\probo\\context\\context_logic.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 class TemplateComponentMap : \"\"\"Template Components Map is the cordinator that serves the right component to spesific view\"\"\" def __init__ ( self , r_props : dict [ str , Any ] = None , ** url_name_comp ): self . url_name_comp = url_name_comp self . r_props = r_props or {} def get_component ( self , url_name ) -> str | tuple : \"\"\" Retrieves a component associated with a URL name and injects request properties. Args: url_name (str): The key/name representing the URL route. Returns: str | tuple: The rendered component (usually a string or HTML tuple). Raises: ValueError: If the url_name does not exist in the map. \"\"\" comp = self . url_name_comp . get ( url_name , None ) if comp : comp . props [ \"request-props\" ] = self . r_props . get ( \"request-props\" , {}) comp . props [ \"state-prop\" ] = self . r_props . get ( \"state-prop\" , {}) return comp . render () else : raise ValueError ( \"no such url maping\" ) def set_component ( self , url_name = None , component_name = None , ** url_name_comp ): \"\"\" Registers new components or updates existing mappings. Args: url_name (str, optional): The specific URL key to update. component_name (object, optional): The component object to associate. **url_name_comp: Additional mappings passed as keyword arguments. Returns: TemplateComponentMap: Self, allowing for method chaining. \"\"\" self . url_name_comp . update ( url_name_comp ) if url_name and component_name : self . url_name_comp [ url_name ] = component_name return self get_component ( url_name ) Retrieves a component associated with a URL name and injects request properties. Parameters: url_name ( str ) \u2013 The key/name representing the URL route. Returns: str | tuple \u2013 str | tuple: The rendered component (usually a string or HTML tuple). Raises: ValueError \u2013 If the url_name does not exist in the map. Source code in src\\probo\\context\\context_logic.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def get_component ( self , url_name ) -> str | tuple : \"\"\" Retrieves a component associated with a URL name and injects request properties. Args: url_name (str): The key/name representing the URL route. Returns: str | tuple: The rendered component (usually a string or HTML tuple). Raises: ValueError: If the url_name does not exist in the map. \"\"\" comp = self . url_name_comp . get ( url_name , None ) if comp : comp . props [ \"request-props\" ] = self . r_props . get ( \"request-props\" , {}) comp . props [ \"state-prop\" ] = self . r_props . get ( \"state-prop\" , {}) return comp . render () else : raise ValueError ( \"no such url maping\" ) set_component ( url_name = None , component_name = None , ** url_name_comp ) Registers new components or updates existing mappings. Parameters: url_name ( str , default: None ) \u2013 The specific URL key to update. component_name ( object , default: None ) \u2013 The component object to associate. **url_name_comp \u2013 Additional mappings passed as keyword arguments. Returns: TemplateComponentMap \u2013 Self, allowing for method chaining. Source code in src\\probo\\context\\context_logic.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def set_component ( self , url_name = None , component_name = None , ** url_name_comp ): \"\"\" Registers new components or updates existing mappings. Args: url_name (str, optional): The specific URL key to update. component_name (object, optional): The component object to associate. **url_name_comp: Additional mappings passed as keyword arguments. Returns: TemplateComponentMap: Self, allowing for method chaining. \"\"\" self . url_name_comp . update ( url_name_comp ) if url_name and component_name : self . url_name_comp [ url_name ] = component_name return self TemplateProcessor A class to process only 'mui' style template blocks but with support for generating Django-style template tags. Static methods are included. Source code in src\\probo\\context\\context_logic.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class TemplateProcessor : \"\"\" A class to process only 'mui' style template blocks but with support for generating Django-style template tags. Static methods are included. \"\"\" SUPPORTED_STYLES = [ \"django\" , \"mui\" ] def __init__ ( self , data_context : dict = None ): \"\"\" Initializes the processor with a global data context. Args: data_context (dict, optional): A dictionary of global variables available to all templates rendered by this instance. \"\"\" self . _global_data_context = data_context if data_context is not None else {} def _evaluate_expression ( self , expression : str , current_context : dict ) -> Any : \"\"\" Safely evaluates a string expression within a given context. Args: expression (str): The python-like expression to evaluate (e.g., \"user.is_active\"). current_context (dict): The local context variables available for this evaluation. Returns: Any: The result of the evaluation, or None if an error occurs. \"\"\" full_context = { ** self . _global_data_context , ** current_context } try : return eval ( expression , {}, full_context ) except Exception as e : print ( f \"Error evaluating expression ' { expression } ': { e } \" ) return None def _apply_filter ( self , value : Any , filter_name : str ) -> Any : \"\"\" Applies a named transformation filter to a value. Supported filters: 'upper', 'lower', 'title', 'length'. Args: value (Any): The value to transform. filter_name (str): The name of the filter to apply. Returns: Any: The transformed value, or the original value if the filter is unknown. \"\"\" filters = { \"upper\" : lambda v : str ( v ) . upper (), \"lower\" : lambda v : str ( v ) . lower (), \"title\" : lambda v : str ( v ) . title (), \"length\" : lambda v : len ( v ) if hasattr ( v , \"__len__\" ) else len ( str ( v )), } return filters . get ( filter_name , lambda v : v )( value ) def _process_template_block ( self , text : str , current_context : dict ) -> str : \"\"\" recursively processes template logic within the text. It handles loops, conditional blocks, and variable substitutions in that specific order to ensure nested structures are rendered correctly. Args: text (str): The raw template string containing custom tags. current_context (dict): The data context for rendering. Returns: str: The fully rendered text string. \"\"\" text = self . _process_for_loops ( text , current_context ) text = self . _process_if_blocks ( text , current_context ) text = self . _process_variables ( text , current_context ) return text def _process_if_blocks ( self , text : str , context : dict ) -> str : \"\"\" Parses and evaluates custom <$if>...<$elif>...<$else>...<$/if> tags. It supports evaluating conditions dynamically against the provided context. Args: text (str): The text containing IF blocks. context (dict): The data context used to evaluate the conditions. Returns: str: The text with the correct block content retained and tags removed. \"\"\" # Matches <$if condition> ... <$else> ... </$if> if_pattern = re . compile ( r \"<\\$if (.+?)>(.*?)\" r \"(?:(?:<\\$elif (.+?)>(.*?))*)\" r \"(?:<\\$else>(.*?))?\" r \"</\\$if>\" , re . DOTALL , ) def repl ( match ): condition = match . group ( 1 ) . strip () if_block = match . group ( 2 ) elif_condition = match . group ( 3 ) elif_block = match . group ( 4 ) else_block = match . group ( 5 ) try : if self . _evaluate_expression ( condition , context ): return self . _process_template_block ( if_block , context ) elif elif_condition and self . _evaluate_expression ( elif_condition , context ): return self . _process_template_block ( elif_block , context ) elif else_block : return self . _process_template_block ( else_block , context ) except Exception as e : print ( f \"Error in IF evaluation: { e } \" ) return \"\" return if_pattern . sub ( repl , text ) def _process_for_loops ( self , text : str , context : dict ) -> str : \"\"\" Parses and evaluates custom <$for item in iterable>...<$/for> tags. Iterates over the provided collection and repeats the block content for each item. Args: text (str): The text containing FOR loops. context (dict): The data context containing the iterable variables. Returns: str: The text with the loop fully expanded. \"\"\" for_pattern = re . compile ( r \"<\\$for (.+?) in (.+?)>(.*?)</\\$for>\" , re . DOTALL ) def repl ( match ): loop_var = match . group ( 1 ) . strip () iterable = self . _evaluate_expression ( match . group ( 2 ) . strip (), context ) loop_content = match . group ( 3 ) if not iterable : return \"\" result = [] for item in iterable : local_context = { ** context , loop_var : item } result . append ( self . _process_template_block ( loop_content , local_context )) return \"\" . join ( result ) return for_pattern . sub ( repl , text ) def _process_variables ( self , text : str , context : dict ) -> str : \"\"\" Replaces {{ variable|filter }} syntax with actual values from the context. Args: text (str): The text containing variable placeholders. context (dict): The data context to look up values. Returns: str: The text with variables replaced by their string representations. \"\"\" # Matches variables like {{ var|filter }} var_pattern = re . compile ( r \"\\{\\{ (.+?) \\}\\}\" ) def repl ( match ): expr = match . group ( 1 ) if \"|\" in expr : var_name , filter_name = expr . split ( \"|\" , 1 ) value = self . _evaluate_expression ( var_name . strip (), context ) return str ( self . _apply_filter ( value , filter_name . strip ())) return str ( self . _evaluate_expression ( expr . strip (), context ) or \"\" ) return var_pattern . sub ( repl , text ) def render_template ( self , template_string : str , context : dict = None ) -> str : \"\"\" The main entry point for rendering a template string. Merges the instance's global context with the provided local context and processes all template blocks (loops, ifs, vars). Args: template_string (str): The raw template string to render. context (dict, optional): Additional local context for this specific render. Returns: str: The fully rendered string. \"\"\" effective_context = { ** self . _global_data_context , ** ( context or {})} return self . _process_template_block ( template_string , effective_context ) # ---------- STATIC METHODS FOR BLOCK CREATION ---------- @staticmethod def if_true ( expression , if_block , style = \"mui\" , else_statement = None , ** elif_statements ): \"\"\" Generates a conditional block string in the specified style (MUI or Django). Args: expression (str): The condition to evaluate (e.g., \"user.is_admin\"). if_block (str): Content to render if true. style (str): The syntax style to generate (\"mui\" or \"django\"). else_statement (str, optional): Content for the else block. **elif_statements: Key-value pairs where key is condition and value is content for elif blocks. Returns: str: The formatted conditional block string. \"\"\" if style == \"mui\" : return ( f \"<$if { expression } > { if_block } \" + \"\" . join ( [ f \"<$elif { cond } > { block } \" for cond , block in elif_statements . items () ] ) + ( f \"<$else> { else_statement } \" if else_statement else \"\" ) + \"</$if>\" ) elif style == \"django\" : return ( f \" {{ % if { expression } % }} { if_block } \" + \"\" . join ( [ f \" {{ % elif { cond } % }} { block } \" for cond , block in elif_statements . items () ] ) + ( f \" {{ % else % }} { else_statement } \" if else_statement else \"\" ) + \"{ % e ndif %}\" ) else : return \"\" @staticmethod def for_loop ( expression , for_block , style = \"mui\" , empty_content = None ): \"\"\" Generates a for-loop block string in the specified style. Args: expression (str): The loop expression (e.g., \"item in items\"). for_block (str): The content to repeat inside the loop. style (str): The syntax style to generate (\"mui\" or \"django\"). empty_content (str, optional): Content to display if the iterable is empty (Django style only). Returns: str: The formatted loop block string. \"\"\" empty = f \" {{ % empty % }} { empty_content } \" if empty_content else \"\" if style == \"mui\" : return f \"<$for { expression } > { for_block } </$for>\" elif style == \"django\" : return f \" {{ % for { expression } % }} { for_block }{ empty } {{ % endfor % }} \" else : return \"\" @staticmethod def set_variable ( expression , ): \"\"\" Generates a variable output string. Args: expression (str): The variable expression to output (e.g., \"user.name\"). Returns: str: The formatted variable string (e.g., \"{{ user.name }}\"). \"\"\" return f \" {{{{ { expression } }}}} \" __init__ ( data_context = None ) Initializes the processor with a global data context. Parameters: data_context ( dict , default: None ) \u2013 A dictionary of global variables available to all templates rendered by this instance. Source code in src\\probo\\context\\context_logic.py 16 17 18 19 20 21 22 23 24 def __init__ ( self , data_context : dict = None ): \"\"\" Initializes the processor with a global data context. Args: data_context (dict, optional): A dictionary of global variables available to all templates rendered by this instance. \"\"\" self . _global_data_context = data_context if data_context is not None else {} for_loop ( expression , for_block , style = 'mui' , empty_content = None ) staticmethod Generates a for-loop block string in the specified style. Parameters: expression ( str ) \u2013 The loop expression (e.g., \"item in items\"). for_block ( str ) \u2013 The content to repeat inside the loop. style ( str , default: 'mui' ) \u2013 The syntax style to generate (\"mui\" or \"django\"). empty_content ( str , default: None ) \u2013 Content to display if the iterable is empty (Django style only). Returns: str \u2013 The formatted loop block string. Source code in src\\probo\\context\\context_logic.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 @staticmethod def for_loop ( expression , for_block , style = \"mui\" , empty_content = None ): \"\"\" Generates a for-loop block string in the specified style. Args: expression (str): The loop expression (e.g., \"item in items\"). for_block (str): The content to repeat inside the loop. style (str): The syntax style to generate (\"mui\" or \"django\"). empty_content (str, optional): Content to display if the iterable is empty (Django style only). Returns: str: The formatted loop block string. \"\"\" empty = f \" {{ % empty % }} { empty_content } \" if empty_content else \"\" if style == \"mui\" : return f \"<$for { expression } > { for_block } </$for>\" elif style == \"django\" : return f \" {{ % for { expression } % }} { for_block }{ empty } {{ % endfor % }} \" else : return \"\" if_true ( expression , if_block , style = 'mui' , else_statement = None , ** elif_statements ) staticmethod Generates a conditional block string in the specified style (MUI or Django). Parameters: expression ( str ) \u2013 The condition to evaluate (e.g., \"user.is_admin\"). if_block ( str ) \u2013 Content to render if true. style ( str , default: 'mui' ) \u2013 The syntax style to generate (\"mui\" or \"django\"). else_statement ( str , default: None ) \u2013 Content for the else block. **elif_statements \u2013 Key-value pairs where key is condition and value is content for elif blocks. Returns: str \u2013 The formatted conditional block string. Source code in src\\probo\\context\\context_logic.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 @staticmethod def if_true ( expression , if_block , style = \"mui\" , else_statement = None , ** elif_statements ): \"\"\" Generates a conditional block string in the specified style (MUI or Django). Args: expression (str): The condition to evaluate (e.g., \"user.is_admin\"). if_block (str): Content to render if true. style (str): The syntax style to generate (\"mui\" or \"django\"). else_statement (str, optional): Content for the else block. **elif_statements: Key-value pairs where key is condition and value is content for elif blocks. Returns: str: The formatted conditional block string. \"\"\" if style == \"mui\" : return ( f \"<$if { expression } > { if_block } \" + \"\" . join ( [ f \"<$elif { cond } > { block } \" for cond , block in elif_statements . items () ] ) + ( f \"<$else> { else_statement } \" if else_statement else \"\" ) + \"</$if>\" ) elif style == \"django\" : return ( f \" {{ % if { expression } % }} { if_block } \" + \"\" . join ( [ f \" {{ % elif { cond } % }} { block } \" for cond , block in elif_statements . items () ] ) + ( f \" {{ % else % }} { else_statement } \" if else_statement else \"\" ) + \"{ % e ndif %}\" ) else : return \"\" render_template ( template_string , context = None ) The main entry point for rendering a template string. Merges the instance's global context with the provided local context and processes all template blocks (loops, ifs, vars). Parameters: template_string ( str ) \u2013 The raw template string to render. context ( dict , default: None ) \u2013 Additional local context for this specific render. Returns: str ( str ) \u2013 The fully rendered string. Source code in src\\probo\\context\\context_logic.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def render_template ( self , template_string : str , context : dict = None ) -> str : \"\"\" The main entry point for rendering a template string. Merges the instance's global context with the provided local context and processes all template blocks (loops, ifs, vars). Args: template_string (str): The raw template string to render. context (dict, optional): Additional local context for this specific render. Returns: str: The fully rendered string. \"\"\" effective_context = { ** self . _global_data_context , ** ( context or {})} return self . _process_template_block ( template_string , effective_context ) set_variable ( expression ) staticmethod Generates a variable output string. Parameters: expression ( str ) \u2013 The variable expression to output (e.g., \"user.name\"). Returns: str \u2013 The formatted variable string (e.g., \"{{ user.name }}\"). Source code in src\\probo\\context\\context_logic.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @staticmethod def set_variable ( expression , ): \"\"\" Generates a variable output string. Args: expression (str): The variable expression to output (e.g., \"user.name\"). Returns: str: The formatted variable string (e.g., \"{{ user.name }}\"). \"\"\" return f \" {{{{ { expression } }}}} \" loop ( data , renderer ) Iterates over data and generates elements using a renderer function. Parameters: data \u2013 An int (for simple duplication), a dict, or an iterable (list/queryset). renderer \u2013 A function/lambda that takes the item(s) and returns an Element, OR a static Element to simply duplicate. Returns: \u2013 A list of rendered elements. Source code in src\\probo\\context\\context_logic.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def loop ( data , renderer ): \"\"\" Iterates over data and generates elements using a renderer function. Args: data: An int (for simple duplication), a dict, or an iterable (list/queryset). renderer: A function/lambda that takes the item(s) and returns an Element, OR a static Element to simply duplicate. Returns: A list of rendered elements. \"\"\" results = [] iterator = [] if not renderer : renderer = lambda u : u # --- 1. NORMALIZE INPUT TO ITERATOR --- if isinstance ( data , int ): # Case: Integer -> Repeat N times # We use range so the renderer gets the index (0, 1, 2...) iterator = range ( data ) elif isinstance ( data , dict ): # Case: Dictionary -> Iterate over (key, value) pairs iterator = data . items () elif isinstance ( data , Iterable ) and not isinstance ( data , ( str , bytes )): # Case: List, QuerySet, Tuple, etc. iterator = data else : # Fallback: Treat as single item list iterator = [ data ] # --- 2. EXECUTE LOOP --- for item in iterator : if callable ( renderer ): # Dynamic: Pass data to the function (The \"Placeholder\" concept) if isinstance ( data , dict ): # For dicts, unpack key and value: renderer(key, value) key , value = item results . append ( renderer ( key , value )) else : # For lists/ints, pass the single item: renderer(item) results . append ( renderer ( item )) return results","title":"context_logic"},{"location":"reference/probo/context/context_logic/#context_logic","text":"","title":"context_logic"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.DynamicData","text":"data class to define and get dynamic data (from user or db) with custom manipulation plug in function for rendering components Source code in src\\probo\\context\\context_logic.py 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 @dataclass class DynamicData : \"\"\" data class to define and get dynamic data (from user or db) with custom manipulation plug in function for rendering components \"\"\" data_obj : Optional [ object ] = None processor : Optional [ Callable [[ Any ], Dict ]] = None dynamic_data : dict [ str , Any ] = field ( default_factory = dict ) def __post_init__ ( self ): \"\"\" This runs AUTOMATICALLY immediately after __init__. It processes the data_obj and populates dynamic_data instantly. \"\"\" if self . processor and callable ( self . processor ) and self . data_obj : self . dynamic_data = self . processor ( self . data_obj ) elif isinstance ( self . data_obj , dict ): self . dynamic_data = self . data_obj def get ( self , Value ): \"\"\" Retrieves a value from the processed dynamic data. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . dynamic_data . get ( Value , None ) # Optional: Keep this if you want a \"Safe Accessor\" that ensures a Dict return type @property def data ( self ) -> Dict : \"\"\" Safely accesses the full dynamic data dictionary. Returns: Dict: The dynamic data dictionary, ensuring a dict type is returned even if empty. \"\"\" return self . dynamic_data or {}","title":"DynamicData"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.DynamicData.data","text":"Safely accesses the full dynamic data dictionary. Returns: Dict ( Dict ) \u2013 The dynamic data dictionary, ensuring a dict type is returned even if empty.","title":"data"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.DynamicData.__post_init__","text":"This runs AUTOMATICALLY immediately after init . It processes the data_obj and populates dynamic_data instantly. Source code in src\\probo\\context\\context_logic.py 402 403 404 405 406 407 408 409 410 def __post_init__ ( self ): \"\"\" This runs AUTOMATICALLY immediately after __init__. It processes the data_obj and populates dynamic_data instantly. \"\"\" if self . processor and callable ( self . processor ) and self . data_obj : self . dynamic_data = self . processor ( self . data_obj ) elif isinstance ( self . data_obj , dict ): self . dynamic_data = self . data_obj","title":"__post_init__"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.DynamicData.get","text":"Retrieves a value from the processed dynamic data. Parameters: Value ( str ) \u2013 The key to look up. Returns: Any \u2013 The value associated with the key, or None if not found. Source code in src\\probo\\context\\context_logic.py 412 413 414 415 416 417 418 419 420 421 422 def get ( self , Value ): \"\"\" Retrieves a value from the processed dynamic data. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . dynamic_data . get ( Value , None )","title":"get"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.StaticData","text":"data class to define and get statiic data for rendering components Source code in src\\probo\\context\\context_logic.py 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 @dataclass class StaticData : \"\"\" data class to define and get statiic data for rendering components \"\"\" static_data : dict [ str , Any ] def get ( self , Value ): \"\"\" Retrieves a value from the static data dictionary. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . static_data . get ( Value , None )","title":"StaticData"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.StaticData.get","text":"Retrieves a value from the static data dictionary. Parameters: Value ( str ) \u2013 The key to look up. Returns: Any \u2013 The value associated with the key, or None if not found. Source code in src\\probo\\context\\context_logic.py 380 381 382 383 384 385 386 387 388 389 390 def get ( self , Value ): \"\"\" Retrieves a value from the static data dictionary. Args: Value (str): The key to look up. Returns: Any: The value associated with the key, or None if not found. \"\"\" return self . static_data . get ( Value , None )","title":"get"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateComponentMap","text":"Template Components Map is the cordinator that serves the right component to spesific view Source code in src\\probo\\context\\context_logic.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 class TemplateComponentMap : \"\"\"Template Components Map is the cordinator that serves the right component to spesific view\"\"\" def __init__ ( self , r_props : dict [ str , Any ] = None , ** url_name_comp ): self . url_name_comp = url_name_comp self . r_props = r_props or {} def get_component ( self , url_name ) -> str | tuple : \"\"\" Retrieves a component associated with a URL name and injects request properties. Args: url_name (str): The key/name representing the URL route. Returns: str | tuple: The rendered component (usually a string or HTML tuple). Raises: ValueError: If the url_name does not exist in the map. \"\"\" comp = self . url_name_comp . get ( url_name , None ) if comp : comp . props [ \"request-props\" ] = self . r_props . get ( \"request-props\" , {}) comp . props [ \"state-prop\" ] = self . r_props . get ( \"state-prop\" , {}) return comp . render () else : raise ValueError ( \"no such url maping\" ) def set_component ( self , url_name = None , component_name = None , ** url_name_comp ): \"\"\" Registers new components or updates existing mappings. Args: url_name (str, optional): The specific URL key to update. component_name (object, optional): The component object to associate. **url_name_comp: Additional mappings passed as keyword arguments. Returns: TemplateComponentMap: Self, allowing for method chaining. \"\"\" self . url_name_comp . update ( url_name_comp ) if url_name and component_name : self . url_name_comp [ url_name ] = component_name return self","title":"TemplateComponentMap"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateComponentMap.get_component","text":"Retrieves a component associated with a URL name and injects request properties. Parameters: url_name ( str ) \u2013 The key/name representing the URL route. Returns: str | tuple \u2013 str | tuple: The rendered component (usually a string or HTML tuple). Raises: ValueError \u2013 If the url_name does not exist in the map. Source code in src\\probo\\context\\context_logic.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 def get_component ( self , url_name ) -> str | tuple : \"\"\" Retrieves a component associated with a URL name and injects request properties. Args: url_name (str): The key/name representing the URL route. Returns: str | tuple: The rendered component (usually a string or HTML tuple). Raises: ValueError: If the url_name does not exist in the map. \"\"\" comp = self . url_name_comp . get ( url_name , None ) if comp : comp . props [ \"request-props\" ] = self . r_props . get ( \"request-props\" , {}) comp . props [ \"state-prop\" ] = self . r_props . get ( \"state-prop\" , {}) return comp . render () else : raise ValueError ( \"no such url maping\" )","title":"get_component"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateComponentMap.set_component","text":"Registers new components or updates existing mappings. Parameters: url_name ( str , default: None ) \u2013 The specific URL key to update. component_name ( object , default: None ) \u2013 The component object to associate. **url_name_comp \u2013 Additional mappings passed as keyword arguments. Returns: TemplateComponentMap \u2013 Self, allowing for method chaining. Source code in src\\probo\\context\\context_logic.py 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 def set_component ( self , url_name = None , component_name = None , ** url_name_comp ): \"\"\" Registers new components or updates existing mappings. Args: url_name (str, optional): The specific URL key to update. component_name (object, optional): The component object to associate. **url_name_comp: Additional mappings passed as keyword arguments. Returns: TemplateComponentMap: Self, allowing for method chaining. \"\"\" self . url_name_comp . update ( url_name_comp ) if url_name and component_name : self . url_name_comp [ url_name ] = component_name return self","title":"set_component"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateProcessor","text":"A class to process only 'mui' style template blocks but with support for generating Django-style template tags. Static methods are included. Source code in src\\probo\\context\\context_logic.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 class TemplateProcessor : \"\"\" A class to process only 'mui' style template blocks but with support for generating Django-style template tags. Static methods are included. \"\"\" SUPPORTED_STYLES = [ \"django\" , \"mui\" ] def __init__ ( self , data_context : dict = None ): \"\"\" Initializes the processor with a global data context. Args: data_context (dict, optional): A dictionary of global variables available to all templates rendered by this instance. \"\"\" self . _global_data_context = data_context if data_context is not None else {} def _evaluate_expression ( self , expression : str , current_context : dict ) -> Any : \"\"\" Safely evaluates a string expression within a given context. Args: expression (str): The python-like expression to evaluate (e.g., \"user.is_active\"). current_context (dict): The local context variables available for this evaluation. Returns: Any: The result of the evaluation, or None if an error occurs. \"\"\" full_context = { ** self . _global_data_context , ** current_context } try : return eval ( expression , {}, full_context ) except Exception as e : print ( f \"Error evaluating expression ' { expression } ': { e } \" ) return None def _apply_filter ( self , value : Any , filter_name : str ) -> Any : \"\"\" Applies a named transformation filter to a value. Supported filters: 'upper', 'lower', 'title', 'length'. Args: value (Any): The value to transform. filter_name (str): The name of the filter to apply. Returns: Any: The transformed value, or the original value if the filter is unknown. \"\"\" filters = { \"upper\" : lambda v : str ( v ) . upper (), \"lower\" : lambda v : str ( v ) . lower (), \"title\" : lambda v : str ( v ) . title (), \"length\" : lambda v : len ( v ) if hasattr ( v , \"__len__\" ) else len ( str ( v )), } return filters . get ( filter_name , lambda v : v )( value ) def _process_template_block ( self , text : str , current_context : dict ) -> str : \"\"\" recursively processes template logic within the text. It handles loops, conditional blocks, and variable substitutions in that specific order to ensure nested structures are rendered correctly. Args: text (str): The raw template string containing custom tags. current_context (dict): The data context for rendering. Returns: str: The fully rendered text string. \"\"\" text = self . _process_for_loops ( text , current_context ) text = self . _process_if_blocks ( text , current_context ) text = self . _process_variables ( text , current_context ) return text def _process_if_blocks ( self , text : str , context : dict ) -> str : \"\"\" Parses and evaluates custom <$if>...<$elif>...<$else>...<$/if> tags. It supports evaluating conditions dynamically against the provided context. Args: text (str): The text containing IF blocks. context (dict): The data context used to evaluate the conditions. Returns: str: The text with the correct block content retained and tags removed. \"\"\" # Matches <$if condition> ... <$else> ... </$if> if_pattern = re . compile ( r \"<\\$if (.+?)>(.*?)\" r \"(?:(?:<\\$elif (.+?)>(.*?))*)\" r \"(?:<\\$else>(.*?))?\" r \"</\\$if>\" , re . DOTALL , ) def repl ( match ): condition = match . group ( 1 ) . strip () if_block = match . group ( 2 ) elif_condition = match . group ( 3 ) elif_block = match . group ( 4 ) else_block = match . group ( 5 ) try : if self . _evaluate_expression ( condition , context ): return self . _process_template_block ( if_block , context ) elif elif_condition and self . _evaluate_expression ( elif_condition , context ): return self . _process_template_block ( elif_block , context ) elif else_block : return self . _process_template_block ( else_block , context ) except Exception as e : print ( f \"Error in IF evaluation: { e } \" ) return \"\" return if_pattern . sub ( repl , text ) def _process_for_loops ( self , text : str , context : dict ) -> str : \"\"\" Parses and evaluates custom <$for item in iterable>...<$/for> tags. Iterates over the provided collection and repeats the block content for each item. Args: text (str): The text containing FOR loops. context (dict): The data context containing the iterable variables. Returns: str: The text with the loop fully expanded. \"\"\" for_pattern = re . compile ( r \"<\\$for (.+?) in (.+?)>(.*?)</\\$for>\" , re . DOTALL ) def repl ( match ): loop_var = match . group ( 1 ) . strip () iterable = self . _evaluate_expression ( match . group ( 2 ) . strip (), context ) loop_content = match . group ( 3 ) if not iterable : return \"\" result = [] for item in iterable : local_context = { ** context , loop_var : item } result . append ( self . _process_template_block ( loop_content , local_context )) return \"\" . join ( result ) return for_pattern . sub ( repl , text ) def _process_variables ( self , text : str , context : dict ) -> str : \"\"\" Replaces {{ variable|filter }} syntax with actual values from the context. Args: text (str): The text containing variable placeholders. context (dict): The data context to look up values. Returns: str: The text with variables replaced by their string representations. \"\"\" # Matches variables like {{ var|filter }} var_pattern = re . compile ( r \"\\{\\{ (.+?) \\}\\}\" ) def repl ( match ): expr = match . group ( 1 ) if \"|\" in expr : var_name , filter_name = expr . split ( \"|\" , 1 ) value = self . _evaluate_expression ( var_name . strip (), context ) return str ( self . _apply_filter ( value , filter_name . strip ())) return str ( self . _evaluate_expression ( expr . strip (), context ) or \"\" ) return var_pattern . sub ( repl , text ) def render_template ( self , template_string : str , context : dict = None ) -> str : \"\"\" The main entry point for rendering a template string. Merges the instance's global context with the provided local context and processes all template blocks (loops, ifs, vars). Args: template_string (str): The raw template string to render. context (dict, optional): Additional local context for this specific render. Returns: str: The fully rendered string. \"\"\" effective_context = { ** self . _global_data_context , ** ( context or {})} return self . _process_template_block ( template_string , effective_context ) # ---------- STATIC METHODS FOR BLOCK CREATION ---------- @staticmethod def if_true ( expression , if_block , style = \"mui\" , else_statement = None , ** elif_statements ): \"\"\" Generates a conditional block string in the specified style (MUI or Django). Args: expression (str): The condition to evaluate (e.g., \"user.is_admin\"). if_block (str): Content to render if true. style (str): The syntax style to generate (\"mui\" or \"django\"). else_statement (str, optional): Content for the else block. **elif_statements: Key-value pairs where key is condition and value is content for elif blocks. Returns: str: The formatted conditional block string. \"\"\" if style == \"mui\" : return ( f \"<$if { expression } > { if_block } \" + \"\" . join ( [ f \"<$elif { cond } > { block } \" for cond , block in elif_statements . items () ] ) + ( f \"<$else> { else_statement } \" if else_statement else \"\" ) + \"</$if>\" ) elif style == \"django\" : return ( f \" {{ % if { expression } % }} { if_block } \" + \"\" . join ( [ f \" {{ % elif { cond } % }} { block } \" for cond , block in elif_statements . items () ] ) + ( f \" {{ % else % }} { else_statement } \" if else_statement else \"\" ) + \"{ % e ndif %}\" ) else : return \"\" @staticmethod def for_loop ( expression , for_block , style = \"mui\" , empty_content = None ): \"\"\" Generates a for-loop block string in the specified style. Args: expression (str): The loop expression (e.g., \"item in items\"). for_block (str): The content to repeat inside the loop. style (str): The syntax style to generate (\"mui\" or \"django\"). empty_content (str, optional): Content to display if the iterable is empty (Django style only). Returns: str: The formatted loop block string. \"\"\" empty = f \" {{ % empty % }} { empty_content } \" if empty_content else \"\" if style == \"mui\" : return f \"<$for { expression } > { for_block } </$for>\" elif style == \"django\" : return f \" {{ % for { expression } % }} { for_block }{ empty } {{ % endfor % }} \" else : return \"\" @staticmethod def set_variable ( expression , ): \"\"\" Generates a variable output string. Args: expression (str): The variable expression to output (e.g., \"user.name\"). Returns: str: The formatted variable string (e.g., \"{{ user.name }}\"). \"\"\" return f \" {{{{ { expression } }}}} \"","title":"TemplateProcessor"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateProcessor.__init__","text":"Initializes the processor with a global data context. Parameters: data_context ( dict , default: None ) \u2013 A dictionary of global variables available to all templates rendered by this instance. Source code in src\\probo\\context\\context_logic.py 16 17 18 19 20 21 22 23 24 def __init__ ( self , data_context : dict = None ): \"\"\" Initializes the processor with a global data context. Args: data_context (dict, optional): A dictionary of global variables available to all templates rendered by this instance. \"\"\" self . _global_data_context = data_context if data_context is not None else {}","title":"__init__"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateProcessor.for_loop","text":"Generates a for-loop block string in the specified style. Parameters: expression ( str ) \u2013 The loop expression (e.g., \"item in items\"). for_block ( str ) \u2013 The content to repeat inside the loop. style ( str , default: 'mui' ) \u2013 The syntax style to generate (\"mui\" or \"django\"). empty_content ( str , default: None ) \u2013 Content to display if the iterable is empty (Django style only). Returns: str \u2013 The formatted loop block string. Source code in src\\probo\\context\\context_logic.py 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 @staticmethod def for_loop ( expression , for_block , style = \"mui\" , empty_content = None ): \"\"\" Generates a for-loop block string in the specified style. Args: expression (str): The loop expression (e.g., \"item in items\"). for_block (str): The content to repeat inside the loop. style (str): The syntax style to generate (\"mui\" or \"django\"). empty_content (str, optional): Content to display if the iterable is empty (Django style only). Returns: str: The formatted loop block string. \"\"\" empty = f \" {{ % empty % }} { empty_content } \" if empty_content else \"\" if style == \"mui\" : return f \"<$for { expression } > { for_block } </$for>\" elif style == \"django\" : return f \" {{ % for { expression } % }} { for_block }{ empty } {{ % endfor % }} \" else : return \"\"","title":"for_loop"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateProcessor.if_true","text":"Generates a conditional block string in the specified style (MUI or Django). Parameters: expression ( str ) \u2013 The condition to evaluate (e.g., \"user.is_admin\"). if_block ( str ) \u2013 Content to render if true. style ( str , default: 'mui' ) \u2013 The syntax style to generate (\"mui\" or \"django\"). else_statement ( str , default: None ) \u2013 Content for the else block. **elif_statements \u2013 Key-value pairs where key is condition and value is content for elif blocks. Returns: str \u2013 The formatted conditional block string. Source code in src\\probo\\context\\context_logic.py 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 @staticmethod def if_true ( expression , if_block , style = \"mui\" , else_statement = None , ** elif_statements ): \"\"\" Generates a conditional block string in the specified style (MUI or Django). Args: expression (str): The condition to evaluate (e.g., \"user.is_admin\"). if_block (str): Content to render if true. style (str): The syntax style to generate (\"mui\" or \"django\"). else_statement (str, optional): Content for the else block. **elif_statements: Key-value pairs where key is condition and value is content for elif blocks. Returns: str: The formatted conditional block string. \"\"\" if style == \"mui\" : return ( f \"<$if { expression } > { if_block } \" + \"\" . join ( [ f \"<$elif { cond } > { block } \" for cond , block in elif_statements . items () ] ) + ( f \"<$else> { else_statement } \" if else_statement else \"\" ) + \"</$if>\" ) elif style == \"django\" : return ( f \" {{ % if { expression } % }} { if_block } \" + \"\" . join ( [ f \" {{ % elif { cond } % }} { block } \" for cond , block in elif_statements . items () ] ) + ( f \" {{ % else % }} { else_statement } \" if else_statement else \"\" ) + \"{ % e ndif %}\" ) else : return \"\"","title":"if_true"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateProcessor.render_template","text":"The main entry point for rendering a template string. Merges the instance's global context with the provided local context and processes all template blocks (loops, ifs, vars). Parameters: template_string ( str ) \u2013 The raw template string to render. context ( dict , default: None ) \u2013 Additional local context for this specific render. Returns: str ( str ) \u2013 The fully rendered string. Source code in src\\probo\\context\\context_logic.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 def render_template ( self , template_string : str , context : dict = None ) -> str : \"\"\" The main entry point for rendering a template string. Merges the instance's global context with the provided local context and processes all template blocks (loops, ifs, vars). Args: template_string (str): The raw template string to render. context (dict, optional): Additional local context for this specific render. Returns: str: The fully rendered string. \"\"\" effective_context = { ** self . _global_data_context , ** ( context or {})} return self . _process_template_block ( template_string , effective_context )","title":"render_template"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.TemplateProcessor.set_variable","text":"Generates a variable output string. Parameters: expression ( str ) \u2013 The variable expression to output (e.g., \"user.name\"). Returns: str \u2013 The formatted variable string (e.g., \"{{ user.name }}\"). Source code in src\\probo\\context\\context_logic.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 @staticmethod def set_variable ( expression , ): \"\"\" Generates a variable output string. Args: expression (str): The variable expression to output (e.g., \"user.name\"). Returns: str: The formatted variable string (e.g., \"{{ user.name }}\"). \"\"\" return f \" {{{{ { expression } }}}} \"","title":"set_variable"},{"location":"reference/probo/context/context_logic/#probo.context.context_logic.loop","text":"Iterates over data and generates elements using a renderer function. Parameters: data \u2013 An int (for simple duplication), a dict, or an iterable (list/queryset). renderer \u2013 A function/lambda that takes the item(s) and returns an Element, OR a static Element to simply duplicate. Returns: \u2013 A list of rendered elements. Source code in src\\probo\\context\\context_logic.py 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 def loop ( data , renderer ): \"\"\" Iterates over data and generates elements using a renderer function. Args: data: An int (for simple duplication), a dict, or an iterable (list/queryset). renderer: A function/lambda that takes the item(s) and returns an Element, OR a static Element to simply duplicate. Returns: A list of rendered elements. \"\"\" results = [] iterator = [] if not renderer : renderer = lambda u : u # --- 1. NORMALIZE INPUT TO ITERATOR --- if isinstance ( data , int ): # Case: Integer -> Repeat N times # We use range so the renderer gets the index (0, 1, 2...) iterator = range ( data ) elif isinstance ( data , dict ): # Case: Dictionary -> Iterate over (key, value) pairs iterator = data . items () elif isinstance ( data , Iterable ) and not isinstance ( data , ( str , bytes )): # Case: List, QuerySet, Tuple, etc. iterator = data else : # Fallback: Treat as single item list iterator = [ data ] # --- 2. EXECUTE LOOP --- for item in iterator : if callable ( renderer ): # Dynamic: Pass data to the function (The \"Placeholder\" concept) if isinstance ( data , dict ): # For dicts, unpack key and value: renderer(key, value) key , value = item results . append ( renderer ( key , value )) else : # For lists/ints, pass the single item: renderer(item) results . append ( renderer ( item )) return results","title":"loop"},{"location":"reference/probo/context/django/","text":"django DjangoComponent A declarative builder for Django Templates. Allows defining 'extends', 'blocks', raw template strings, and variables in Python. This class is framework-agnostic at import time. Actual rendering requires Django to be installed and configured in the execution environment. Source code in src\\probo\\context\\django.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class DjangoComponent : \"\"\" A declarative builder for Django Templates. Allows defining 'extends', 'blocks', raw template strings, and variables in Python. This class is framework-agnostic at import time. Actual rendering requires Django to be installed and configured in the execution environment. \"\"\" def __init__ ( self , template_string : str = \"\" , context : Dict [ str , Any ] = None , extends : str = None , ** kwargs , ): \"\"\" Initializes the DjangoComponent builder. Args: template_string (str, optional): The base raw template content. context (Dict[str, Any], optional): Initial context dictionary. extends (str, optional): The parent template to extend. **kwargs: Additional variables to be added to the context. \"\"\" self . raw_template = template_string self . context = context or {} self . extends_from = extends self . blocks : Dict [ str , str ] = {} # Store variables passed as kwargs for substitution self . variables = kwargs super () . __init__ () def extends ( self , template_name : str ): \"\"\" Sets the parent template (e.g. 'base.html'). Args: template_name (str): The name/path of the parent template. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . extends_from = template_name return self def add_block ( self , name : str , content : str ): \"\"\" Adds a named block to the template: {% block name %}...{% endblock %} Args: name (str): The name of the block. content (str): The content to insert into the block. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . blocks [ name ] = content return self def set_variables ( self , ** kwargs ): \"\"\" Sets context variables for the template. These are merged into the context at render time. Args: **kwargs: Key-value pairs representing template variables. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . variables . update ( kwargs ) return self def _build_vars ( self , source : str ) -> str : \"\"\" Compiles internal variable syntax into valid Django Template syntax. Converts <$probo-var name='variable_name'/> --> {{ variable_name }} Args: source (str): The template string containing internal variable placeholders. Returns: str: The template string with valid Django variable tags. \"\"\" # Regex matches <$probo-var name='...'/> or name=\"...\" pattern = r \"<\\$probo-var\\s+name=[' \\\" ](.*?)[' \\\" ]\\s*/>\" # Replace matches with Django variable syntax {{ ... }} compiled_source = re . sub ( pattern , r \"{{\\1}}\" , source ) return compiled_source def build_source ( self ) -> str : \"\"\" Constructs the final raw Django Template string by assembling extensions, blocks, and content. It combines: 1. The {% extends %} tag (if present). 2. All defined blocks. 3. Any raw template content. 4. Variable syntax translation. Returns: str: The complete, renderable Django template source string. \"\"\" parts = [] # 1. Extends if self . extends_from : parts . append ( f \" {{ % extends ' { self . extends_from } ' % }} \" ) # 2. Blocks (If extending) or Raw Content (If not) if self . blocks : for name , content in self . blocks . items (): parts . append ( f \" {{ % block { name } % }} { content } {{ % endblock % }} \" ) # Append raw template content if not just blocks if self . raw_template : parts . append ( self . raw_template ) raw_source = \" \\n \" . join ( parts ) # 3. Apply Variable Substitution (probo -> Django syntax) return self . _build_vars ( raw_source ) def render ( self , ) -> str : \"\"\" Renders the constructed template using Django. This method compiles the source and returns it as a string. Note: This currently returns the *source* string, but in a real Django environment, this would likely interact with `django.template.Template` and `Context`. Returns: str: The final template source string (ready for Django engine processing). \"\"\" source = self . build_source () return source __init__ ( template_string = '' , context = None , extends = None , ** kwargs ) Initializes the DjangoComponent builder. Parameters: template_string ( str , default: '' ) \u2013 The base raw template content. context ( Dict [ str , Any ] , default: None ) \u2013 Initial context dictionary. extends ( str , default: None ) \u2013 The parent template to extend. **kwargs \u2013 Additional variables to be added to the context. Source code in src\\probo\\context\\django.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def __init__ ( self , template_string : str = \"\" , context : Dict [ str , Any ] = None , extends : str = None , ** kwargs , ): \"\"\" Initializes the DjangoComponent builder. Args: template_string (str, optional): The base raw template content. context (Dict[str, Any], optional): Initial context dictionary. extends (str, optional): The parent template to extend. **kwargs: Additional variables to be added to the context. \"\"\" self . raw_template = template_string self . context = context or {} self . extends_from = extends self . blocks : Dict [ str , str ] = {} # Store variables passed as kwargs for substitution self . variables = kwargs super () . __init__ () add_block ( name , content ) Adds a named block to the template: {% block name %}...{% endblock %} Parameters: name ( str ) \u2013 The name of the block. content ( str ) \u2013 The content to insert into the block. Returns: DjangoComponent \u2013 Self, for method chaining. Source code in src\\probo\\context\\django.py 189 190 191 192 193 194 195 196 197 198 199 200 201 def add_block ( self , name : str , content : str ): \"\"\" Adds a named block to the template: {% block name %}...{% endblock %} Args: name (str): The name of the block. content (str): The content to insert into the block. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . blocks [ name ] = content return self build_source () Constructs the final raw Django Template string by assembling extensions, blocks, and content. It combines: 1. The {% extends %} tag (if present). 2. All defined blocks. 3. Any raw template content. 4. Variable syntax translation. Returns: str ( str ) \u2013 The complete, renderable Django template source string. Source code in src\\probo\\context\\django.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def build_source ( self ) -> str : \"\"\" Constructs the final raw Django Template string by assembling extensions, blocks, and content. It combines: 1. The {% extends %} tag (if present). 2. All defined blocks. 3. Any raw template content. 4. Variable syntax translation. Returns: str: The complete, renderable Django template source string. \"\"\" parts = [] # 1. Extends if self . extends_from : parts . append ( f \" {{ % extends ' { self . extends_from } ' % }} \" ) # 2. Blocks (If extending) or Raw Content (If not) if self . blocks : for name , content in self . blocks . items (): parts . append ( f \" {{ % block { name } % }} { content } {{ % endblock % }} \" ) # Append raw template content if not just blocks if self . raw_template : parts . append ( self . raw_template ) raw_source = \" \\n \" . join ( parts ) # 3. Apply Variable Substitution (probo -> Django syntax) return self . _build_vars ( raw_source ) extends ( template_name ) Sets the parent template (e.g. 'base.html'). Parameters: template_name ( str ) \u2013 The name/path of the parent template. Returns: DjangoComponent \u2013 Self, for method chaining. Source code in src\\probo\\context\\django.py 176 177 178 179 180 181 182 183 184 185 186 187 def extends ( self , template_name : str ): \"\"\" Sets the parent template (e.g. 'base.html'). Args: template_name (str): The name/path of the parent template. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . extends_from = template_name return self render () Renders the constructed template using Django. This method compiles the source and returns it as a string. Note: This currently returns the source string, but in a real Django environment, this would likely interact with django.template.Template and Context . Returns: str ( str ) \u2013 The final template source string (ready for Django engine processing). Source code in src\\probo\\context\\django.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def render ( self , ) -> str : \"\"\" Renders the constructed template using Django. This method compiles the source and returns it as a string. Note: This currently returns the *source* string, but in a real Django environment, this would likely interact with `django.template.Template` and `Context`. Returns: str: The final template source string (ready for Django engine processing). \"\"\" source = self . build_source () return source set_variables ( ** kwargs ) Sets context variables for the template. These are merged into the context at render time. Parameters: **kwargs \u2013 Key-value pairs representing template variables. Returns: DjangoComponent \u2013 Self, for method chaining. Source code in src\\probo\\context\\django.py 203 204 205 206 207 208 209 210 211 212 213 214 215 def set_variables ( self , ** kwargs ): \"\"\" Sets context variables for the template. These are merged into the context at render time. Args: **kwargs: Key-value pairs representing template variables. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . variables . update ( kwargs ) return self DjangoComponentTools Bases: TemplateProcessor Helper methods to generate Django Template Language (DTL) syntax blocks. Inherited by DjangoComponent to provide a fluent API for template logic. Source code in src\\probo\\context\\django.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class DjangoComponentTools ( TemplateProcessor ): \"\"\" Helper methods to generate Django Template Language (DTL) syntax blocks. Inherited by DjangoComponent to provide a fluent API for template logic. \"\"\" def __init__ ( self ): super () . __init__ () def If ( self , condition : str , content : str , else_content : str = None , ** elif_blocks ) -> str : \"\"\" Generates a standard Django IF block: {% if condition %}...{% endif %} Args: condition (str): The boolean expression to evaluate (e.g., \"user.is_authenticated\"). content (str): The template content to render if the condition is true. else_content (str, optional): The content for the {% else %} block. **elif_blocks: Key-value pairs where keys are conditions and values are content for {% elif %} blocks. Returns: str: The fully formatted Django template string. \"\"\" return self . if_true ( condition , content , style = \"django\" , else_statement = else_content , ** elif_blocks , ) def For ( self , item : str , iterable : str , content : str , empty_content = None , ) -> str : \"\"\" Generates a Django FOR loop: {% for item in iterable %}...{% endfor %} Args: item (str): The variable name for the current item in the loop. iterable (str): The collection or iterable to loop over. content (str): The template content to repeat for each item. empty_content (str, optional): Content to render in the {% empty %} block if the iterable is empty. Returns: str: The fully formatted Django template string. \"\"\" return self . for_loop ( f \" { item } in { iterable } \" , content , style = \"django\" , empty_content = empty_content , ) def Var ( self , variable_name : str ) -> str : \"\"\" Generates a Django variable tag: {{ variable_name }} Args: variable_name (str): The name of the variable to output. Returns: str: The formatted variable string. \"\"\" return self . set_variable ( variable_name ) @staticmethod def With ( assignments : str , content : str ) -> str : \"\"\" Generates a Django WITH block: {% with x=1 y=2 %}...{% endwith %} Args: assignments (str): The variable assignments (e.g., \"total=business.employees.count\"). content (str): The content where these variables are available. Returns: str: The formatted with-block string. \"\"\" return f \" {{ % with { assignments } % }}\\n { content } \\n{{ % endwith % }} \" @staticmethod def Comment ( content : str ) -> str : \"\"\" Generates a Django comment block: {# comment #} Args: content (str): The text content of the comment. Returns: str: The formatted comment string. \"\"\" return f \" {{ # { content } # }} \" @staticmethod def Include ( template_name : str , with_args : str = None ) -> str : \"\"\" Generates a Django INCLUDE tag: {% include 'name' %} Args: template_name (str): The path/name of the template to include. with_args (str, optional): Additional context variables to pass (e.g., \"arg=value\"). Returns: str: The formatted include tag. \"\"\" args = f \" with { with_args } \" if with_args else \"\" return f \" {{ % include ' { template_name } ' { args } % }} \" @staticmethod def Csrf () -> str : \"\"\" Generates the Django CSRF token tag: {% csrf_token %} Returns: str: The csrf token tag. \"\"\" return \"{ % c srf_token %}\" @staticmethod def Load ( library : str ) -> str : \"\"\" Generates a Django LOAD tag: {% load library %} Args: library (str): The name of the template library to load (e.g., \"static\"). Returns: str: The formatted load tag. \"\"\" return f \" {{ % load { library } % }} \" Comment ( content ) staticmethod Generates a Django comment block: {# comment #} Parameters: content ( str ) \u2013 The text content of the comment. Returns: str ( str ) \u2013 The formatted comment string. Source code in src\\probo\\context\\django.py 91 92 93 94 95 96 97 98 99 100 101 102 @staticmethod def Comment ( content : str ) -> str : \"\"\" Generates a Django comment block: {# comment #} Args: content (str): The text content of the comment. Returns: str: The formatted comment string. \"\"\" return f \" {{ # { content } # }} \" Csrf () staticmethod Generates the Django CSRF token tag: {% csrf_token %} Returns: str ( str ) \u2013 The csrf token tag. Source code in src\\probo\\context\\django.py 119 120 121 122 123 124 125 126 127 @staticmethod def Csrf () -> str : \"\"\" Generates the Django CSRF token tag: {% csrf_token %} Returns: str: The csrf token tag. \"\"\" return \"{ % c srf_token %}\" For ( item , iterable , content , empty_content = None ) Generates a Django FOR loop: {% for item in iterable %}...{% endfor %} Parameters: item ( str ) \u2013 The variable name for the current item in the loop. iterable ( str ) \u2013 The collection or iterable to loop over. content ( str ) \u2013 The template content to repeat for each item. empty_content ( str , default: None ) \u2013 Content to render in the {% empty %} block if the iterable is empty. Returns: str ( str ) \u2013 The fully formatted Django template string. Source code in src\\probo\\context\\django.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def For ( self , item : str , iterable : str , content : str , empty_content = None , ) -> str : \"\"\" Generates a Django FOR loop: {% for item in iterable %}...{% endfor %} Args: item (str): The variable name for the current item in the loop. iterable (str): The collection or iterable to loop over. content (str): The template content to repeat for each item. empty_content (str, optional): Content to render in the {% empty %} block if the iterable is empty. Returns: str: The fully formatted Django template string. \"\"\" return self . for_loop ( f \" { item } in { iterable } \" , content , style = \"django\" , empty_content = empty_content , ) If ( condition , content , else_content = None , ** elif_blocks ) Generates a standard Django IF block: {% if condition %}...{% endif %} Parameters: condition ( str ) \u2013 The boolean expression to evaluate (e.g., \"user.is_authenticated\"). content ( str ) \u2013 The template content to render if the condition is true. else_content ( str , default: None ) \u2013 The content for the {% else %} block. **elif_blocks \u2013 Key-value pairs where keys are conditions and values are content for {% elif %} blocks. Returns: str ( str ) \u2013 The fully formatted Django template string. Source code in src\\probo\\context\\django.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def If ( self , condition : str , content : str , else_content : str = None , ** elif_blocks ) -> str : \"\"\" Generates a standard Django IF block: {% if condition %}...{% endif %} Args: condition (str): The boolean expression to evaluate (e.g., \"user.is_authenticated\"). content (str): The template content to render if the condition is true. else_content (str, optional): The content for the {% else %} block. **elif_blocks: Key-value pairs where keys are conditions and values are content for {% elif %} blocks. Returns: str: The fully formatted Django template string. \"\"\" return self . if_true ( condition , content , style = \"django\" , else_statement = else_content , ** elif_blocks , ) Include ( template_name , with_args = None ) staticmethod Generates a Django INCLUDE tag: {% include 'name' %} Parameters: template_name ( str ) \u2013 The path/name of the template to include. with_args ( str , default: None ) \u2013 Additional context variables to pass (e.g., \"arg=value\"). Returns: str ( str ) \u2013 The formatted include tag. Source code in src\\probo\\context\\django.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @staticmethod def Include ( template_name : str , with_args : str = None ) -> str : \"\"\" Generates a Django INCLUDE tag: {% include 'name' %} Args: template_name (str): The path/name of the template to include. with_args (str, optional): Additional context variables to pass (e.g., \"arg=value\"). Returns: str: The formatted include tag. \"\"\" args = f \" with { with_args } \" if with_args else \"\" return f \" {{ % include ' { template_name } ' { args } % }} \" Load ( library ) staticmethod Generates a Django LOAD tag: {% load library %} Parameters: library ( str ) \u2013 The name of the template library to load (e.g., \"static\"). Returns: str ( str ) \u2013 The formatted load tag. Source code in src\\probo\\context\\django.py 129 130 131 132 133 134 135 136 137 138 139 140 @staticmethod def Load ( library : str ) -> str : \"\"\" Generates a Django LOAD tag: {% load library %} Args: library (str): The name of the template library to load (e.g., \"static\"). Returns: str: The formatted load tag. \"\"\" return f \" {{ % load { library } % }} \" Var ( variable_name ) Generates a Django variable tag: {{ variable_name }} Parameters: variable_name ( str ) \u2013 The name of the variable to output. Returns: str ( str ) \u2013 The formatted variable string. Source code in src\\probo\\context\\django.py 65 66 67 68 69 70 71 72 73 74 75 def Var ( self , variable_name : str ) -> str : \"\"\" Generates a Django variable tag: {{ variable_name }} Args: variable_name (str): The name of the variable to output. Returns: str: The formatted variable string. \"\"\" return self . set_variable ( variable_name ) With ( assignments , content ) staticmethod Generates a Django WITH block: {% with x=1 y=2 %}...{% endwith %} Parameters: assignments ( str ) \u2013 The variable assignments (e.g., \"total=business.employees.count\"). content ( str ) \u2013 The content where these variables are available. Returns: str ( str ) \u2013 The formatted with-block string. Source code in src\\probo\\context\\django.py 77 78 79 80 81 82 83 84 85 86 87 88 89 @staticmethod def With ( assignments : str , content : str ) -> str : \"\"\" Generates a Django WITH block: {% with x=1 y=2 %}...{% endwith %} Args: assignments (str): The variable assignments (e.g., \"total=business.employees.count\"). content (str): The content where these variables are available. Returns: str: The formatted with-block string. \"\"\" return f \" {{ % with { assignments } % }}\\n { content } \\n{{ % endwith % }} \"","title":"django"},{"location":"reference/probo/context/django/#django","text":"","title":"django"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent","text":"A declarative builder for Django Templates. Allows defining 'extends', 'blocks', raw template strings, and variables in Python. This class is framework-agnostic at import time. Actual rendering requires Django to be installed and configured in the execution environment. Source code in src\\probo\\context\\django.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 class DjangoComponent : \"\"\" A declarative builder for Django Templates. Allows defining 'extends', 'blocks', raw template strings, and variables in Python. This class is framework-agnostic at import time. Actual rendering requires Django to be installed and configured in the execution environment. \"\"\" def __init__ ( self , template_string : str = \"\" , context : Dict [ str , Any ] = None , extends : str = None , ** kwargs , ): \"\"\" Initializes the DjangoComponent builder. Args: template_string (str, optional): The base raw template content. context (Dict[str, Any], optional): Initial context dictionary. extends (str, optional): The parent template to extend. **kwargs: Additional variables to be added to the context. \"\"\" self . raw_template = template_string self . context = context or {} self . extends_from = extends self . blocks : Dict [ str , str ] = {} # Store variables passed as kwargs for substitution self . variables = kwargs super () . __init__ () def extends ( self , template_name : str ): \"\"\" Sets the parent template (e.g. 'base.html'). Args: template_name (str): The name/path of the parent template. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . extends_from = template_name return self def add_block ( self , name : str , content : str ): \"\"\" Adds a named block to the template: {% block name %}...{% endblock %} Args: name (str): The name of the block. content (str): The content to insert into the block. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . blocks [ name ] = content return self def set_variables ( self , ** kwargs ): \"\"\" Sets context variables for the template. These are merged into the context at render time. Args: **kwargs: Key-value pairs representing template variables. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . variables . update ( kwargs ) return self def _build_vars ( self , source : str ) -> str : \"\"\" Compiles internal variable syntax into valid Django Template syntax. Converts <$probo-var name='variable_name'/> --> {{ variable_name }} Args: source (str): The template string containing internal variable placeholders. Returns: str: The template string with valid Django variable tags. \"\"\" # Regex matches <$probo-var name='...'/> or name=\"...\" pattern = r \"<\\$probo-var\\s+name=[' \\\" ](.*?)[' \\\" ]\\s*/>\" # Replace matches with Django variable syntax {{ ... }} compiled_source = re . sub ( pattern , r \"{{\\1}}\" , source ) return compiled_source def build_source ( self ) -> str : \"\"\" Constructs the final raw Django Template string by assembling extensions, blocks, and content. It combines: 1. The {% extends %} tag (if present). 2. All defined blocks. 3. Any raw template content. 4. Variable syntax translation. Returns: str: The complete, renderable Django template source string. \"\"\" parts = [] # 1. Extends if self . extends_from : parts . append ( f \" {{ % extends ' { self . extends_from } ' % }} \" ) # 2. Blocks (If extending) or Raw Content (If not) if self . blocks : for name , content in self . blocks . items (): parts . append ( f \" {{ % block { name } % }} { content } {{ % endblock % }} \" ) # Append raw template content if not just blocks if self . raw_template : parts . append ( self . raw_template ) raw_source = \" \\n \" . join ( parts ) # 3. Apply Variable Substitution (probo -> Django syntax) return self . _build_vars ( raw_source ) def render ( self , ) -> str : \"\"\" Renders the constructed template using Django. This method compiles the source and returns it as a string. Note: This currently returns the *source* string, but in a real Django environment, this would likely interact with `django.template.Template` and `Context`. Returns: str: The final template source string (ready for Django engine processing). \"\"\" source = self . build_source () return source","title":"DjangoComponent"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent.__init__","text":"Initializes the DjangoComponent builder. Parameters: template_string ( str , default: '' ) \u2013 The base raw template content. context ( Dict [ str , Any ] , default: None ) \u2013 Initial context dictionary. extends ( str , default: None ) \u2013 The parent template to extend. **kwargs \u2013 Additional variables to be added to the context. Source code in src\\probo\\context\\django.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 def __init__ ( self , template_string : str = \"\" , context : Dict [ str , Any ] = None , extends : str = None , ** kwargs , ): \"\"\" Initializes the DjangoComponent builder. Args: template_string (str, optional): The base raw template content. context (Dict[str, Any], optional): Initial context dictionary. extends (str, optional): The parent template to extend. **kwargs: Additional variables to be added to the context. \"\"\" self . raw_template = template_string self . context = context or {} self . extends_from = extends self . blocks : Dict [ str , str ] = {} # Store variables passed as kwargs for substitution self . variables = kwargs super () . __init__ ()","title":"__init__"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent.add_block","text":"Adds a named block to the template: {% block name %}...{% endblock %} Parameters: name ( str ) \u2013 The name of the block. content ( str ) \u2013 The content to insert into the block. Returns: DjangoComponent \u2013 Self, for method chaining. Source code in src\\probo\\context\\django.py 189 190 191 192 193 194 195 196 197 198 199 200 201 def add_block ( self , name : str , content : str ): \"\"\" Adds a named block to the template: {% block name %}...{% endblock %} Args: name (str): The name of the block. content (str): The content to insert into the block. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . blocks [ name ] = content return self","title":"add_block"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent.build_source","text":"Constructs the final raw Django Template string by assembling extensions, blocks, and content. It combines: 1. The {% extends %} tag (if present). 2. All defined blocks. 3. Any raw template content. 4. Variable syntax translation. Returns: str ( str ) \u2013 The complete, renderable Django template source string. Source code in src\\probo\\context\\django.py 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def build_source ( self ) -> str : \"\"\" Constructs the final raw Django Template string by assembling extensions, blocks, and content. It combines: 1. The {% extends %} tag (if present). 2. All defined blocks. 3. Any raw template content. 4. Variable syntax translation. Returns: str: The complete, renderable Django template source string. \"\"\" parts = [] # 1. Extends if self . extends_from : parts . append ( f \" {{ % extends ' { self . extends_from } ' % }} \" ) # 2. Blocks (If extending) or Raw Content (If not) if self . blocks : for name , content in self . blocks . items (): parts . append ( f \" {{ % block { name } % }} { content } {{ % endblock % }} \" ) # Append raw template content if not just blocks if self . raw_template : parts . append ( self . raw_template ) raw_source = \" \\n \" . join ( parts ) # 3. Apply Variable Substitution (probo -> Django syntax) return self . _build_vars ( raw_source )","title":"build_source"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent.extends","text":"Sets the parent template (e.g. 'base.html'). Parameters: template_name ( str ) \u2013 The name/path of the parent template. Returns: DjangoComponent \u2013 Self, for method chaining. Source code in src\\probo\\context\\django.py 176 177 178 179 180 181 182 183 184 185 186 187 def extends ( self , template_name : str ): \"\"\" Sets the parent template (e.g. 'base.html'). Args: template_name (str): The name/path of the parent template. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . extends_from = template_name return self","title":"extends"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent.render","text":"Renders the constructed template using Django. This method compiles the source and returns it as a string. Note: This currently returns the source string, but in a real Django environment, this would likely interact with django.template.Template and Context . Returns: str ( str ) \u2013 The final template source string (ready for Django engine processing). Source code in src\\probo\\context\\django.py 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 def render ( self , ) -> str : \"\"\" Renders the constructed template using Django. This method compiles the source and returns it as a string. Note: This currently returns the *source* string, but in a real Django environment, this would likely interact with `django.template.Template` and `Context`. Returns: str: The final template source string (ready for Django engine processing). \"\"\" source = self . build_source () return source","title":"render"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponent.set_variables","text":"Sets context variables for the template. These are merged into the context at render time. Parameters: **kwargs \u2013 Key-value pairs representing template variables. Returns: DjangoComponent \u2013 Self, for method chaining. Source code in src\\probo\\context\\django.py 203 204 205 206 207 208 209 210 211 212 213 214 215 def set_variables ( self , ** kwargs ): \"\"\" Sets context variables for the template. These are merged into the context at render time. Args: **kwargs: Key-value pairs representing template variables. Returns: DjangoComponent: Self, for method chaining. \"\"\" self . variables . update ( kwargs ) return self","title":"set_variables"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools","text":"Bases: TemplateProcessor Helper methods to generate Django Template Language (DTL) syntax blocks. Inherited by DjangoComponent to provide a fluent API for template logic. Source code in src\\probo\\context\\django.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class DjangoComponentTools ( TemplateProcessor ): \"\"\" Helper methods to generate Django Template Language (DTL) syntax blocks. Inherited by DjangoComponent to provide a fluent API for template logic. \"\"\" def __init__ ( self ): super () . __init__ () def If ( self , condition : str , content : str , else_content : str = None , ** elif_blocks ) -> str : \"\"\" Generates a standard Django IF block: {% if condition %}...{% endif %} Args: condition (str): The boolean expression to evaluate (e.g., \"user.is_authenticated\"). content (str): The template content to render if the condition is true. else_content (str, optional): The content for the {% else %} block. **elif_blocks: Key-value pairs where keys are conditions and values are content for {% elif %} blocks. Returns: str: The fully formatted Django template string. \"\"\" return self . if_true ( condition , content , style = \"django\" , else_statement = else_content , ** elif_blocks , ) def For ( self , item : str , iterable : str , content : str , empty_content = None , ) -> str : \"\"\" Generates a Django FOR loop: {% for item in iterable %}...{% endfor %} Args: item (str): The variable name for the current item in the loop. iterable (str): The collection or iterable to loop over. content (str): The template content to repeat for each item. empty_content (str, optional): Content to render in the {% empty %} block if the iterable is empty. Returns: str: The fully formatted Django template string. \"\"\" return self . for_loop ( f \" { item } in { iterable } \" , content , style = \"django\" , empty_content = empty_content , ) def Var ( self , variable_name : str ) -> str : \"\"\" Generates a Django variable tag: {{ variable_name }} Args: variable_name (str): The name of the variable to output. Returns: str: The formatted variable string. \"\"\" return self . set_variable ( variable_name ) @staticmethod def With ( assignments : str , content : str ) -> str : \"\"\" Generates a Django WITH block: {% with x=1 y=2 %}...{% endwith %} Args: assignments (str): The variable assignments (e.g., \"total=business.employees.count\"). content (str): The content where these variables are available. Returns: str: The formatted with-block string. \"\"\" return f \" {{ % with { assignments } % }}\\n { content } \\n{{ % endwith % }} \" @staticmethod def Comment ( content : str ) -> str : \"\"\" Generates a Django comment block: {# comment #} Args: content (str): The text content of the comment. Returns: str: The formatted comment string. \"\"\" return f \" {{ # { content } # }} \" @staticmethod def Include ( template_name : str , with_args : str = None ) -> str : \"\"\" Generates a Django INCLUDE tag: {% include 'name' %} Args: template_name (str): The path/name of the template to include. with_args (str, optional): Additional context variables to pass (e.g., \"arg=value\"). Returns: str: The formatted include tag. \"\"\" args = f \" with { with_args } \" if with_args else \"\" return f \" {{ % include ' { template_name } ' { args } % }} \" @staticmethod def Csrf () -> str : \"\"\" Generates the Django CSRF token tag: {% csrf_token %} Returns: str: The csrf token tag. \"\"\" return \"{ % c srf_token %}\" @staticmethod def Load ( library : str ) -> str : \"\"\" Generates a Django LOAD tag: {% load library %} Args: library (str): The name of the template library to load (e.g., \"static\"). Returns: str: The formatted load tag. \"\"\" return f \" {{ % load { library } % }} \"","title":"DjangoComponentTools"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.Comment","text":"Generates a Django comment block: {# comment #} Parameters: content ( str ) \u2013 The text content of the comment. Returns: str ( str ) \u2013 The formatted comment string. Source code in src\\probo\\context\\django.py 91 92 93 94 95 96 97 98 99 100 101 102 @staticmethod def Comment ( content : str ) -> str : \"\"\" Generates a Django comment block: {# comment #} Args: content (str): The text content of the comment. Returns: str: The formatted comment string. \"\"\" return f \" {{ # { content } # }} \"","title":"Comment"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.Csrf","text":"Generates the Django CSRF token tag: {% csrf_token %} Returns: str ( str ) \u2013 The csrf token tag. Source code in src\\probo\\context\\django.py 119 120 121 122 123 124 125 126 127 @staticmethod def Csrf () -> str : \"\"\" Generates the Django CSRF token tag: {% csrf_token %} Returns: str: The csrf token tag. \"\"\" return \"{ % c srf_token %}\"","title":"Csrf"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.For","text":"Generates a Django FOR loop: {% for item in iterable %}...{% endfor %} Parameters: item ( str ) \u2013 The variable name for the current item in the loop. iterable ( str ) \u2013 The collection or iterable to loop over. content ( str ) \u2013 The template content to repeat for each item. empty_content ( str , default: None ) \u2013 Content to render in the {% empty %} block if the iterable is empty. Returns: str ( str ) \u2013 The fully formatted Django template string. Source code in src\\probo\\context\\django.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def For ( self , item : str , iterable : str , content : str , empty_content = None , ) -> str : \"\"\" Generates a Django FOR loop: {% for item in iterable %}...{% endfor %} Args: item (str): The variable name for the current item in the loop. iterable (str): The collection or iterable to loop over. content (str): The template content to repeat for each item. empty_content (str, optional): Content to render in the {% empty %} block if the iterable is empty. Returns: str: The fully formatted Django template string. \"\"\" return self . for_loop ( f \" { item } in { iterable } \" , content , style = \"django\" , empty_content = empty_content , )","title":"For"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.If","text":"Generates a standard Django IF block: {% if condition %}...{% endif %} Parameters: condition ( str ) \u2013 The boolean expression to evaluate (e.g., \"user.is_authenticated\"). content ( str ) \u2013 The template content to render if the condition is true. else_content ( str , default: None ) \u2013 The content for the {% else %} block. **elif_blocks \u2013 Key-value pairs where keys are conditions and values are content for {% elif %} blocks. Returns: str ( str ) \u2013 The fully formatted Django template string. Source code in src\\probo\\context\\django.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 def If ( self , condition : str , content : str , else_content : str = None , ** elif_blocks ) -> str : \"\"\" Generates a standard Django IF block: {% if condition %}...{% endif %} Args: condition (str): The boolean expression to evaluate (e.g., \"user.is_authenticated\"). content (str): The template content to render if the condition is true. else_content (str, optional): The content for the {% else %} block. **elif_blocks: Key-value pairs where keys are conditions and values are content for {% elif %} blocks. Returns: str: The fully formatted Django template string. \"\"\" return self . if_true ( condition , content , style = \"django\" , else_statement = else_content , ** elif_blocks , )","title":"If"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.Include","text":"Generates a Django INCLUDE tag: {% include 'name' %} Parameters: template_name ( str ) \u2013 The path/name of the template to include. with_args ( str , default: None ) \u2013 Additional context variables to pass (e.g., \"arg=value\"). Returns: str ( str ) \u2013 The formatted include tag. Source code in src\\probo\\context\\django.py 104 105 106 107 108 109 110 111 112 113 114 115 116 117 @staticmethod def Include ( template_name : str , with_args : str = None ) -> str : \"\"\" Generates a Django INCLUDE tag: {% include 'name' %} Args: template_name (str): The path/name of the template to include. with_args (str, optional): Additional context variables to pass (e.g., \"arg=value\"). Returns: str: The formatted include tag. \"\"\" args = f \" with { with_args } \" if with_args else \"\" return f \" {{ % include ' { template_name } ' { args } % }} \"","title":"Include"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.Load","text":"Generates a Django LOAD tag: {% load library %} Parameters: library ( str ) \u2013 The name of the template library to load (e.g., \"static\"). Returns: str ( str ) \u2013 The formatted load tag. Source code in src\\probo\\context\\django.py 129 130 131 132 133 134 135 136 137 138 139 140 @staticmethod def Load ( library : str ) -> str : \"\"\" Generates a Django LOAD tag: {% load library %} Args: library (str): The name of the template library to load (e.g., \"static\"). Returns: str: The formatted load tag. \"\"\" return f \" {{ % load { library } % }} \"","title":"Load"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.Var","text":"Generates a Django variable tag: {{ variable_name }} Parameters: variable_name ( str ) \u2013 The name of the variable to output. Returns: str ( str ) \u2013 The formatted variable string. Source code in src\\probo\\context\\django.py 65 66 67 68 69 70 71 72 73 74 75 def Var ( self , variable_name : str ) -> str : \"\"\" Generates a Django variable tag: {{ variable_name }} Args: variable_name (str): The name of the variable to output. Returns: str: The formatted variable string. \"\"\" return self . set_variable ( variable_name )","title":"Var"},{"location":"reference/probo/context/django/#probo.context.django.DjangoComponentTools.With","text":"Generates a Django WITH block: {% with x=1 y=2 %}...{% endwith %} Parameters: assignments ( str ) \u2013 The variable assignments (e.g., \"total=business.employees.count\"). content ( str ) \u2013 The content where these variables are available. Returns: str ( str ) \u2013 The formatted with-block string. Source code in src\\probo\\context\\django.py 77 78 79 80 81 82 83 84 85 86 87 88 89 @staticmethod def With ( assignments : str , content : str ) -> str : \"\"\" Generates a Django WITH block: {% with x=1 y=2 %}...{% endwith %} Args: assignments (str): The variable assignments (e.g., \"total=business.employees.count\"). content (str): The content where these variables are available. Returns: str: The formatted with-block string. \"\"\" return f \" {{ % with { assignments } % }}\\n { content } \\n{{ % endwith % }} \"","title":"With"},{"location":"reference/probo/htmx/htmx/","text":"htmx Ajax Helper to build HTMX AJAX attributes Source code in src\\probo\\htmx\\htmx.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Ajax : \"\"\"Helper to build HTMX AJAX attributes\"\"\" def __init__ ( self , ): self . AJAX_HX_DICT = dict () def hx_get ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . GET . value ] = url return self def hx_post ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . POST . value ] = url return self def hx_put ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . PUT . value ] = url return self def hx_patch ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . PATCH . value ] = url return self def hx_delete ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . DELETE . value ] = url return self def hx_target ( self , selector : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . TARGET . value ] = selector return self def hx_trigger ( self , trigger_str : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . TRIGGER . value ] = trigger_str return self def hx_swap ( self , swap_str : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . SWAP . value ] = swap_str return self def hx_indicator ( self , selector : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . INDICATOR . value ] = selector return self def get_values ( self ): return self . AJAX_HX_DICT HTMX The 'Bucket' or Registry for HTMX configurations. Holds multiple HTMXElement configurations by name for reuse across templates. This acts as a central store for your application's interactive behaviors, allowing you to define HTMX logic in one place and inject it into various components or templates by name. Parameters: use_cdn ( bool , default: True ) \u2013 If True, provides the HTMX CDN script tag via get_script_tag(). Defaults to True. local_path ( str , default: None ) \u2013 Path to local HTMX script if use_cdn is False. **htmx_elemets ( HTMXElement , default: {} ) \u2013 Named HTMXElement instances passed as keyword arguments. Example btn = HTMXElement(\"button\",\"click me!!\", hx_post=\"/save\") bucket = HTMX(save_btn=btn) print(bucket.elements.get(\"save_btn\").render()) click me!! Source code in src\\probo\\htmx\\htmx.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class HTMX : \"\"\" The 'Bucket' or Registry for HTMX configurations. Holds multiple HTMXElement configurations by name for reuse across templates. This acts as a central store for your application's interactive behaviors, allowing you to define HTMX logic in one place and inject it into various components or templates by name. Args: use_cdn (bool, optional): If True, provides the HTMX CDN script tag via get_script_tag(). Defaults to True. local_path (str, optional): Path to local HTMX script if use_cdn is False. **htmx_elemets (HTMXElement): Named HTMXElement instances passed as keyword arguments. Example: >>> btn = HTMXElement(\"button\",\"click me!!\", hx_post=\"/save\") >>> bucket = HTMX(save_btn=btn) >>> print(bucket.elements.get(\"save_btn\").render()) <button hx-post=\"/save\">click me!!</button> \"\"\" def __init__ ( self , use_cdn : bool = True , local_path : Optional [ str ] = None , ** htmx_elemets : dict [ str , HTMXElement ], ): self . elements = htmx_elemets self . script_tag = self . get_script_tag ( use_cdn , local_path ) def get_script_tag ( self , use_cdn : bool = True , local_path : Optional [ str ] = None ): \"\"\"Return a script element for HTMX JS\"\"\" src = HTMX_CDN_URL if use_cdn else ( local_path or LOCAL_TEMPO_PATH ) return Srpt ( src = src ) def include ( self , ** htmx_elemets : dict [ str , str ]): self . elements . update ( htmx_elemets ) return self def add ( self , element , value ): self . elements [ element ] = value return self def render ( self , element = None , all_elements = False , as_string = True ): if all_elements : return \"\" . join ([ el . render () for el in self . elements . values ()]) el = self . elements . get ( element , None ) if el : return el . render () if as_string else el else : return el get_script_tag ( use_cdn = True , local_path = None ) Return a script element for HTMX JS Source code in src\\probo\\htmx\\htmx.py 225 226 227 228 def get_script_tag ( self , use_cdn : bool = True , local_path : Optional [ str ] = None ): \"\"\"Return a script element for HTMX JS\"\"\" src = HTMX_CDN_URL if use_cdn else ( local_path or LOCAL_TEMPO_PATH ) return Srpt ( src = src ) HTMXElement Bases: Ajax Represents a single HTMX configuration. Can be rendered as a full HTML Element OR just a string of Attributes. This class provides a fluent API for building HTMX interactions. It supports standard attributes like hx-get, hx-post, hx-target, and hx-swap, normalized from Python snake_case (hx_get) to HTML kebab-case (hx-get). Parameters: element_tag ( str , default: None ) \u2013 The HTML tag name (e.g., 'button'). If None, renders attributes only. content ( str , default: None ) \u2013 The inner content of the element (if tag is provided). template_info ( dict , default: None ) \u2013 a dict with tags attrs exists in a the template to avoid deat referencing **hx_attrs \u2013 Arbitrary HTMX attributes (e.g., hx_post='/api/save', hx_target='#result'). Attributes: attrs ( dict ) \u2013 The normalized dictionary of HTML attributes. Example Fluent API btn = HTMXElement(\"button\", content=\"Save\") btn.hx_post(\"/save\").hx_target(\"#status\").hx_swap(\"outerHTML\") print(btn.render()) Save Attribute Bag attrs = HTMXElement().hx_get(\"/search\").hx_trigger(\"keyup\") print(attrs.render()) hx-get=\"/search\" hx-trigger=\"keyup\" Source code in src\\probo\\htmx\\htmx.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class HTMXElement ( Ajax ): \"\"\" Represents a single HTMX configuration. Can be rendered as a full HTML Element OR just a string of Attributes. This class provides a fluent API for building HTMX interactions. It supports standard attributes like hx-get, hx-post, hx-target, and hx-swap, normalized from Python snake_case (hx_get) to HTML kebab-case (hx-get). Args: element_tag (str, optional): The HTML tag name (e.g., 'button'). If None, renders attributes only. content (str, optional): The inner content of the element (if tag is provided). template_info: a dict with tags attrs exists in a the template to avoid deat referencing **hx_attrs: Arbitrary HTMX attributes (e.g., hx_post='/api/save', hx_target='#result'). Attributes: attrs (dict): The normalized dictionary of HTML attributes. Example: >>> # Fluent API >>> btn = HTMXElement(\"button\", content=\"Save\") >>> btn.hx_post(\"/save\").hx_target(\"#status\").hx_swap(\"outerHTML\") >>> print(btn.render()) <button hx-post=\"/save\" hx-target=\"#status\" hx-swap=\"outerHTML\">Save</button> >>> # Attribute Bag >>> attrs = HTMXElement().hx_get(\"/search\").hx_trigger(\"keyup\") >>> print(attrs.render()) hx-get=\"/search\" hx-trigger=\"keyup\" \"\"\" def __init__ ( self , element_tag : str = None , content : str = None , template_info : dict = None , ** hx_attrs , ): \"\"\" :param use_cdn: Use CDN link or local script path :param local_path: Path to local `htmx.min.js` if not using CDN \"\"\" self . hx_params = HxParams self . hx_bool_val = HxBoolValue self . hx_funcs = Ajax self . hx_attrs = hx_attrs self . element_tag = element_tag self . content = content or str () self . template_info = template_info or dict () self . attr_manager = ElementAttributeManipulator ( self . hx_attrs ) super () . __init__ () if template_info and template_info . get ( \"tags\" , []): if element not in template_info . get ( \"tags\" , []): raise ValueError ( \"elemet not in tag\" ) def set_attr ( self , ** attrs ) -> \"HTMXElement\" : for attribute , value in attrs . items (): try : attr_name = HxAttr [ attribute . upper ()] . value except : attr_name = attribute self . hx_attrs [ attr_name ] = value return self def get_attr ( self , attribute : str ) -> Any : attr_name = self . hx_attrs . get ( attribute , None ) return attr_name def del_attr ( self , attribute : str ) -> \"HTMXElement\" : self . hx_attrs . pop ( attribute , None ) return self def build_trigger_string ( self , event : str , modifiers : Optional [ Dict [ str , str ]] = None , filters : Optional [ List [ str ]] = None , ) -> \"HTMXElement\" : base = HxTrigger [ event ] . value if event in HxTrigger else event parts = [ base ] if modifiers : parts . extend ( f \" { k } : { v } \" for k , v in modifiers . items ()) if filters : parts . append ( f \"[ { ' and ' . join ( filters ) } ]\" ) self . hx_attrs [ HxAttr . TRIGGER . value ] = \" \" . join ( parts ) return self def build_swap_string ( self , name : str , modifiers : Optional [ Dict [ str , str ]] = None ) -> \"HTMXElement\" : base = HxSwap [ name ] . value if name in HxSwap else name parts = [ base ] if modifiers : parts . extend ( f \" { k } : { v } \" for k , v in modifiers . items ()) self . hx_attrs [ HxAttr . SWAP . value ] = \" \" . join ( parts ) return self def build_sync_string ( self , element : str , strategy : str ) -> \"HTMXElement\" : self . hx_attrs [ HxAttr . SYNC . value ] = ( f \" { element } : { HxSyncStrategy [ strategy ] . value if strategy in HxSyncStrategy else strategy } \" ) return self def render ( self , as_string = True , ) -> str | dict [ str , str ]: if self . AJAX_HX_DICT : self . hx_attrs . update ( self . AJAX_HX_DICT ) if self . element_tag : return ( Element ( content = self . content , ** self . hx_attrs ) . custom_element ( self . element_tag , ) . element ) if as_string : return f \" { r ( self . element_tag , self . hx_attrs ) } \" else : return self . hx_attrs __init__ ( element_tag = None , content = None , template_info = None , ** hx_attrs ) :param use_cdn: Use CDN link or local script path :param local_path: Path to local htmx.min.js if not using CDN Source code in src\\probo\\htmx\\htmx.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def __init__ ( self , element_tag : str = None , content : str = None , template_info : dict = None , ** hx_attrs , ): \"\"\" :param use_cdn: Use CDN link or local script path :param local_path: Path to local `htmx.min.js` if not using CDN \"\"\" self . hx_params = HxParams self . hx_bool_val = HxBoolValue self . hx_funcs = Ajax self . hx_attrs = hx_attrs self . element_tag = element_tag self . content = content or str () self . template_info = template_info or dict () self . attr_manager = ElementAttributeManipulator ( self . hx_attrs ) super () . __init__ () if template_info and template_info . get ( \"tags\" , []): if element not in template_info . get ( \"tags\" , []): raise ValueError ( \"elemet not in tag\" )","title":"htmx"},{"location":"reference/probo/htmx/htmx/#htmx","text":"","title":"htmx"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.Ajax","text":"Helper to build HTMX AJAX attributes Source code in src\\probo\\htmx\\htmx.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class Ajax : \"\"\"Helper to build HTMX AJAX attributes\"\"\" def __init__ ( self , ): self . AJAX_HX_DICT = dict () def hx_get ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . GET . value ] = url return self def hx_post ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . POST . value ] = url return self def hx_put ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . PUT . value ] = url return self def hx_patch ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . PATCH . value ] = url return self def hx_delete ( self , url : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . DELETE . value ] = url return self def hx_target ( self , selector : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . TARGET . value ] = selector return self def hx_trigger ( self , trigger_str : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . TRIGGER . value ] = trigger_str return self def hx_swap ( self , swap_str : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . SWAP . value ] = swap_str return self def hx_indicator ( self , selector : str ) -> Dict [ str , str ]: self . AJAX_HX_DICT [ HxAttr . INDICATOR . value ] = selector return self def get_values ( self ): return self . AJAX_HX_DICT","title":"Ajax"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.HTMX","text":"The 'Bucket' or Registry for HTMX configurations. Holds multiple HTMXElement configurations by name for reuse across templates. This acts as a central store for your application's interactive behaviors, allowing you to define HTMX logic in one place and inject it into various components or templates by name. Parameters: use_cdn ( bool , default: True ) \u2013 If True, provides the HTMX CDN script tag via get_script_tag(). Defaults to True. local_path ( str , default: None ) \u2013 Path to local HTMX script if use_cdn is False. **htmx_elemets ( HTMXElement , default: {} ) \u2013 Named HTMXElement instances passed as keyword arguments. Example btn = HTMXElement(\"button\",\"click me!!\", hx_post=\"/save\") bucket = HTMX(save_btn=btn) print(bucket.elements.get(\"save_btn\").render()) click me!! Source code in src\\probo\\htmx\\htmx.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class HTMX : \"\"\" The 'Bucket' or Registry for HTMX configurations. Holds multiple HTMXElement configurations by name for reuse across templates. This acts as a central store for your application's interactive behaviors, allowing you to define HTMX logic in one place and inject it into various components or templates by name. Args: use_cdn (bool, optional): If True, provides the HTMX CDN script tag via get_script_tag(). Defaults to True. local_path (str, optional): Path to local HTMX script if use_cdn is False. **htmx_elemets (HTMXElement): Named HTMXElement instances passed as keyword arguments. Example: >>> btn = HTMXElement(\"button\",\"click me!!\", hx_post=\"/save\") >>> bucket = HTMX(save_btn=btn) >>> print(bucket.elements.get(\"save_btn\").render()) <button hx-post=\"/save\">click me!!</button> \"\"\" def __init__ ( self , use_cdn : bool = True , local_path : Optional [ str ] = None , ** htmx_elemets : dict [ str , HTMXElement ], ): self . elements = htmx_elemets self . script_tag = self . get_script_tag ( use_cdn , local_path ) def get_script_tag ( self , use_cdn : bool = True , local_path : Optional [ str ] = None ): \"\"\"Return a script element for HTMX JS\"\"\" src = HTMX_CDN_URL if use_cdn else ( local_path or LOCAL_TEMPO_PATH ) return Srpt ( src = src ) def include ( self , ** htmx_elemets : dict [ str , str ]): self . elements . update ( htmx_elemets ) return self def add ( self , element , value ): self . elements [ element ] = value return self def render ( self , element = None , all_elements = False , as_string = True ): if all_elements : return \"\" . join ([ el . render () for el in self . elements . values ()]) el = self . elements . get ( element , None ) if el : return el . render () if as_string else el else : return el","title":"HTMX"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.HTMX.get_script_tag","text":"Return a script element for HTMX JS Source code in src\\probo\\htmx\\htmx.py 225 226 227 228 def get_script_tag ( self , use_cdn : bool = True , local_path : Optional [ str ] = None ): \"\"\"Return a script element for HTMX JS\"\"\" src = HTMX_CDN_URL if use_cdn else ( local_path or LOCAL_TEMPO_PATH ) return Srpt ( src = src )","title":"get_script_tag"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.HTMXElement","text":"Bases: Ajax Represents a single HTMX configuration. Can be rendered as a full HTML Element OR just a string of Attributes. This class provides a fluent API for building HTMX interactions. It supports standard attributes like hx-get, hx-post, hx-target, and hx-swap, normalized from Python snake_case (hx_get) to HTML kebab-case (hx-get). Parameters: element_tag ( str , default: None ) \u2013 The HTML tag name (e.g., 'button'). If None, renders attributes only. content ( str , default: None ) \u2013 The inner content of the element (if tag is provided). template_info ( dict , default: None ) \u2013 a dict with tags attrs exists in a the template to avoid deat referencing **hx_attrs \u2013 Arbitrary HTMX attributes (e.g., hx_post='/api/save', hx_target='#result'). Attributes: attrs ( dict ) \u2013 The normalized dictionary of HTML attributes. Example","title":"HTMXElement"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.HTMXElement--fluent-api","text":"btn = HTMXElement(\"button\", content=\"Save\") btn.hx_post(\"/save\").hx_target(\"#status\").hx_swap(\"outerHTML\") print(btn.render()) Save","title":"Fluent API"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.HTMXElement--attribute-bag","text":"attrs = HTMXElement().hx_get(\"/search\").hx_trigger(\"keyup\") print(attrs.render()) hx-get=\"/search\" hx-trigger=\"keyup\" Source code in src\\probo\\htmx\\htmx.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 class HTMXElement ( Ajax ): \"\"\" Represents a single HTMX configuration. Can be rendered as a full HTML Element OR just a string of Attributes. This class provides a fluent API for building HTMX interactions. It supports standard attributes like hx-get, hx-post, hx-target, and hx-swap, normalized from Python snake_case (hx_get) to HTML kebab-case (hx-get). Args: element_tag (str, optional): The HTML tag name (e.g., 'button'). If None, renders attributes only. content (str, optional): The inner content of the element (if tag is provided). template_info: a dict with tags attrs exists in a the template to avoid deat referencing **hx_attrs: Arbitrary HTMX attributes (e.g., hx_post='/api/save', hx_target='#result'). Attributes: attrs (dict): The normalized dictionary of HTML attributes. Example: >>> # Fluent API >>> btn = HTMXElement(\"button\", content=\"Save\") >>> btn.hx_post(\"/save\").hx_target(\"#status\").hx_swap(\"outerHTML\") >>> print(btn.render()) <button hx-post=\"/save\" hx-target=\"#status\" hx-swap=\"outerHTML\">Save</button> >>> # Attribute Bag >>> attrs = HTMXElement().hx_get(\"/search\").hx_trigger(\"keyup\") >>> print(attrs.render()) hx-get=\"/search\" hx-trigger=\"keyup\" \"\"\" def __init__ ( self , element_tag : str = None , content : str = None , template_info : dict = None , ** hx_attrs , ): \"\"\" :param use_cdn: Use CDN link or local script path :param local_path: Path to local `htmx.min.js` if not using CDN \"\"\" self . hx_params = HxParams self . hx_bool_val = HxBoolValue self . hx_funcs = Ajax self . hx_attrs = hx_attrs self . element_tag = element_tag self . content = content or str () self . template_info = template_info or dict () self . attr_manager = ElementAttributeManipulator ( self . hx_attrs ) super () . __init__ () if template_info and template_info . get ( \"tags\" , []): if element not in template_info . get ( \"tags\" , []): raise ValueError ( \"elemet not in tag\" ) def set_attr ( self , ** attrs ) -> \"HTMXElement\" : for attribute , value in attrs . items (): try : attr_name = HxAttr [ attribute . upper ()] . value except : attr_name = attribute self . hx_attrs [ attr_name ] = value return self def get_attr ( self , attribute : str ) -> Any : attr_name = self . hx_attrs . get ( attribute , None ) return attr_name def del_attr ( self , attribute : str ) -> \"HTMXElement\" : self . hx_attrs . pop ( attribute , None ) return self def build_trigger_string ( self , event : str , modifiers : Optional [ Dict [ str , str ]] = None , filters : Optional [ List [ str ]] = None , ) -> \"HTMXElement\" : base = HxTrigger [ event ] . value if event in HxTrigger else event parts = [ base ] if modifiers : parts . extend ( f \" { k } : { v } \" for k , v in modifiers . items ()) if filters : parts . append ( f \"[ { ' and ' . join ( filters ) } ]\" ) self . hx_attrs [ HxAttr . TRIGGER . value ] = \" \" . join ( parts ) return self def build_swap_string ( self , name : str , modifiers : Optional [ Dict [ str , str ]] = None ) -> \"HTMXElement\" : base = HxSwap [ name ] . value if name in HxSwap else name parts = [ base ] if modifiers : parts . extend ( f \" { k } : { v } \" for k , v in modifiers . items ()) self . hx_attrs [ HxAttr . SWAP . value ] = \" \" . join ( parts ) return self def build_sync_string ( self , element : str , strategy : str ) -> \"HTMXElement\" : self . hx_attrs [ HxAttr . SYNC . value ] = ( f \" { element } : { HxSyncStrategy [ strategy ] . value if strategy in HxSyncStrategy else strategy } \" ) return self def render ( self , as_string = True , ) -> str | dict [ str , str ]: if self . AJAX_HX_DICT : self . hx_attrs . update ( self . AJAX_HX_DICT ) if self . element_tag : return ( Element ( content = self . content , ** self . hx_attrs ) . custom_element ( self . element_tag , ) . element ) if as_string : return f \" { r ( self . element_tag , self . hx_attrs ) } \" else : return self . hx_attrs","title":"Attribute Bag"},{"location":"reference/probo/htmx/htmx/#probo.htmx.htmx.HTMXElement.__init__","text":":param use_cdn: Use CDN link or local script path :param local_path: Path to local htmx.min.js if not using CDN Source code in src\\probo\\htmx\\htmx.py 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def __init__ ( self , element_tag : str = None , content : str = None , template_info : dict = None , ** hx_attrs , ): \"\"\" :param use_cdn: Use CDN link or local script path :param local_path: Path to local `htmx.min.js` if not using CDN \"\"\" self . hx_params = HxParams self . hx_bool_val = HxBoolValue self . hx_funcs = Ajax self . hx_attrs = hx_attrs self . element_tag = element_tag self . content = content or str () self . template_info = template_info or dict () self . attr_manager = ElementAttributeManipulator ( self . hx_attrs ) super () . __init__ () if template_info and template_info . get ( \"tags\" , []): if element not in template_info . get ( \"tags\" , []): raise ValueError ( \"elemet not in tag\" )","title":"__init__"},{"location":"reference/probo/htmx/htmx_enum/","text":"htmx_enum HxAttr Bases: Enum HTMX attributes Source code in src\\probo\\htmx\\htmx_enum.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class HxAttr ( Enum ): \"\"\"HTMX attributes\"\"\" BOOST = \"hx-boost\" GET = \"hx-get\" POST = \"hx-post\" PUT = \"hx-put\" PATCH = \"hx-patch\" DELETE = \"hx-delete\" TARGET = \"hx-target\" SWAP = \"hx-swap\" SWAP_OOB = \"hx-swap-oob\" TRIGGER = \"hx-trigger\" VALS = \"hx-vals\" PARAMS = \"hx-params\" CONFIRM = \"hx-confirm\" PUSH_URL = \"hx-push-url\" SELECT = \"hx-select\" SELECT_OOB = \"hx-select-oob\" SYNC = \"hx-sync\" VARS = \"hx-vars\" EXT = \"hx-ext\" HEADERS = \"hx-headers\" HISTORY = \"hx-history\" HISTORY_ELT = \"hx-history-elt\" INCLUDE = \"hx-include\" INDICATOR = \"hx-indicator\" PRESERVE = \"hx-preserve\" PROMPT = \"hx-prompt\" REPLACE_URL = \"hx-replace-url\" REQUEST = \"hx-request\" SSE = \"hx-sse\" VALIDATE = \"hx-validate\" WS = \"hx-ws\" @classmethod def all_attrs ( cls ) -> List [ str ]: return [ attr . value for attr in cls ]","title":"htmx_enum"},{"location":"reference/probo/htmx/htmx_enum/#htmx_enum","text":"","title":"htmx_enum"},{"location":"reference/probo/htmx/htmx_enum/#probo.htmx.htmx_enum.HxAttr","text":"Bases: Enum HTMX attributes Source code in src\\probo\\htmx\\htmx_enum.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 class HxAttr ( Enum ): \"\"\"HTMX attributes\"\"\" BOOST = \"hx-boost\" GET = \"hx-get\" POST = \"hx-post\" PUT = \"hx-put\" PATCH = \"hx-patch\" DELETE = \"hx-delete\" TARGET = \"hx-target\" SWAP = \"hx-swap\" SWAP_OOB = \"hx-swap-oob\" TRIGGER = \"hx-trigger\" VALS = \"hx-vals\" PARAMS = \"hx-params\" CONFIRM = \"hx-confirm\" PUSH_URL = \"hx-push-url\" SELECT = \"hx-select\" SELECT_OOB = \"hx-select-oob\" SYNC = \"hx-sync\" VARS = \"hx-vars\" EXT = \"hx-ext\" HEADERS = \"hx-headers\" HISTORY = \"hx-history\" HISTORY_ELT = \"hx-history-elt\" INCLUDE = \"hx-include\" INDICATOR = \"hx-indicator\" PRESERVE = \"hx-preserve\" PROMPT = \"hx-prompt\" REPLACE_URL = \"hx-replace-url\" REQUEST = \"hx-request\" SSE = \"hx-sse\" VALIDATE = \"hx-validate\" WS = \"hx-ws\" @classmethod def all_attrs ( cls ) -> List [ str ]: return [ attr . value for attr in cls ]","title":"HxAttr"},{"location":"reference/probo/request/props/","text":"props","title":"props"},{"location":"reference/probo/request/props/#props","text":"","title":"props"},{"location":"reference/probo/request/request_context/","text":"request_context ComponentRequestContext This class handles injecting global/context properties into Component objects that are not directly tied to a request lifecycle (e.g., static components needing context). Source code in src\\probo\\request\\request_context.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ComponentRequestContext : \"\"\" This class handles injecting global/context properties into Component objects that are not directly tied to a request lifecycle (e.g., static components needing context). \"\"\" def __init__ ( self , * components_objs , ** context_props ): self . context_props = context_props self . components = list ( components_objs ) self . processed_components = [] def process_components ( self , * extra_component_objs , ** extra_props ) -> List [ Any ]: \"\"\" Applies the stored context_props (plus any extra_props) to all components. \"\"\" # 1. Prepare Context (Merge defaults with extras) current_context = self . context_props . copy () if extra_props : current_context . update ( extra_props ) # 2. Prepare Targets (Merge defaults with extras) targets = self . components . copy () if extra_component_objs : targets . extend ( extra_component_objs ) # 3. Apply Context to Components self . processed_components = [] for obj in targets : # We assume obj has a 'props' dictionary if hasattr ( obj , \"props\" ) and isinstance ( obj . props , dict ): obj . props . clear () obj . props . update ( current_context ) self . processed_components . append ( obj ) return self . processed_components process_components ( * extra_component_objs , ** extra_props ) Applies the stored context_props (plus any extra_props) to all components. Source code in src\\probo\\request\\request_context.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def process_components ( self , * extra_component_objs , ** extra_props ) -> List [ Any ]: \"\"\" Applies the stored context_props (plus any extra_props) to all components. \"\"\" # 1. Prepare Context (Merge defaults with extras) current_context = self . context_props . copy () if extra_props : current_context . update ( extra_props ) # 2. Prepare Targets (Merge defaults with extras) targets = self . components . copy () if extra_component_objs : targets . extend ( extra_component_objs ) # 3. Apply Context to Components self . processed_components = [] for obj in targets : # We assume obj has a 'props' dictionary if hasattr ( obj , \"props\" ) and isinstance ( obj . props , dict ): obj . props . clear () obj . props . update ( current_context ) self . processed_components . append ( obj ) return self . processed_components","title":"request_context"},{"location":"reference/probo/request/request_context/#request_context","text":"","title":"request_context"},{"location":"reference/probo/request/request_context/#probo.request.request_context.ComponentRequestContext","text":"This class handles injecting global/context properties into Component objects that are not directly tied to a request lifecycle (e.g., static components needing context). Source code in src\\probo\\request\\request_context.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 class ComponentRequestContext : \"\"\" This class handles injecting global/context properties into Component objects that are not directly tied to a request lifecycle (e.g., static components needing context). \"\"\" def __init__ ( self , * components_objs , ** context_props ): self . context_props = context_props self . components = list ( components_objs ) self . processed_components = [] def process_components ( self , * extra_component_objs , ** extra_props ) -> List [ Any ]: \"\"\" Applies the stored context_props (plus any extra_props) to all components. \"\"\" # 1. Prepare Context (Merge defaults with extras) current_context = self . context_props . copy () if extra_props : current_context . update ( extra_props ) # 2. Prepare Targets (Merge defaults with extras) targets = self . components . copy () if extra_component_objs : targets . extend ( extra_component_objs ) # 3. Apply Context to Components self . processed_components = [] for obj in targets : # We assume obj has a 'props' dictionary if hasattr ( obj , \"props\" ) and isinstance ( obj . props , dict ): obj . props . clear () obj . props . update ( current_context ) self . processed_components . append ( obj ) return self . processed_components","title":"ComponentRequestContext"},{"location":"reference/probo/request/request_context/#probo.request.request_context.ComponentRequestContext.process_components","text":"Applies the stored context_props (plus any extra_props) to all components. Source code in src\\probo\\request\\request_context.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def process_components ( self , * extra_component_objs , ** extra_props ) -> List [ Any ]: \"\"\" Applies the stored context_props (plus any extra_props) to all components. \"\"\" # 1. Prepare Context (Merge defaults with extras) current_context = self . context_props . copy () if extra_props : current_context . update ( extra_props ) # 2. Prepare Targets (Merge defaults with extras) targets = self . components . copy () if extra_component_objs : targets . extend ( extra_component_objs ) # 3. Apply Context to Components self . processed_components = [] for obj in targets : # We assume obj has a 'props' dictionary if hasattr ( obj , \"props\" ) and isinstance ( obj . props , dict ): obj . props . clear () obj . props . update ( current_context ) self . processed_components . append ( obj ) return self . processed_components","title":"process_components"},{"location":"reference/probo/request/transformer/","text":"transformer FormHandler this class utility the RequestDataTransformer to save the forms in a view setting Source code in src\\probo\\request\\transformer.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class FormHandler : \"\"\" this class utility the RequestDataTransformer to save the forms in a view setting \"\"\" def __init__ ( self , request_data : RequestDataTransformer ): \"\"\" Initializes FormHandler with request data and operation type. \"\"\" self . request_data = request_data self . logger_instance = None self . logger_instance_message = None super () . __init__ () def form_handling ( self , ): if self . request_data . mono_form : operation_status = self . mono_form_true_option () else : operation_status = self . mono_form_false_option () return operation_status def mono_form_true_option ( self , ): if self . request_data . is_valid (): self . request_data . save_form () return True else : return False def mono_form_false_option ( self , ): if self . request_data . are_valid (): self . request_data . save_forms () return True else : return False __init__ ( request_data ) Initializes FormHandler with request data and operation type. Source code in src\\probo\\request\\transformer.py 343 344 345 346 347 348 349 350 def __init__ ( self , request_data : RequestDataTransformer ): \"\"\" Initializes FormHandler with request data and operation type. \"\"\" self . request_data = request_data self . logger_instance = None self . logger_instance_message = None super () . __init__ () RequestDataTransformer RequestDataTransformer or RDT is a class that parses and extracts contents from django request object ,also supports form hundling args: request : the django request object form_class: the form class definition request_files: indicates support for files and media, can be list or single class mono_form: indicates if only one form or multiple example: >>> # single form >>> from .forms import ExampleModelForm >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,ExampleModelForm) >>> if rdt.request_method == 'POST': >>> if rdt.is_valid(): >>> rdt.save_form() >>> >>> >>> >>> # multiform >>> from .forms import (ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,) >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,[ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,],mono_form=False) >>> if rdt.request_method == 'POST': >>> if rdt.are_valid(): >>> rdt.save_forms() Source code in src\\probo\\request\\transformer.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 class RequestDataTransformer : \"\"\"RequestDataTransformer or RDT is a class that parses and extracts contents from django request object ,also supports form hundling args: request : the django request object form_class: the form class definition request_files: indicates support for files and media, can be list or single class mono_form: indicates if only one form or multiple example: >>> # single form >>> from .forms import ExampleModelForm >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,ExampleModelForm) >>> if rdt.request_method == 'POST': >>> if rdt.is_valid(): >>> rdt.save_form() >>> >>> >>> >>> # multiform >>> from .forms import (ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,) >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,[ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,],mono_form=False) >>> if rdt.request_method == 'POST': >>> if rdt.are_valid(): >>> rdt.save_forms() \"\"\" def __init__ ( self , request = None , form_class = None , request_files = False , mono_form = True ): self . target_data = {} self . request = request self . form_class = form_class self . errors = {} self . cleaned_data = {} self . request_method = request . method if hasattr ( request , \"method\" ) else str () self . request_user = request . user if hasattr ( request , \"user\" ) else dict () self . mono_form = mono_form if mono_form : self . form = ( form_class ( request . POST , request . FILES ) if form_class and request_files else ( form_class ( request . POST ) if form_class else None ) ) else : self . form = self . _initialize_multi_form_processing () self . user_data = ( self . _prepare_user_data () if hasattr ( request , \"user\" ) else dict () ) self . request_files = ( self . _process_post_files () if hasattr ( request , \"FILES\" ) else dict () ) self . post_data = ( self . _process_post_data () if hasattr ( request , \"POST\" ) else dict () ) self . get_data = self . _process_get_data () if hasattr ( request , \"GET\" ) else dict () self . session_data = ( self . _get_all_session_data () if hasattr ( request , \"session\" ) else dict () ) self . id = self . session_data . get ( \"session_key\" , None ) self . validations = {} # Initialize the form if a form_class is provided # Process target data fields as a dictionary of lists def _process_get_data ( self ): get_data_dict = {} for field , field_data in self . request . GET . items (): if isinstance ( field_data , list ): if len ( field_data ) == 1 : get_data_dict [ field ] = field_data [ 0 ] # Single value, store as string else : get_data_dict [ field ] = field_data # Multiple values, store as list else : get_data_dict [ field ] = field_data # Single value, store as string return get_data_dict def _process_post_data ( self ): post_data_dict = {} for field , field_data in self . request . POST . items (): if isinstance ( field_data , list ): if len ( field_data ) == 1 : post_data_dict [ field ] = field_data [ 0 ] # Single value, store as string else : post_data_dict [ field ] = field_data # Multiple values, store as list else : post_data_dict [ field ] = field_data # Single value, store as string return post_data_dict def _process_post_files ( self ): post_data_dict = {} for field , field_data in self . request . FILES . items (): if isinstance ( field_data , list ): if len ( field_data ) == 1 : post_data_dict [ field ] = field_data [ 0 ] # Single value, store as string else : post_data_dict [ field ] = field_data # Multiple values, store as list else : post_data_dict [ field ] = field_data # Single value, store as string return post_data_dict def save_form ( self , ** kwargs ): if self . is_valid (): self . form . save ( ** kwargs ) return self . form return not self . errors def is_valid ( self ): \"\"\"Validates the request form and ensures all target data fields are provided.\"\"\" # Validate the form if it was provided if self . form and not self . form . is_valid (): self . errors . update ( ** { self . form_class . __name__ : self . form . errors . values ()}) # Check if each target data field has at least one value \"\"\"for field, values in self.post_data.items(): if not values: self.errors.update(f'{field}':f\"Please select at least one option for '{field}'.\") \"\"\" # Populate cleaned_data with form data if the form is valid if self . form and self . form . is_valid (): self . cleaned_data . update ( self . form . cleaned_data ) return not self . errors # Returns True if there are no errors def get_errors ( self ): \"\"\"Returns a list of validation errors.\"\"\" return self . errors def get_request_data ( self , organized = False ): \"\"\" Returns cleaned form data and target fields. Parameters: - organized: If True, returns a dictionary with cleaned and target data organized in separate keys. Returns: Dictionary of cleaned data and target fields. \"\"\" return ( { \"cleaned_data\" : self . cleaned_data , \"post_data\" : self . post_data , \"self.get_data\" : self . get_data , } if organized else { ** self . cleaned_data , ** self . post_data , ** self . get_data , ** self . request_files , } ) def _prepare_user_data ( self ): return self . request_user . __dict__ if self . request else None def _get_all_session_data ( self ): \"\"\"Retrieve all session data as a dictionary.\"\"\" return dict ( self . request . session ) # Convert session to a dictionary def set_session_data ( self , key , value ): \"\"\"Sets a session variable.\"\"\" self . request . session [ key ] = value self . request . session . modified = True # Mark session as modified self . session_data = self . _get_all_session_data () # Update session_data def get_session_data ( self , key , default = None ): \"\"\"Retrieves a session variable, returning a default if not found.\"\"\" return self . request . session . get ( key , default ) def update_session_data ( self , key , update_func ): \"\"\"Updates a session variable using a provided function.\"\"\" if key in self . request . session : self . request . session [ key ] = update_func ( self . request . session [ key ]) self . request . session . modified = True self . session_data = self . _get_all_session_data () # Update session_data def delete_session_data ( self , key ): \"\"\"Deletes a session variable if it exists.\"\"\" if key in self . request . session : del self . request . session [ key ] self . request . session . modified = True self . session_data = self . _get_all_session_data () def extract_target_data ( self , fields = None , multi_value_fields = None , is_json = False ): \"\"\" Extracts data from the request. Supports both form data (default) and JSON payloads. :param fields: List of fields to retrieve. If None, retrieves all fields in the request. :param multi_value_fields: List of fields that may contain multiple values (e.g., checkboxes). :param is_json: If True, treats the request as containing JSON data. :return: Dictionary with extracted data. \"\"\" if is_json : self . target_data = ( self . request . json () if hasattr ( self . request , \"json\" ) else {} ) else : fields = fields or self . request . POST . keys () multi_value_fields = multi_value_fields or [] for field in fields : if field in multi_value_fields : # Get a list for fields that may contain multiple values values = self . request . POST . getlist ( field ) self . target_data [ field ] = values if len ( values ) > 1 else values [ 0 ] else : self . target_data [ field ] = self . request . POST . get ( field ) return self . target_data def clear_all_session_data ( self , ): \"\"\" Clears specific session data by key, or clears all session data if no key is provided. \"\"\" self . session_data . clear () return True def get_field_value ( self , field , default = None , ): \"\"\" Retrieves the value of a specific field from the request data. :param field: Field name to retrieve :param default: Default value if the field does not exist \"\"\" return self . post_data . get ( field ) if field in self . post_data else default def get_json_field_value ( self , field , default = None ): \"\"\" Retrieves a field's value from JSON data in the request. \"\"\" if not hasattr ( self . request , \"json\" ): raise ValueError ( \"Request does not contain JSON data.\" ) json_data = self . request . json () return json_data . get ( field , default ) def has_field ( self , field ): \"\"\" Checks if a field exists in the request data. \"\"\" return field in self . post_data or ( hasattr ( self . request , \"json\" ) and field in self . request . json () ) def _initialize_multi_form_processing ( self ): \"\"\" Initializes data structures and validation status for each form class specified. \"\"\" form_instances = {} for form_class in self . form_class : prefix = form_class . __name__ . lower () form_instance = form_class ( self . request . POST , prefix = prefix ) form_instances [ prefix ] = form_instance if form_instance . is_valid (): self . cleaned_data [ prefix ] = form_instance . cleaned_data self . errors [ prefix ] = None self . validations [ prefix ] = True else : self . errors [ prefix ] = form_instance . errors . values () self . validations [ prefix ] = False self . cleaned_data [ prefix ] = None return form_instances def are_valid ( self ): \"\"\" Checks if all forms are valid and updates error tracking. \"\"\" all_valid = True for prefix , instance in self . validations . items (): if not instance : all_valid = False return all_valid def save_forms ( self , ): if self . are_valid (): for form in self . form : form . save ( commit = False ) return self . are_valid () def get_csrf_token ( self ): try : from django.middleware.csrf import get_token return get_token ( self . request ) except : return \"\" def extract_props ( self ): \"\"\" Separates data into Global Context (User/Session) and Local Context (Form/Data) for the TCM. \"\"\" # 1. GLOBAL DATA (Context for all components) # This data is needed by Layouts, Navbars, User Menus, etc. global_ctx = { \"user\" : self . request_user , \"is_authenticated\" : self . request . user . is_authenticated if self . request else False , \"session\" : self . session_data , \"csrf_token\" : self . get_csrf_token (), # Crucial for FormElement \"path\" : self . request . path , \"request_method\" : self . request_method , } # 2. LOCAL DATA (Specific to the component/form being rendered) # This data is needed by the specific FormElement or Content Component local_ctx = { \"form\" : self . form , # The specific form instance \"errors\" : self . errors , # Validation errors \"cleaned_data\" : self . cleaned_data , \"raw_post_data\" : self . post_data , \"raw_get_data\" : self . get_data , \"is_valid\" : self . is_valid () if self . mono_form else self . are_valid (), } # Return the structured object return RequestProps ( global_context = global_ctx , local_context = local_ctx ) are_valid () Checks if all forms are valid and updates error tracking. Source code in src\\probo\\request\\transformer.py 278 279 280 281 282 283 284 285 286 def are_valid ( self ): \"\"\" Checks if all forms are valid and updates error tracking. \"\"\" all_valid = True for prefix , instance in self . validations . items (): if not instance : all_valid = False return all_valid clear_all_session_data () Clears specific session data by key, or clears all session data if no key is provided. Source code in src\\probo\\request\\transformer.py 221 222 223 224 225 226 227 228 def clear_all_session_data ( self , ): \"\"\" Clears specific session data by key, or clears all session data if no key is provided. \"\"\" self . session_data . clear () return True delete_session_data ( key ) Deletes a session variable if it exists. Source code in src\\probo\\request\\transformer.py 188 189 190 191 192 193 def delete_session_data ( self , key ): \"\"\"Deletes a session variable if it exists.\"\"\" if key in self . request . session : del self . request . session [ key ] self . request . session . modified = True self . session_data = self . _get_all_session_data () extract_props () Separates data into Global Context (User/Session) and Local Context (Form/Data) for the TCM. Source code in src\\probo\\request\\transformer.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def extract_props ( self ): \"\"\" Separates data into Global Context (User/Session) and Local Context (Form/Data) for the TCM. \"\"\" # 1. GLOBAL DATA (Context for all components) # This data is needed by Layouts, Navbars, User Menus, etc. global_ctx = { \"user\" : self . request_user , \"is_authenticated\" : self . request . user . is_authenticated if self . request else False , \"session\" : self . session_data , \"csrf_token\" : self . get_csrf_token (), # Crucial for FormElement \"path\" : self . request . path , \"request_method\" : self . request_method , } # 2. LOCAL DATA (Specific to the component/form being rendered) # This data is needed by the specific FormElement or Content Component local_ctx = { \"form\" : self . form , # The specific form instance \"errors\" : self . errors , # Validation errors \"cleaned_data\" : self . cleaned_data , \"raw_post_data\" : self . post_data , \"raw_get_data\" : self . get_data , \"is_valid\" : self . is_valid () if self . mono_form else self . are_valid (), } # Return the structured object return RequestProps ( global_context = global_ctx , local_context = local_ctx ) extract_target_data ( fields = None , multi_value_fields = None , is_json = False ) Extracts data from the request. Supports both form data (default) and JSON payloads. :param fields: List of fields to retrieve. If None, retrieves all fields in the request. :param multi_value_fields: List of fields that may contain multiple values (e.g., checkboxes). :param is_json: If True, treats the request as containing JSON data. :return: Dictionary with extracted data. Source code in src\\probo\\request\\transformer.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def extract_target_data ( self , fields = None , multi_value_fields = None , is_json = False ): \"\"\" Extracts data from the request. Supports both form data (default) and JSON payloads. :param fields: List of fields to retrieve. If None, retrieves all fields in the request. :param multi_value_fields: List of fields that may contain multiple values (e.g., checkboxes). :param is_json: If True, treats the request as containing JSON data. :return: Dictionary with extracted data. \"\"\" if is_json : self . target_data = ( self . request . json () if hasattr ( self . request , \"json\" ) else {} ) else : fields = fields or self . request . POST . keys () multi_value_fields = multi_value_fields or [] for field in fields : if field in multi_value_fields : # Get a list for fields that may contain multiple values values = self . request . POST . getlist ( field ) self . target_data [ field ] = values if len ( values ) > 1 else values [ 0 ] else : self . target_data [ field ] = self . request . POST . get ( field ) return self . target_data get_errors () Returns a list of validation errors. Source code in src\\probo\\request\\transformer.py 136 137 138 def get_errors ( self ): \"\"\"Returns a list of validation errors.\"\"\" return self . errors get_field_value ( field , default = None ) Retrieves the value of a specific field from the request data. :param field: Field name to retrieve :param default: Default value if the field does not exist Source code in src\\probo\\request\\transformer.py 230 231 232 233 234 235 236 237 238 239 240 def get_field_value ( self , field , default = None , ): \"\"\" Retrieves the value of a specific field from the request data. :param field: Field name to retrieve :param default: Default value if the field does not exist \"\"\" return self . post_data . get ( field ) if field in self . post_data else default get_json_field_value ( field , default = None ) Retrieves a field's value from JSON data in the request. Source code in src\\probo\\request\\transformer.py 242 243 244 245 246 247 248 249 def get_json_field_value ( self , field , default = None ): \"\"\" Retrieves a field's value from JSON data in the request. \"\"\" if not hasattr ( self . request , \"json\" ): raise ValueError ( \"Request does not contain JSON data.\" ) json_data = self . request . json () return json_data . get ( field , default ) get_request_data ( organized = False ) Returns cleaned form data and target fields. Parameters: - organized: If True, returns a dictionary with cleaned and target data organized in separate keys. Returns: Dictionary of cleaned data and target fields. Source code in src\\probo\\request\\transformer.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_request_data ( self , organized = False ): \"\"\" Returns cleaned form data and target fields. Parameters: - organized: If True, returns a dictionary with cleaned and target data organized in separate keys. Returns: Dictionary of cleaned data and target fields. \"\"\" return ( { \"cleaned_data\" : self . cleaned_data , \"post_data\" : self . post_data , \"self.get_data\" : self . get_data , } if organized else { ** self . cleaned_data , ** self . post_data , ** self . get_data , ** self . request_files , } ) get_session_data ( key , default = None ) Retrieves a session variable, returning a default if not found. Source code in src\\probo\\request\\transformer.py 177 178 179 def get_session_data ( self , key , default = None ): \"\"\"Retrieves a session variable, returning a default if not found.\"\"\" return self . request . session . get ( key , default ) has_field ( field ) Checks if a field exists in the request data. Source code in src\\probo\\request\\transformer.py 251 252 253 254 255 256 257 def has_field ( self , field ): \"\"\" Checks if a field exists in the request data. \"\"\" return field in self . post_data or ( hasattr ( self . request , \"json\" ) and field in self . request . json () ) is_valid () Validates the request form and ensures all target data fields are provided. Source code in src\\probo\\request\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def is_valid ( self ): \"\"\"Validates the request form and ensures all target data fields are provided.\"\"\" # Validate the form if it was provided if self . form and not self . form . is_valid (): self . errors . update ( ** { self . form_class . __name__ : self . form . errors . values ()}) # Check if each target data field has at least one value \"\"\"for field, values in self.post_data.items(): if not values: self.errors.update(f'{field}':f\"Please select at least one option for '{field}'.\") \"\"\" # Populate cleaned_data with form data if the form is valid if self . form and self . form . is_valid (): self . cleaned_data . update ( self . form . cleaned_data ) return not self . errors # Returns True if there are no errors set_session_data ( key , value ) Sets a session variable. Source code in src\\probo\\request\\transformer.py 171 172 173 174 175 def set_session_data ( self , key , value ): \"\"\"Sets a session variable.\"\"\" self . request . session [ key ] = value self . request . session . modified = True # Mark session as modified self . session_data = self . _get_all_session_data () # Update session_data update_session_data ( key , update_func ) Updates a session variable using a provided function. Source code in src\\probo\\request\\transformer.py 181 182 183 184 185 186 def update_session_data ( self , key , update_func ): \"\"\"Updates a session variable using a provided function.\"\"\" if key in self . request . session : self . request . session [ key ] = update_func ( self . request . session [ key ]) self . request . session . modified = True self . session_data = self . _get_all_session_data () # Update session_data","title":"transformer"},{"location":"reference/probo/request/transformer/#transformer","text":"","title":"transformer"},{"location":"reference/probo/request/transformer/#probo.request.transformer.FormHandler","text":"this class utility the RequestDataTransformer to save the forms in a view setting Source code in src\\probo\\request\\transformer.py 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 class FormHandler : \"\"\" this class utility the RequestDataTransformer to save the forms in a view setting \"\"\" def __init__ ( self , request_data : RequestDataTransformer ): \"\"\" Initializes FormHandler with request data and operation type. \"\"\" self . request_data = request_data self . logger_instance = None self . logger_instance_message = None super () . __init__ () def form_handling ( self , ): if self . request_data . mono_form : operation_status = self . mono_form_true_option () else : operation_status = self . mono_form_false_option () return operation_status def mono_form_true_option ( self , ): if self . request_data . is_valid (): self . request_data . save_form () return True else : return False def mono_form_false_option ( self , ): if self . request_data . are_valid (): self . request_data . save_forms () return True else : return False","title":"FormHandler"},{"location":"reference/probo/request/transformer/#probo.request.transformer.FormHandler.__init__","text":"Initializes FormHandler with request data and operation type. Source code in src\\probo\\request\\transformer.py 343 344 345 346 347 348 349 350 def __init__ ( self , request_data : RequestDataTransformer ): \"\"\" Initializes FormHandler with request data and operation type. \"\"\" self . request_data = request_data self . logger_instance = None self . logger_instance_message = None super () . __init__ ()","title":"__init__"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer","text":"RequestDataTransformer or RDT is a class that parses and extracts contents from django request object ,also supports form hundling args: request : the django request object form_class: the form class definition request_files: indicates support for files and media, can be list or single class mono_form: indicates if only one form or multiple example: >>> # single form >>> from .forms import ExampleModelForm >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,ExampleModelForm) >>> if rdt.request_method == 'POST': >>> if rdt.is_valid(): >>> rdt.save_form() >>> >>> >>> >>> # multiform >>> from .forms import (ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,) >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,[ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,],mono_form=False) >>> if rdt.request_method == 'POST': >>> if rdt.are_valid(): >>> rdt.save_forms() Source code in src\\probo\\request\\transformer.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 class RequestDataTransformer : \"\"\"RequestDataTransformer or RDT is a class that parses and extracts contents from django request object ,also supports form hundling args: request : the django request object form_class: the form class definition request_files: indicates support for files and media, can be list or single class mono_form: indicates if only one form or multiple example: >>> # single form >>> from .forms import ExampleModelForm >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,ExampleModelForm) >>> if rdt.request_method == 'POST': >>> if rdt.is_valid(): >>> rdt.save_form() >>> >>> >>> >>> # multiform >>> from .forms import (ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,) >>> def example_view(request,) >>> rdt = RequestDataTransformer(request,[ExampleModelForm1,ExampleModelForm2,ExampleModelForm3,ExampleModelForm4,ExampleModelForm5,],mono_form=False) >>> if rdt.request_method == 'POST': >>> if rdt.are_valid(): >>> rdt.save_forms() \"\"\" def __init__ ( self , request = None , form_class = None , request_files = False , mono_form = True ): self . target_data = {} self . request = request self . form_class = form_class self . errors = {} self . cleaned_data = {} self . request_method = request . method if hasattr ( request , \"method\" ) else str () self . request_user = request . user if hasattr ( request , \"user\" ) else dict () self . mono_form = mono_form if mono_form : self . form = ( form_class ( request . POST , request . FILES ) if form_class and request_files else ( form_class ( request . POST ) if form_class else None ) ) else : self . form = self . _initialize_multi_form_processing () self . user_data = ( self . _prepare_user_data () if hasattr ( request , \"user\" ) else dict () ) self . request_files = ( self . _process_post_files () if hasattr ( request , \"FILES\" ) else dict () ) self . post_data = ( self . _process_post_data () if hasattr ( request , \"POST\" ) else dict () ) self . get_data = self . _process_get_data () if hasattr ( request , \"GET\" ) else dict () self . session_data = ( self . _get_all_session_data () if hasattr ( request , \"session\" ) else dict () ) self . id = self . session_data . get ( \"session_key\" , None ) self . validations = {} # Initialize the form if a form_class is provided # Process target data fields as a dictionary of lists def _process_get_data ( self ): get_data_dict = {} for field , field_data in self . request . GET . items (): if isinstance ( field_data , list ): if len ( field_data ) == 1 : get_data_dict [ field ] = field_data [ 0 ] # Single value, store as string else : get_data_dict [ field ] = field_data # Multiple values, store as list else : get_data_dict [ field ] = field_data # Single value, store as string return get_data_dict def _process_post_data ( self ): post_data_dict = {} for field , field_data in self . request . POST . items (): if isinstance ( field_data , list ): if len ( field_data ) == 1 : post_data_dict [ field ] = field_data [ 0 ] # Single value, store as string else : post_data_dict [ field ] = field_data # Multiple values, store as list else : post_data_dict [ field ] = field_data # Single value, store as string return post_data_dict def _process_post_files ( self ): post_data_dict = {} for field , field_data in self . request . FILES . items (): if isinstance ( field_data , list ): if len ( field_data ) == 1 : post_data_dict [ field ] = field_data [ 0 ] # Single value, store as string else : post_data_dict [ field ] = field_data # Multiple values, store as list else : post_data_dict [ field ] = field_data # Single value, store as string return post_data_dict def save_form ( self , ** kwargs ): if self . is_valid (): self . form . save ( ** kwargs ) return self . form return not self . errors def is_valid ( self ): \"\"\"Validates the request form and ensures all target data fields are provided.\"\"\" # Validate the form if it was provided if self . form and not self . form . is_valid (): self . errors . update ( ** { self . form_class . __name__ : self . form . errors . values ()}) # Check if each target data field has at least one value \"\"\"for field, values in self.post_data.items(): if not values: self.errors.update(f'{field}':f\"Please select at least one option for '{field}'.\") \"\"\" # Populate cleaned_data with form data if the form is valid if self . form and self . form . is_valid (): self . cleaned_data . update ( self . form . cleaned_data ) return not self . errors # Returns True if there are no errors def get_errors ( self ): \"\"\"Returns a list of validation errors.\"\"\" return self . errors def get_request_data ( self , organized = False ): \"\"\" Returns cleaned form data and target fields. Parameters: - organized: If True, returns a dictionary with cleaned and target data organized in separate keys. Returns: Dictionary of cleaned data and target fields. \"\"\" return ( { \"cleaned_data\" : self . cleaned_data , \"post_data\" : self . post_data , \"self.get_data\" : self . get_data , } if organized else { ** self . cleaned_data , ** self . post_data , ** self . get_data , ** self . request_files , } ) def _prepare_user_data ( self ): return self . request_user . __dict__ if self . request else None def _get_all_session_data ( self ): \"\"\"Retrieve all session data as a dictionary.\"\"\" return dict ( self . request . session ) # Convert session to a dictionary def set_session_data ( self , key , value ): \"\"\"Sets a session variable.\"\"\" self . request . session [ key ] = value self . request . session . modified = True # Mark session as modified self . session_data = self . _get_all_session_data () # Update session_data def get_session_data ( self , key , default = None ): \"\"\"Retrieves a session variable, returning a default if not found.\"\"\" return self . request . session . get ( key , default ) def update_session_data ( self , key , update_func ): \"\"\"Updates a session variable using a provided function.\"\"\" if key in self . request . session : self . request . session [ key ] = update_func ( self . request . session [ key ]) self . request . session . modified = True self . session_data = self . _get_all_session_data () # Update session_data def delete_session_data ( self , key ): \"\"\"Deletes a session variable if it exists.\"\"\" if key in self . request . session : del self . request . session [ key ] self . request . session . modified = True self . session_data = self . _get_all_session_data () def extract_target_data ( self , fields = None , multi_value_fields = None , is_json = False ): \"\"\" Extracts data from the request. Supports both form data (default) and JSON payloads. :param fields: List of fields to retrieve. If None, retrieves all fields in the request. :param multi_value_fields: List of fields that may contain multiple values (e.g., checkboxes). :param is_json: If True, treats the request as containing JSON data. :return: Dictionary with extracted data. \"\"\" if is_json : self . target_data = ( self . request . json () if hasattr ( self . request , \"json\" ) else {} ) else : fields = fields or self . request . POST . keys () multi_value_fields = multi_value_fields or [] for field in fields : if field in multi_value_fields : # Get a list for fields that may contain multiple values values = self . request . POST . getlist ( field ) self . target_data [ field ] = values if len ( values ) > 1 else values [ 0 ] else : self . target_data [ field ] = self . request . POST . get ( field ) return self . target_data def clear_all_session_data ( self , ): \"\"\" Clears specific session data by key, or clears all session data if no key is provided. \"\"\" self . session_data . clear () return True def get_field_value ( self , field , default = None , ): \"\"\" Retrieves the value of a specific field from the request data. :param field: Field name to retrieve :param default: Default value if the field does not exist \"\"\" return self . post_data . get ( field ) if field in self . post_data else default def get_json_field_value ( self , field , default = None ): \"\"\" Retrieves a field's value from JSON data in the request. \"\"\" if not hasattr ( self . request , \"json\" ): raise ValueError ( \"Request does not contain JSON data.\" ) json_data = self . request . json () return json_data . get ( field , default ) def has_field ( self , field ): \"\"\" Checks if a field exists in the request data. \"\"\" return field in self . post_data or ( hasattr ( self . request , \"json\" ) and field in self . request . json () ) def _initialize_multi_form_processing ( self ): \"\"\" Initializes data structures and validation status for each form class specified. \"\"\" form_instances = {} for form_class in self . form_class : prefix = form_class . __name__ . lower () form_instance = form_class ( self . request . POST , prefix = prefix ) form_instances [ prefix ] = form_instance if form_instance . is_valid (): self . cleaned_data [ prefix ] = form_instance . cleaned_data self . errors [ prefix ] = None self . validations [ prefix ] = True else : self . errors [ prefix ] = form_instance . errors . values () self . validations [ prefix ] = False self . cleaned_data [ prefix ] = None return form_instances def are_valid ( self ): \"\"\" Checks if all forms are valid and updates error tracking. \"\"\" all_valid = True for prefix , instance in self . validations . items (): if not instance : all_valid = False return all_valid def save_forms ( self , ): if self . are_valid (): for form in self . form : form . save ( commit = False ) return self . are_valid () def get_csrf_token ( self ): try : from django.middleware.csrf import get_token return get_token ( self . request ) except : return \"\" def extract_props ( self ): \"\"\" Separates data into Global Context (User/Session) and Local Context (Form/Data) for the TCM. \"\"\" # 1. GLOBAL DATA (Context for all components) # This data is needed by Layouts, Navbars, User Menus, etc. global_ctx = { \"user\" : self . request_user , \"is_authenticated\" : self . request . user . is_authenticated if self . request else False , \"session\" : self . session_data , \"csrf_token\" : self . get_csrf_token (), # Crucial for FormElement \"path\" : self . request . path , \"request_method\" : self . request_method , } # 2. LOCAL DATA (Specific to the component/form being rendered) # This data is needed by the specific FormElement or Content Component local_ctx = { \"form\" : self . form , # The specific form instance \"errors\" : self . errors , # Validation errors \"cleaned_data\" : self . cleaned_data , \"raw_post_data\" : self . post_data , \"raw_get_data\" : self . get_data , \"is_valid\" : self . is_valid () if self . mono_form else self . are_valid (), } # Return the structured object return RequestProps ( global_context = global_ctx , local_context = local_ctx )","title":"RequestDataTransformer"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.are_valid","text":"Checks if all forms are valid and updates error tracking. Source code in src\\probo\\request\\transformer.py 278 279 280 281 282 283 284 285 286 def are_valid ( self ): \"\"\" Checks if all forms are valid and updates error tracking. \"\"\" all_valid = True for prefix , instance in self . validations . items (): if not instance : all_valid = False return all_valid","title":"are_valid"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.clear_all_session_data","text":"Clears specific session data by key, or clears all session data if no key is provided. Source code in src\\probo\\request\\transformer.py 221 222 223 224 225 226 227 228 def clear_all_session_data ( self , ): \"\"\" Clears specific session data by key, or clears all session data if no key is provided. \"\"\" self . session_data . clear () return True","title":"clear_all_session_data"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.delete_session_data","text":"Deletes a session variable if it exists. Source code in src\\probo\\request\\transformer.py 188 189 190 191 192 193 def delete_session_data ( self , key ): \"\"\"Deletes a session variable if it exists.\"\"\" if key in self . request . session : del self . request . session [ key ] self . request . session . modified = True self . session_data = self . _get_all_session_data ()","title":"delete_session_data"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.extract_props","text":"Separates data into Global Context (User/Session) and Local Context (Form/Data) for the TCM. Source code in src\\probo\\request\\transformer.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 def extract_props ( self ): \"\"\" Separates data into Global Context (User/Session) and Local Context (Form/Data) for the TCM. \"\"\" # 1. GLOBAL DATA (Context for all components) # This data is needed by Layouts, Navbars, User Menus, etc. global_ctx = { \"user\" : self . request_user , \"is_authenticated\" : self . request . user . is_authenticated if self . request else False , \"session\" : self . session_data , \"csrf_token\" : self . get_csrf_token (), # Crucial for FormElement \"path\" : self . request . path , \"request_method\" : self . request_method , } # 2. LOCAL DATA (Specific to the component/form being rendered) # This data is needed by the specific FormElement or Content Component local_ctx = { \"form\" : self . form , # The specific form instance \"errors\" : self . errors , # Validation errors \"cleaned_data\" : self . cleaned_data , \"raw_post_data\" : self . post_data , \"raw_get_data\" : self . get_data , \"is_valid\" : self . is_valid () if self . mono_form else self . are_valid (), } # Return the structured object return RequestProps ( global_context = global_ctx , local_context = local_ctx )","title":"extract_props"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.extract_target_data","text":"Extracts data from the request. Supports both form data (default) and JSON payloads. :param fields: List of fields to retrieve. If None, retrieves all fields in the request. :param multi_value_fields: List of fields that may contain multiple values (e.g., checkboxes). :param is_json: If True, treats the request as containing JSON data. :return: Dictionary with extracted data. Source code in src\\probo\\request\\transformer.py 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 def extract_target_data ( self , fields = None , multi_value_fields = None , is_json = False ): \"\"\" Extracts data from the request. Supports both form data (default) and JSON payloads. :param fields: List of fields to retrieve. If None, retrieves all fields in the request. :param multi_value_fields: List of fields that may contain multiple values (e.g., checkboxes). :param is_json: If True, treats the request as containing JSON data. :return: Dictionary with extracted data. \"\"\" if is_json : self . target_data = ( self . request . json () if hasattr ( self . request , \"json\" ) else {} ) else : fields = fields or self . request . POST . keys () multi_value_fields = multi_value_fields or [] for field in fields : if field in multi_value_fields : # Get a list for fields that may contain multiple values values = self . request . POST . getlist ( field ) self . target_data [ field ] = values if len ( values ) > 1 else values [ 0 ] else : self . target_data [ field ] = self . request . POST . get ( field ) return self . target_data","title":"extract_target_data"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.get_errors","text":"Returns a list of validation errors. Source code in src\\probo\\request\\transformer.py 136 137 138 def get_errors ( self ): \"\"\"Returns a list of validation errors.\"\"\" return self . errors","title":"get_errors"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.get_field_value","text":"Retrieves the value of a specific field from the request data. :param field: Field name to retrieve :param default: Default value if the field does not exist Source code in src\\probo\\request\\transformer.py 230 231 232 233 234 235 236 237 238 239 240 def get_field_value ( self , field , default = None , ): \"\"\" Retrieves the value of a specific field from the request data. :param field: Field name to retrieve :param default: Default value if the field does not exist \"\"\" return self . post_data . get ( field ) if field in self . post_data else default","title":"get_field_value"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.get_json_field_value","text":"Retrieves a field's value from JSON data in the request. Source code in src\\probo\\request\\transformer.py 242 243 244 245 246 247 248 249 def get_json_field_value ( self , field , default = None ): \"\"\" Retrieves a field's value from JSON data in the request. \"\"\" if not hasattr ( self . request , \"json\" ): raise ValueError ( \"Request does not contain JSON data.\" ) json_data = self . request . json () return json_data . get ( field , default )","title":"get_json_field_value"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.get_request_data","text":"Returns cleaned form data and target fields. Parameters: - organized: If True, returns a dictionary with cleaned and target data organized in separate keys. Returns: Dictionary of cleaned data and target fields. Source code in src\\probo\\request\\transformer.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 def get_request_data ( self , organized = False ): \"\"\" Returns cleaned form data and target fields. Parameters: - organized: If True, returns a dictionary with cleaned and target data organized in separate keys. Returns: Dictionary of cleaned data and target fields. \"\"\" return ( { \"cleaned_data\" : self . cleaned_data , \"post_data\" : self . post_data , \"self.get_data\" : self . get_data , } if organized else { ** self . cleaned_data , ** self . post_data , ** self . get_data , ** self . request_files , } )","title":"get_request_data"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.get_session_data","text":"Retrieves a session variable, returning a default if not found. Source code in src\\probo\\request\\transformer.py 177 178 179 def get_session_data ( self , key , default = None ): \"\"\"Retrieves a session variable, returning a default if not found.\"\"\" return self . request . session . get ( key , default )","title":"get_session_data"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.has_field","text":"Checks if a field exists in the request data. Source code in src\\probo\\request\\transformer.py 251 252 253 254 255 256 257 def has_field ( self , field ): \"\"\" Checks if a field exists in the request data. \"\"\" return field in self . post_data or ( hasattr ( self . request , \"json\" ) and field in self . request . json () )","title":"has_field"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.is_valid","text":"Validates the request form and ensures all target data fields are provided. Source code in src\\probo\\request\\transformer.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 def is_valid ( self ): \"\"\"Validates the request form and ensures all target data fields are provided.\"\"\" # Validate the form if it was provided if self . form and not self . form . is_valid (): self . errors . update ( ** { self . form_class . __name__ : self . form . errors . values ()}) # Check if each target data field has at least one value \"\"\"for field, values in self.post_data.items(): if not values: self.errors.update(f'{field}':f\"Please select at least one option for '{field}'.\") \"\"\" # Populate cleaned_data with form data if the form is valid if self . form and self . form . is_valid (): self . cleaned_data . update ( self . form . cleaned_data ) return not self . errors # Returns True if there are no errors","title":"is_valid"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.set_session_data","text":"Sets a session variable. Source code in src\\probo\\request\\transformer.py 171 172 173 174 175 def set_session_data ( self , key , value ): \"\"\"Sets a session variable.\"\"\" self . request . session [ key ] = value self . request . session . modified = True # Mark session as modified self . session_data = self . _get_all_session_data () # Update session_data","title":"set_session_data"},{"location":"reference/probo/request/transformer/#probo.request.transformer.RequestDataTransformer.update_session_data","text":"Updates a session variable using a provided function. Source code in src\\probo\\request\\transformer.py 181 182 183 184 185 186 def update_session_data ( self , key , update_func ): \"\"\"Updates a session variable using a provided function.\"\"\" if key in self . request . session : self . request . session [ key ] = update_func ( self . request . session [ key ]) self . request . session . modified = True self . session_data = self . _get_all_session_data () # Update session_data","title":"update_session_data"},{"location":"reference/probo/shortcuts/configs/","text":"configs ComponentConfig dataclass The Master Configuration. Defines the Component's Identity, Structure, State, and Style. usage: from probo.shortcuts import Flow from probo.shortcuts.configs import ComponentConfig, StateConfig, StyleConfig, ElementState 1. Define the Config card_config = ComponentConfig( name=\"UserCard\", template=\" <$ ... $> \", # Define Elements & Data elements=[ElementState('span', d_state='username')], state=StateConfig( d_data={'username': 'Youness'}, strict=True ), # Define Styles (CSS + Bootstrap) style=StyleConfig( # Custom JIT CSS css={'#card': {'border': '1px solid black'}}, # Bootstrap Classes for the root bs5_classes=['card', 'shadow-sm', 'p-3'] ) ) 2. Build comp = Flow.component(card_config) 3. Render Result: ... CSS: #card { border: 1px solid black; } comp.render() This architecture is scalable, type-safe, and supports your specific requirement of mixing JIT CSS with Bootstrap classes seamlessly. Source code in src\\probo\\shortcuts\\configs.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 @dataclass class ComponentConfig : \"\"\" The Master Configuration. Defines the Component's Identity, Structure, State, and Style. usage: from probo.shortcuts import Flow from probo.shortcuts.configs import ComponentConfig, StateConfig, StyleConfig, ElementState # 1. Define the Config card_config = ComponentConfig( name=\"UserCard\", template=\"<div id='card'> <$ ... $> </div>\", # Define Elements & Data elements=[ElementState('span', d_state='username')], state=StateConfig( d_data={'username': 'Youness'}, strict=True ), # Define Styles (CSS + Bootstrap) style=StyleConfig( # Custom JIT CSS css={'#card': {'border': '1px solid black'}}, # Bootstrap Classes for the root bs5_classes=['card', 'shadow-sm', 'p-3'] ) ) # 2. Build comp = Flow.component(card_config) # 3. Render # Result: <div id='card' class='card shadow-sm p-3'>...</div> # CSS: #card { border: 1px solid black; } comp.render() This architecture is scalable, type-safe, and supports your specific requirement of mixing JIT CSS with Bootstrap classes seamlessly. \"\"\" name : str template : str # Composition state_config : StateConfig = field ( default_factory = StateConfig ) style_config : StyleConfig = field ( default_factory = StyleConfig ) children : Dict [ str , Any ] = field ( default_factory = dict ) # Child Components or Elements props : Dict [ str , Any ] = field ( default_factory = dict ) # Incoming Props root_element : str = None # Default root element tag root_attrs : Dict [ str , str ] = field ( default_factory = dict ) # Attributes for root ElementStateConfig dataclass Configuration for Individual Elements within a Component. Source code in src\\probo\\shortcuts\\configs.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @dataclass class ElementStateConfig : \"\"\" Configuration for Individual Elements within a Component. \"\"\" tag : str config_id : str = field ( default_factory = lambda : uuid . uuid4 () . hex ) s_state : str = field ( default_factory = str ) d_state : str = field ( default_factory = str ) c_state : str = field ( default_factory = str ) is_custom = False props : StateProps = field ( default_factory = StateProps ) bind_to : str = field ( default_factory = str ) i_state = False hide_dynamic = False is_void_element : bool = False attrs : Dict [ str , Any ] = field ( default_factory = dict ) def __post_init__ ( self , ): self . config_id = f \" { self . tag } == { self . config_id } \" FormConfig dataclass Configuration for Forms (Connecting the Bridge). Source code in src\\probo\\shortcuts\\configs.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 @dataclass class FormConfig : \"\"\" Configuration for Forms (Connecting the Bridge). \"\"\" action : str = \"\" method : str = \"post\" # Mode A: Django Integration request : Any = None # The Django request object form_class : Any = None # The Django Form Class # Mode B: Manual fields : list = field ( default_factory = list ) # List of ProboFormField csrf_token : str = None def __on_init__ ( self ): if not self . request or not self . form_class : # Ensure fields are ProboFormField instances self . fields = [ field if isinstance ( field , ProboFormField ) else ProboFormField ( ** field ) for field in self . fields ] LayoutConfig dataclass Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. Source code in src\\probo\\shortcuts\\configs.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 @dataclass class LayoutConfig : \"\"\" Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. \"\"\" # Fixed Regions (Components or HTML strings) layout_slots : list [ str ] = field ( default_factory = list ) # The main content wrapper configuration # e.g. <main id=\"content\"> or <div class=\"container\"> wrapper_tag : str = \"main\" wrapper_attrs : Dict [ str , str ] = field ( default_factory = dict ) wrapper_index : int = field ( default_factory = int ) # Default content for slots if not provided during swap defaults : Dict [ str , Any ] = field ( default_factory = dict ) ListConfig dataclass Configuration for Repeated Elements (Collections). Replaces manual loop() calls. Source code in src\\probo\\shortcuts\\configs.py 196 197 198 199 200 201 202 203 204 205 206 207 208 @dataclass class ListConfig : \"\"\" Configuration for Repeated Elements (Collections). Replaces manual loop() calls. \"\"\" items : list # The data source wrapper_tag : str = \"div\" # e.g., 'ul', 'div' wrapper_attrs : Dict [ str , str ] = field ( default_factory = dict ) # The Renderer: A function that takes an item and returns an Element/String item_renderer : Any = None PageConfig dataclass Configuration for a Full HTML Document. Source code in src\\probo\\shortcuts\\configs.py 166 167 168 169 170 171 172 173 174 175 176 177 178 @dataclass class PageConfig : \"\"\" Configuration for a Full HTML Document. \"\"\" head_config : HeadConfig = field ( default_factory = HeadConfig ) # The body content. Can be a string, a Component, or a ComponentConfig body : Union [ str , Component , ComponentConfig ] = \"\" layout_config : Union [ \"LayoutConfig\" , \"SemanticLayoutConfig\" ] = \"\" lang : str = \"en\" doc_type_func : str = doctype SEOConfig dataclass Advanced Meta Tags for Social Media (Open Graph, Twitter) and Search. Source code in src\\probo\\shortcuts\\configs.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @dataclass class SEOConfig : \"\"\" Advanced Meta Tags for Social Media (Open Graph, Twitter) and Search. \"\"\" # Standard description : str = \"\" keywords : List [ str ] = field ( default_factory = list ) canonical_url : Optional [ str ] = None robots : str = \"index, follow\" # Open Graph (Facebook/LinkedIn) og_title : Optional [ str ] = None # Defaults to page title if None og_type : str = \"website\" og_url : Optional [ str ] = None og_image : Optional [ str ] = None og_site_name : Optional [ str ] = None # Twitter Card twitter_card : str = \"summary_large_image\" twitter_site : Optional [ str ] = None # @username twitter_creator : Optional [ str ] = None SemanticLayoutConfig dataclass Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. Source code in src\\probo\\shortcuts\\configs.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 @dataclass class SemanticLayoutConfig : \"\"\" Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. \"\"\" # Fixed Regions (Components or HTML strings) header : Any = None footer : Any = None sidebar : Any = None sections : Dict [ str , Any ] = field ( default_factory = dict ) articles : Dict [ str , Any ] = field ( default_factory = dict ) # The main content wrapper configuration # e.g. <main id=\"content\"> or <div class=\"container\"> wrapper_tag : str = \"main\" wrapper_attrs : Dict [ str , str ] = field ( default_factory = dict ) # Default content for slots if not provided during swap defaults : Dict [ str , Any ] = field ( default_factory = dict ) StateConfig dataclass Configures the 'Brain' (Data & Logic). Source code in src\\probo\\shortcuts\\configs.py 39 40 41 42 43 44 45 46 47 48 49 50 51 @dataclass class StateConfig : \"\"\" Configures the 'Brain' (Data & Logic). \"\"\" s_data : Dict [ str , Any ] = field ( default_factory = dict ) d_data : Dict [ str , Any ] = field ( default_factory = dict ) props : Dict [ str , Any ] = field ( default_factory = dict ) elements_state_config : List [ ElementStateConfig ] = field ( default_factory = list ) # Flags strict : bool = False require_props : bool = False StyleConfig dataclass Configures the 'Skin' (CSS & Frameworks). Pluggable: Can handle raw CSS, Theme Lists, or Framework classes. Source code in src\\probo\\shortcuts\\configs.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class StyleConfig : \"\"\" Configures the 'Skin' (CSS & Frameworks). Pluggable: Can handle raw CSS, Theme Lists, or Framework classes. \"\"\" # 1. JIT CSS Rules (Dict or List of Rules) css : Union [ Dict , List [ CssRule ]] = field ( default_factory = dict ) # 2. Root Element Overrides (Inline styles or specific ID styling) root_css : Dict [ str , str ] = field ( default_factory = dict ) # 3. Bootstrap 5 Support # List of classes to auto-append to the root element (e.g. ['card', 'p-3']) root_bs5_classes : List [ str ] = field ( default_factory = list ) TableConfig dataclass Config for Flow.datatable. Source code in src\\probo\\shortcuts\\configs.py 280 281 282 283 284 285 286 287 @dataclass class TableConfig : \"\"\"Config for Flow.datatable.\"\"\" columns : List [ str ] # Keys to display data : List [ Dict ] # List of dicts or objects table_class : str = \"table table-striped\" actions : List [ Any ] = field ( default_factory = list ) # Edit/Delete buttons ThemeConfig dataclass Config for Flow.theme (CSS Variables). Source code in src\\probo\\shortcuts\\configs.py 290 291 292 293 294 295 296 @dataclass class ThemeConfig : \"\"\"Config for Flow.theme (CSS Variables).\"\"\" colors : Dict [ str , str ] = field ( default_factory = dict ) typography : Dict [ str , str ] = field ( default_factory = dict ) spacing : str = \"0.25rem\" XmlConfig dataclass Configuration for XML Data Labeling / Feeds. Source code in src\\probo\\shortcuts\\configs.py 181 182 183 184 185 186 187 188 189 190 191 192 193 @dataclass class XmlConfig : \"\"\" Configuration for XML Data Labeling / Feeds. \"\"\" root_tag : str attributes : Dict [ str , str ] = field ( default_factory = dict ) content : Any = \"\" # Can be string, list of Elements, or Dict (for auto-conversion) # XML Specifics declaration : str = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' is_cdata : bool = False # Wrap content in <![CDATA[...]]>","title":"configs"},{"location":"reference/probo/shortcuts/configs/#configs","text":"","title":"configs"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ComponentConfig","text":"The Master Configuration. Defines the Component's Identity, Structure, State, and Style. usage: from probo.shortcuts import Flow from probo.shortcuts.configs import ComponentConfig, StateConfig, StyleConfig, ElementState","title":"ComponentConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ComponentConfig--1-define-the-config","text":"card_config = ComponentConfig( name=\"UserCard\", template=\" <$ ... $> \", # Define Elements & Data elements=[ElementState('span', d_state='username')], state=StateConfig( d_data={'username': 'Youness'}, strict=True ), # Define Styles (CSS + Bootstrap) style=StyleConfig( # Custom JIT CSS css={'#card': {'border': '1px solid black'}}, # Bootstrap Classes for the root bs5_classes=['card', 'shadow-sm', 'p-3'] ) )","title":"1. Define the Config"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ComponentConfig--2-build","text":"comp = Flow.component(card_config)","title":"2. Build"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ComponentConfig--3-render","text":"","title":"3. Render"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ComponentConfig--result","text":"","title":"Result: ..."},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ComponentConfig--css-card-border-1px-solid-black","text":"comp.render() This architecture is scalable, type-safe, and supports your specific requirement of mixing JIT CSS with Bootstrap classes seamlessly. Source code in src\\probo\\shortcuts\\configs.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 @dataclass class ComponentConfig : \"\"\" The Master Configuration. Defines the Component's Identity, Structure, State, and Style. usage: from probo.shortcuts import Flow from probo.shortcuts.configs import ComponentConfig, StateConfig, StyleConfig, ElementState # 1. Define the Config card_config = ComponentConfig( name=\"UserCard\", template=\"<div id='card'> <$ ... $> </div>\", # Define Elements & Data elements=[ElementState('span', d_state='username')], state=StateConfig( d_data={'username': 'Youness'}, strict=True ), # Define Styles (CSS + Bootstrap) style=StyleConfig( # Custom JIT CSS css={'#card': {'border': '1px solid black'}}, # Bootstrap Classes for the root bs5_classes=['card', 'shadow-sm', 'p-3'] ) ) # 2. Build comp = Flow.component(card_config) # 3. Render # Result: <div id='card' class='card shadow-sm p-3'>...</div> # CSS: #card { border: 1px solid black; } comp.render() This architecture is scalable, type-safe, and supports your specific requirement of mixing JIT CSS with Bootstrap classes seamlessly. \"\"\" name : str template : str # Composition state_config : StateConfig = field ( default_factory = StateConfig ) style_config : StyleConfig = field ( default_factory = StyleConfig ) children : Dict [ str , Any ] = field ( default_factory = dict ) # Child Components or Elements props : Dict [ str , Any ] = field ( default_factory = dict ) # Incoming Props root_element : str = None # Default root element tag root_attrs : Dict [ str , str ] = field ( default_factory = dict ) # Attributes for root","title":"CSS: #card { border: 1px solid black; }"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ElementStateConfig","text":"Configuration for Individual Elements within a Component. Source code in src\\probo\\shortcuts\\configs.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 @dataclass class ElementStateConfig : \"\"\" Configuration for Individual Elements within a Component. \"\"\" tag : str config_id : str = field ( default_factory = lambda : uuid . uuid4 () . hex ) s_state : str = field ( default_factory = str ) d_state : str = field ( default_factory = str ) c_state : str = field ( default_factory = str ) is_custom = False props : StateProps = field ( default_factory = StateProps ) bind_to : str = field ( default_factory = str ) i_state = False hide_dynamic = False is_void_element : bool = False attrs : Dict [ str , Any ] = field ( default_factory = dict ) def __post_init__ ( self , ): self . config_id = f \" { self . tag } == { self . config_id } \"","title":"ElementStateConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.FormConfig","text":"Configuration for Forms (Connecting the Bridge). Source code in src\\probo\\shortcuts\\configs.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 @dataclass class FormConfig : \"\"\" Configuration for Forms (Connecting the Bridge). \"\"\" action : str = \"\" method : str = \"post\" # Mode A: Django Integration request : Any = None # The Django request object form_class : Any = None # The Django Form Class # Mode B: Manual fields : list = field ( default_factory = list ) # List of ProboFormField csrf_token : str = None def __on_init__ ( self ): if not self . request or not self . form_class : # Ensure fields are ProboFormField instances self . fields = [ field if isinstance ( field , ProboFormField ) else ProboFormField ( ** field ) for field in self . fields ]","title":"FormConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.LayoutConfig","text":"Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. Source code in src\\probo\\shortcuts\\configs.py 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 @dataclass class LayoutConfig : \"\"\" Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. \"\"\" # Fixed Regions (Components or HTML strings) layout_slots : list [ str ] = field ( default_factory = list ) # The main content wrapper configuration # e.g. <main id=\"content\"> or <div class=\"container\"> wrapper_tag : str = \"main\" wrapper_attrs : Dict [ str , str ] = field ( default_factory = dict ) wrapper_index : int = field ( default_factory = int ) # Default content for slots if not provided during swap defaults : Dict [ str , Any ] = field ( default_factory = dict )","title":"LayoutConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ListConfig","text":"Configuration for Repeated Elements (Collections). Replaces manual loop() calls. Source code in src\\probo\\shortcuts\\configs.py 196 197 198 199 200 201 202 203 204 205 206 207 208 @dataclass class ListConfig : \"\"\" Configuration for Repeated Elements (Collections). Replaces manual loop() calls. \"\"\" items : list # The data source wrapper_tag : str = \"div\" # e.g., 'ul', 'div' wrapper_attrs : Dict [ str , str ] = field ( default_factory = dict ) # The Renderer: A function that takes an item and returns an Element/String item_renderer : Any = None","title":"ListConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.PageConfig","text":"Configuration for a Full HTML Document. Source code in src\\probo\\shortcuts\\configs.py 166 167 168 169 170 171 172 173 174 175 176 177 178 @dataclass class PageConfig : \"\"\" Configuration for a Full HTML Document. \"\"\" head_config : HeadConfig = field ( default_factory = HeadConfig ) # The body content. Can be a string, a Component, or a ComponentConfig body : Union [ str , Component , ComponentConfig ] = \"\" layout_config : Union [ \"LayoutConfig\" , \"SemanticLayoutConfig\" ] = \"\" lang : str = \"en\" doc_type_func : str = doctype","title":"PageConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.SEOConfig","text":"Advanced Meta Tags for Social Media (Open Graph, Twitter) and Search. Source code in src\\probo\\shortcuts\\configs.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 @dataclass class SEOConfig : \"\"\" Advanced Meta Tags for Social Media (Open Graph, Twitter) and Search. \"\"\" # Standard description : str = \"\" keywords : List [ str ] = field ( default_factory = list ) canonical_url : Optional [ str ] = None robots : str = \"index, follow\" # Open Graph (Facebook/LinkedIn) og_title : Optional [ str ] = None # Defaults to page title if None og_type : str = \"website\" og_url : Optional [ str ] = None og_image : Optional [ str ] = None og_site_name : Optional [ str ] = None # Twitter Card twitter_card : str = \"summary_large_image\" twitter_site : Optional [ str ] = None # @username twitter_creator : Optional [ str ] = None","title":"SEOConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.SemanticLayoutConfig","text":"Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. Source code in src\\probo\\shortcuts\\configs.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 @dataclass class SemanticLayoutConfig : \"\"\" Configuration for a Reusable Page Layout. Example: A Dashboard Layout with fixed Sidebar and Header. \"\"\" # Fixed Regions (Components or HTML strings) header : Any = None footer : Any = None sidebar : Any = None sections : Dict [ str , Any ] = field ( default_factory = dict ) articles : Dict [ str , Any ] = field ( default_factory = dict ) # The main content wrapper configuration # e.g. <main id=\"content\"> or <div class=\"container\"> wrapper_tag : str = \"main\" wrapper_attrs : Dict [ str , str ] = field ( default_factory = dict ) # Default content for slots if not provided during swap defaults : Dict [ str , Any ] = field ( default_factory = dict )","title":"SemanticLayoutConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.StateConfig","text":"Configures the 'Brain' (Data & Logic). Source code in src\\probo\\shortcuts\\configs.py 39 40 41 42 43 44 45 46 47 48 49 50 51 @dataclass class StateConfig : \"\"\" Configures the 'Brain' (Data & Logic). \"\"\" s_data : Dict [ str , Any ] = field ( default_factory = dict ) d_data : Dict [ str , Any ] = field ( default_factory = dict ) props : Dict [ str , Any ] = field ( default_factory = dict ) elements_state_config : List [ ElementStateConfig ] = field ( default_factory = list ) # Flags strict : bool = False require_props : bool = False","title":"StateConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.StyleConfig","text":"Configures the 'Skin' (CSS & Frameworks). Pluggable: Can handle raw CSS, Theme Lists, or Framework classes. Source code in src\\probo\\shortcuts\\configs.py 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 @dataclass class StyleConfig : \"\"\" Configures the 'Skin' (CSS & Frameworks). Pluggable: Can handle raw CSS, Theme Lists, or Framework classes. \"\"\" # 1. JIT CSS Rules (Dict or List of Rules) css : Union [ Dict , List [ CssRule ]] = field ( default_factory = dict ) # 2. Root Element Overrides (Inline styles or specific ID styling) root_css : Dict [ str , str ] = field ( default_factory = dict ) # 3. Bootstrap 5 Support # List of classes to auto-append to the root element (e.g. ['card', 'p-3']) root_bs5_classes : List [ str ] = field ( default_factory = list )","title":"StyleConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.TableConfig","text":"Config for Flow.datatable. Source code in src\\probo\\shortcuts\\configs.py 280 281 282 283 284 285 286 287 @dataclass class TableConfig : \"\"\"Config for Flow.datatable.\"\"\" columns : List [ str ] # Keys to display data : List [ Dict ] # List of dicts or objects table_class : str = \"table table-striped\" actions : List [ Any ] = field ( default_factory = list ) # Edit/Delete buttons","title":"TableConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.ThemeConfig","text":"Config for Flow.theme (CSS Variables). Source code in src\\probo\\shortcuts\\configs.py 290 291 292 293 294 295 296 @dataclass class ThemeConfig : \"\"\"Config for Flow.theme (CSS Variables).\"\"\" colors : Dict [ str , str ] = field ( default_factory = dict ) typography : Dict [ str , str ] = field ( default_factory = dict ) spacing : str = \"0.25rem\"","title":"ThemeConfig"},{"location":"reference/probo/shortcuts/configs/#probo.shortcuts.configs.XmlConfig","text":"Configuration for XML Data Labeling / Feeds. Source code in src\\probo\\shortcuts\\configs.py 181 182 183 184 185 186 187 188 189 190 191 192 193 @dataclass class XmlConfig : \"\"\" Configuration for XML Data Labeling / Feeds. \"\"\" root_tag : str attributes : Dict [ str , str ] = field ( default_factory = dict ) content : Any = \"\" # Can be string, list of Elements, or Dict (for auto-conversion) # XML Specifics declaration : str = '<?xml version=\"1.0\" encoding=\"UTF-8\"?>' is_cdata : bool = False # Wrap content in <![CDATA[...]]>","title":"XmlConfig"},{"location":"reference/probo/shortcuts/shortcuts/","text":"shortcuts component ( config ) a shortcut to Builds a Component from a Configuration Object. Handles State, Styles (CSS/BS5), and Structure in one pass. Source code in src\\probo\\shortcuts\\shortcuts.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def component ( config : ComponentConfig ) -> Component : \"\"\" a shortcut to Builds a Component from a Configuration Object. Handles State, Styles (CSS/BS5), and Structure in one pass. \"\"\" # 1. Build State (The Brain) # We unpack the specific StateConfig dataclass es_list = list () for esc in config . state_config . elements_state_config : es = make_es_from_esc ( esc ) es_list . append ( es ) config . template = config . template . replace ( esc . config_id , es . placeholder ) state_obj = ComponentState ( * es_list , # ElementStates are passed as *args to CS s_data = config . state_config . s_data , d_data = config . state_config . d_data , strict = config . state_config . strict , # require_props_definition=config.state_config.require_props, ** config . state_config . props , ) # 2. Initialize Component (The Structure) comp = Component ( name = config . name , template = str ( config . template ), state = state_obj , * config . children , ** config . props , ) # 3. Apply Styles (The Skin) style_conf = config . style_config # A. JIT CSS Rules if style_conf . css : # change_skin handles dicts or lists of rules automatically comp . load_css_rules ( ** style_conf . css ) # B. Root Element Styles (kwargs) if style_conf . root_css : comp . change_skin ( root_css = style_conf . root_css ) # C. Bootstrap 5 Classes if style_conf . root_bs5_classes : bs5_string = \" \" . join ( style_conf . root_bs5_classes ) current = config . root_attrs . get ( \"class\" , \"\" ) config . root_attrs [ \"class\" ] = f \" { current } { bs5_string } \" . strip () if config . root_element : comp . set_root_element ( config . root_element , ** config . root_attrs ) return comp custom ( tag , content = '' , is_void_element = False , ** attrs ) Creates a custom HTML tag string immediately. Source code in src\\probo\\shortcuts\\shortcuts.py 41 42 43 44 45 46 47 48 def custom ( tag : str , content : str = \"\" , is_void_element : bool = False , ** attrs ) -> str : \"\"\"Creates a custom HTML tag string immediately.\"\"\" return ( Element () . custom_element ( tag , content = content , is_void_element = is_void_element , ** attrs ) . stringify_element () . element ) datatable ( config ) Generates a clean HTML Table. Source code in src\\probo\\shortcuts\\shortcuts.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def datatable ( config : TableConfig ) -> str : \"\"\" Generates a clean HTML Table. \"\"\" # Header th_str = \"\" . join ( f \"<th> { col . title () } </th>\" for col in config . columns ) thead = f \"<thead><tr> { th_str } </tr></thead>\" # Body rows = [] for row in config . data : # Handle dict access or object attribute access td_str = \"\" for col in config . columns : val = row . get ( col , \"\" ) if isinstance ( row , dict ) else getattr ( row , col , \"\" ) td_str += f \"<td> { val } </td>\" rows . append ( f \"<tr> { td_str } </tr>\" ) tbody = f \"<tbody> { '' . join ( rows ) } </tbody>\" return f '<table class=\" { config . table_class } \"> { thead }{ tbody } </table>' document ( config ) Assembles a full HTML Document Template. Wires up Head + Body + Layout. Source code in src\\probo\\shortcuts\\shortcuts.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def document ( config : PageConfig ) -> Template : \"\"\" Assembles a full HTML Document Template. Wires up Head + Body + Layout. \"\"\" # 1. Build Head head_obj = head_seo ( config . head_config ) # 2. Prepare Body # If body is a Component or Config, render it to string/html body_content = config . body if hasattr ( body_content , \"render\" ): body_content = body_content . render ()[ 0 ] # 3. Assemble Template # We use a standard layout where 'main' is the body slot slots = { \"main\" : body_content } # If PageConfig has layout info (optional future expansion), handle here # For now, standard document structure tmpl = Template ( separator = \" \\n \" , ** slots ) tmpl . head = head_obj return tmpl head_seo ( config ) Constructs a fully populated Head object with SEO metadata. Source code in src\\probo\\shortcuts\\shortcuts.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def head_seo ( config : HeadConfig ) -> Head : \"\"\" Constructs a fully populated Head object with SEO metadata. \"\"\" head = Head () # 1. Essentials head . set_title ( config . title ) head . register_meta ( charset = config . charset ) head . register_meta ( name = \"viewport\" , content = config . viewport ) # 2. SEO Config (If present) if config . seo : s = config . seo if s . description : head . register_meta ( name = \"description\" , content = s . description ) if s . keywords : head . register_meta ( name = \"keywords\" , content = \",\" . join ( s . keywords )) if s . canonical_url : head . register_link ( rel = \"canonical\" , href = s . canonical_url ) if s . robots : head . register_meta ( name = \"robots\" , content = s . robots ) # Social (Open Graph) if s . og_title : head . register_meta ( property = \"og:title\" , content = s . og_title ) if s . og_type : head . register_meta ( property = \"og:type\" , content = s . og_type ) if s . og_image : head . register_meta ( property = \"og:image\" , content = s . og_image ) # Twitter if s . twitter_card : head . register_meta ( name = \"twitter:card\" , content = s . twitter_card ) if s . twitter_creator : head . register_meta ( name = \"twitter:creator\" , content = s . twitter_creator ) # 3. Assets for css in config . css_links : head . register_link ( rel = \"stylesheet\" , href = css ) for js in config . js_scripts : head . register_script ( src = js , defer = True ) # 4. Extra Meta for name , content in config . extra_meta . items (): head . register_meta ( name = name , content = content ) return head iterator ( config ) shortcut Generates a list of items wrapped in a container. Source code in src\\probo\\shortcuts\\shortcuts.py 182 183 184 185 186 187 188 189 190 def iterator ( config : ListConfig ) -> str : \"\"\" shortcut Generates a list of items wrapped in a container. \"\"\" rendered = loop ( config . items , config . item_renderer ) content = \"\" . join ( r . render () if hasattr ( r , \"render\" ) else str ( r ) for r in rendered ) return custom ( config . wrapper_tag , content , ** config . wrapper_attrs ) layout ( config ) a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). Source code in src\\probo\\shortcuts\\shortcuts.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def layout ( config : LayoutConfig ) -> Template : \"\"\" a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). \"\"\" wrapper_tag = config . wrapper_tag wrapper_attrs = config . wrapper_attrs wrapper_index = config . wrapper_index # Default content for slots if not provided during swap defaults = config . defaults content = custom ( wrapper_tag , \"\" . join ( defaults . values ()), ** wrapper_attrs ) if len ( config . layout_slots ) > wrapper_index : config . layout_slots . insert ( wrapper_index , content ) template_slots = { \"layout_slots\" : ( config . layout_slots ), } return Template ( separator = \" \\n \" , ** template_slots ) probo_form ( config ) a shortcut Builds a Form (Django or Manual). Source code in src\\probo\\shortcuts\\shortcuts.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def probo_form ( config : FormConfig ) -> str : \"\"\"a shortcut Builds a Form (Django or Manual).\"\"\" if config . request and config . form_class : rdt = RequestDataTransformer ( config . request , config . form_class ) mf = ProboForm ( config . action , request_data = rdt , method = config . method ) else : mf = ProboForm ( config . action , * config . fields , method = config . method , manual = True , csrf_token = config . csrf_token , ) return mf . render () semantic_layout ( config ) a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). Source code in src\\probo\\shortcuts\\shortcuts.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def semantic_layout ( config : SemanticLayoutConfig ) -> Template : \"\"\" a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). \"\"\" header = config . header footer = config . footer sidebar = config . sidebar sections = \"\" . join ( config . sections . values ()) articles = \"\" . join ( config . articles . values ()) # The main content wrapper configuration # e.g. <main id=\"content\"> or <div class=\"container\"> wrapper_tag = config . wrapper_tag wrapper_attrs = config . wrapper_attrs # Default content for slots if not provided during swap defaults = config . defaults content = custom ( wrapper_tag , sections + articles , ** wrapper_attrs ) template_slots = { \"header\" : header or defaults . get ( \"header\" , \"\" ), \"sidebar\" : sidebar or defaults . get ( \"sidebar\" , \"\" ), \"content\" : content , \"footer\" : footer or defaults . get ( \"footer\" , \"\" ), } return Template ( separator = \" \\n \" , ** template_slots ) set_data ( * variables ) Creates a custom HTML tag string immediately. Source code in src\\probo\\shortcuts\\shortcuts.py 51 52 53 def set_data ( * variables ) -> str : \"\"\"Creates a custom HTML tag string immediately.\"\"\" return Element () . set_data ( * variables ) . stringify_element () . element theme ( config ) Generates the :root CSS variables block. Returns the raw CSS string. Source code in src\\probo\\shortcuts\\shortcuts.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def theme ( config : ThemeConfig ) -> str : \"\"\" Generates the :root CSS variables block. Returns the raw CSS string. \"\"\" css_vars = {} for k , v in config . colors . items (): css_vars [ f \"--color- { k } \" ] = v for k , v in config . typography . items (): css_vars [ f \"--font- { k } \" ] = v if config . spacing : css_vars [ \"--spacing\" ] = config . spacing # Return the rendered CSS rule string return f \":root { CssRule ( ** css_vars ) . render () } \" xml ( config ) shortcut to Generates an XML Document or Fragment. Source code in src\\probo\\shortcuts\\shortcuts.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def xml ( config : XmlConfig ) -> str : \"\"\" shortcut to Generates an XML Document or Fragment. \"\"\" content = config . content # Auto-convert Dict to XML nodes if isinstance ( content , dict ): content = \"\" . join ( custom ( k , str ( v )) for k , v in content . items ()) # Wrap in CDATA if requested if config . is_cdata : content = f \"<![CDATA[ { content } ]]>\" root = custom ( config . root_tag , content , ** config . attributes ) return f \" { config . declaration } \\n { root } \"","title":"shortcuts"},{"location":"reference/probo/shortcuts/shortcuts/#shortcuts","text":"","title":"shortcuts"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.component","text":"a shortcut to Builds a Component from a Configuration Object. Handles State, Styles (CSS/BS5), and Structure in one pass. Source code in src\\probo\\shortcuts\\shortcuts.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 def component ( config : ComponentConfig ) -> Component : \"\"\" a shortcut to Builds a Component from a Configuration Object. Handles State, Styles (CSS/BS5), and Structure in one pass. \"\"\" # 1. Build State (The Brain) # We unpack the specific StateConfig dataclass es_list = list () for esc in config . state_config . elements_state_config : es = make_es_from_esc ( esc ) es_list . append ( es ) config . template = config . template . replace ( esc . config_id , es . placeholder ) state_obj = ComponentState ( * es_list , # ElementStates are passed as *args to CS s_data = config . state_config . s_data , d_data = config . state_config . d_data , strict = config . state_config . strict , # require_props_definition=config.state_config.require_props, ** config . state_config . props , ) # 2. Initialize Component (The Structure) comp = Component ( name = config . name , template = str ( config . template ), state = state_obj , * config . children , ** config . props , ) # 3. Apply Styles (The Skin) style_conf = config . style_config # A. JIT CSS Rules if style_conf . css : # change_skin handles dicts or lists of rules automatically comp . load_css_rules ( ** style_conf . css ) # B. Root Element Styles (kwargs) if style_conf . root_css : comp . change_skin ( root_css = style_conf . root_css ) # C. Bootstrap 5 Classes if style_conf . root_bs5_classes : bs5_string = \" \" . join ( style_conf . root_bs5_classes ) current = config . root_attrs . get ( \"class\" , \"\" ) config . root_attrs [ \"class\" ] = f \" { current } { bs5_string } \" . strip () if config . root_element : comp . set_root_element ( config . root_element , ** config . root_attrs ) return comp","title":"component"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.custom","text":"Creates a custom HTML tag string immediately. Source code in src\\probo\\shortcuts\\shortcuts.py 41 42 43 44 45 46 47 48 def custom ( tag : str , content : str = \"\" , is_void_element : bool = False , ** attrs ) -> str : \"\"\"Creates a custom HTML tag string immediately.\"\"\" return ( Element () . custom_element ( tag , content = content , is_void_element = is_void_element , ** attrs ) . stringify_element () . element )","title":"custom"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.datatable","text":"Generates a clean HTML Table. Source code in src\\probo\\shortcuts\\shortcuts.py 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def datatable ( config : TableConfig ) -> str : \"\"\" Generates a clean HTML Table. \"\"\" # Header th_str = \"\" . join ( f \"<th> { col . title () } </th>\" for col in config . columns ) thead = f \"<thead><tr> { th_str } </tr></thead>\" # Body rows = [] for row in config . data : # Handle dict access or object attribute access td_str = \"\" for col in config . columns : val = row . get ( col , \"\" ) if isinstance ( row , dict ) else getattr ( row , col , \"\" ) td_str += f \"<td> { val } </td>\" rows . append ( f \"<tr> { td_str } </tr>\" ) tbody = f \"<tbody> { '' . join ( rows ) } </tbody>\" return f '<table class=\" { config . table_class } \"> { thead }{ tbody } </table>'","title":"datatable"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.document","text":"Assembles a full HTML Document Template. Wires up Head + Body + Layout. Source code in src\\probo\\shortcuts\\shortcuts.py 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 def document ( config : PageConfig ) -> Template : \"\"\" Assembles a full HTML Document Template. Wires up Head + Body + Layout. \"\"\" # 1. Build Head head_obj = head_seo ( config . head_config ) # 2. Prepare Body # If body is a Component or Config, render it to string/html body_content = config . body if hasattr ( body_content , \"render\" ): body_content = body_content . render ()[ 0 ] # 3. Assemble Template # We use a standard layout where 'main' is the body slot slots = { \"main\" : body_content } # If PageConfig has layout info (optional future expansion), handle here # For now, standard document structure tmpl = Template ( separator = \" \\n \" , ** slots ) tmpl . head = head_obj return tmpl","title":"document"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.head_seo","text":"Constructs a fully populated Head object with SEO metadata. Source code in src\\probo\\shortcuts\\shortcuts.py 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 def head_seo ( config : HeadConfig ) -> Head : \"\"\" Constructs a fully populated Head object with SEO metadata. \"\"\" head = Head () # 1. Essentials head . set_title ( config . title ) head . register_meta ( charset = config . charset ) head . register_meta ( name = \"viewport\" , content = config . viewport ) # 2. SEO Config (If present) if config . seo : s = config . seo if s . description : head . register_meta ( name = \"description\" , content = s . description ) if s . keywords : head . register_meta ( name = \"keywords\" , content = \",\" . join ( s . keywords )) if s . canonical_url : head . register_link ( rel = \"canonical\" , href = s . canonical_url ) if s . robots : head . register_meta ( name = \"robots\" , content = s . robots ) # Social (Open Graph) if s . og_title : head . register_meta ( property = \"og:title\" , content = s . og_title ) if s . og_type : head . register_meta ( property = \"og:type\" , content = s . og_type ) if s . og_image : head . register_meta ( property = \"og:image\" , content = s . og_image ) # Twitter if s . twitter_card : head . register_meta ( name = \"twitter:card\" , content = s . twitter_card ) if s . twitter_creator : head . register_meta ( name = \"twitter:creator\" , content = s . twitter_creator ) # 3. Assets for css in config . css_links : head . register_link ( rel = \"stylesheet\" , href = css ) for js in config . js_scripts : head . register_script ( src = js , defer = True ) # 4. Extra Meta for name , content in config . extra_meta . items (): head . register_meta ( name = name , content = content ) return head","title":"head_seo"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.iterator","text":"shortcut Generates a list of items wrapped in a container. Source code in src\\probo\\shortcuts\\shortcuts.py 182 183 184 185 186 187 188 189 190 def iterator ( config : ListConfig ) -> str : \"\"\" shortcut Generates a list of items wrapped in a container. \"\"\" rendered = loop ( config . items , config . item_renderer ) content = \"\" . join ( r . render () if hasattr ( r , \"render\" ) else str ( r ) for r in rendered ) return custom ( config . wrapper_tag , content , ** config . wrapper_attrs )","title":"iterator"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.layout","text":"a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). Source code in src\\probo\\shortcuts\\shortcuts.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 def layout ( config : LayoutConfig ) -> Template : \"\"\" a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). \"\"\" wrapper_tag = config . wrapper_tag wrapper_attrs = config . wrapper_attrs wrapper_index = config . wrapper_index # Default content for slots if not provided during swap defaults = config . defaults content = custom ( wrapper_tag , \"\" . join ( defaults . values ()), ** wrapper_attrs ) if len ( config . layout_slots ) > wrapper_index : config . layout_slots . insert ( wrapper_index , content ) template_slots = { \"layout_slots\" : ( config . layout_slots ), } return Template ( separator = \" \\n \" , ** template_slots )","title":"layout"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.probo_form","text":"a shortcut Builds a Form (Django or Manual). Source code in src\\probo\\shortcuts\\shortcuts.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 def probo_form ( config : FormConfig ) -> str : \"\"\"a shortcut Builds a Form (Django or Manual).\"\"\" if config . request and config . form_class : rdt = RequestDataTransformer ( config . request , config . form_class ) mf = ProboForm ( config . action , request_data = rdt , method = config . method ) else : mf = ProboForm ( config . action , * config . fields , method = config . method , manual = True , csrf_token = config . csrf_token , ) return mf . render ()","title":"probo_form"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.semantic_layout","text":"a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). Source code in src\\probo\\shortcuts\\shortcuts.py 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 def semantic_layout ( config : SemanticLayoutConfig ) -> Template : \"\"\" a shortcut Generates a Reusable sementic Layout Template. Wires up Header, Footer, Sidebar, and a Main Content Wrapper. Returns a Template object ready for .swap_component(). \"\"\" header = config . header footer = config . footer sidebar = config . sidebar sections = \"\" . join ( config . sections . values ()) articles = \"\" . join ( config . articles . values ()) # The main content wrapper configuration # e.g. <main id=\"content\"> or <div class=\"container\"> wrapper_tag = config . wrapper_tag wrapper_attrs = config . wrapper_attrs # Default content for slots if not provided during swap defaults = config . defaults content = custom ( wrapper_tag , sections + articles , ** wrapper_attrs ) template_slots = { \"header\" : header or defaults . get ( \"header\" , \"\" ), \"sidebar\" : sidebar or defaults . get ( \"sidebar\" , \"\" ), \"content\" : content , \"footer\" : footer or defaults . get ( \"footer\" , \"\" ), } return Template ( separator = \" \\n \" , ** template_slots )","title":"semantic_layout"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.set_data","text":"Creates a custom HTML tag string immediately. Source code in src\\probo\\shortcuts\\shortcuts.py 51 52 53 def set_data ( * variables ) -> str : \"\"\"Creates a custom HTML tag string immediately.\"\"\" return Element () . set_data ( * variables ) . stringify_element () . element","title":"set_data"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.theme","text":"Generates the :root CSS variables block. Returns the raw CSS string. Source code in src\\probo\\shortcuts\\shortcuts.py 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 def theme ( config : ThemeConfig ) -> str : \"\"\" Generates the :root CSS variables block. Returns the raw CSS string. \"\"\" css_vars = {} for k , v in config . colors . items (): css_vars [ f \"--color- { k } \" ] = v for k , v in config . typography . items (): css_vars [ f \"--font- { k } \" ] = v if config . spacing : css_vars [ \"--spacing\" ] = config . spacing # Return the rendered CSS rule string return f \":root { CssRule ( ** css_vars ) . render () } \"","title":"theme"},{"location":"reference/probo/shortcuts/shortcuts/#probo.shortcuts.shortcuts.xml","text":"shortcut to Generates an XML Document or Fragment. Source code in src\\probo\\shortcuts\\shortcuts.py 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 def xml ( config : XmlConfig ) -> str : \"\"\" shortcut to Generates an XML Document or Fragment. \"\"\" content = config . content # Auto-convert Dict to XML nodes if isinstance ( content , dict ): content = \"\" . join ( custom ( k , str ( v )) for k , v in content . items ()) # Wrap in CDATA if requested if config . is_cdata : content = f \"<![CDATA[ { content } ]]>\" root = custom ( config . root_tag , content , ** config . attributes ) return f \" { config . declaration } \\n { root } \"","title":"xml"},{"location":"reference/probo/shortcuts/shortcuts_utils/","text":"shortcuts_utils make_es_from_esc ( config ) Helper to create ElementState from ElementStateConfig. Source code in src\\probo\\shortcuts\\shortcuts_utils.py 5 6 7 8 9 10 11 12 13 14 15 def make_es_from_esc ( config : ElementStateConfig ) -> ElementState : \"\"\"Helper to create ElementState from ElementStateConfig.\"\"\" return ElementState ( element = config . tag , s_state = config . s_state , d_state = config . d_state , c_state = config . c_state , hide_dynamic = config . hide_dynamic , is_void_element = config . is_void_element , attrs = config . attrs , )","title":"shortcuts_utils"},{"location":"reference/probo/shortcuts/shortcuts_utils/#shortcuts_utils","text":"","title":"shortcuts_utils"},{"location":"reference/probo/shortcuts/shortcuts_utils/#probo.shortcuts.shortcuts_utils.make_es_from_esc","text":"Helper to create ElementState from ElementStateConfig. Source code in src\\probo\\shortcuts\\shortcuts_utils.py 5 6 7 8 9 10 11 12 13 14 15 def make_es_from_esc ( config : ElementStateConfig ) -> ElementState : \"\"\"Helper to create ElementState from ElementStateConfig.\"\"\" return ElementState ( element = config . tag , s_state = config . s_state , d_state = config . d_state , c_state = config . c_state , hide_dynamic = config . hide_dynamic , is_void_element = config . is_void_element , attrs = config . attrs , )","title":"make_es_from_esc"},{"location":"reference/probo/styles/css_enum/","text":"css_enum CssPropertyEnum Bases: Enum Source code in src\\probo\\styles\\css_enum.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class CssPropertyEnum ( Enum ): ACCENT_COLOR = \"accent-color: %s \" ALIGN_CONTENT = \"align-content: %s \" ALIGN_ITEMS = \"align-items: %s \" ALIGN_SELF = \"align-self: %s \" ALL = \"all: %s \" ANIMATION = \"animation: %s \" ANIMATION_DELAY = \"animation-delay: %s \" ANIMATION_DIRECTION = \"animation-direction: %s \" ANIMATION_DURATION = \"animation-duration: %s \" ANIMATION_FILL_MODE = \"animation-fill-mode: %s \" ANIMATION_ITERATION_COUNT = \"animation-iteration-count: %s \" ANIMATION_NAME = \"animation-name: %s \" ANIMATION_PLAY_STATE = \"animation-play-state: %s \" ANIMATION_TIMING_FUNCTION = \"animation-timing-function: %s \" APPEARANCE = \"appearance: %s \" ASPECT_RATIO = \"aspect-ratio: %s \" BACKDROP_FILTER = \"backdrop-filter: %s \" BACKFACE_VISIBILITY = \"backface-visibility: %s \" BACKGROUND = \"background: %s \" BACKGROUND_ATTACHMENT = \"background-attachment: %s \" BACKGROUND_BLEND_MODE = \"background-blend-mode: %s \" BACKGROUND_CLIP = \"background-clip: %s \" BACKGROUND_COLOR = \"background-color: %s \" BACKGROUND_IMAGE = \"background-image: %s \" BACKGROUND_ORIGIN = \"background-origin: %s \" BACKGROUND_POSITION = \"background-position: %s \" BACKGROUND_POSITION_X = \"background-position-x: %s \" BACKGROUND_POSITION_Y = \"background-position-y: %s \" BACKGROUND_REPEAT = \"background-repeat: %s \" BACKGROUND_SIZE = \"background-size: %s \" BLOCK_SIZE = \"block-size: %s \" BORDER = \"border: %s \" BORDER_BLOCK = \"border-block: %s \" BORDER_BLOCK_COLOR = \"border-block-color: %s \" BORDER_BLOCK_END = \"border-block-end: %s \" BORDER_BLOCK_END_COLOR = \"border-block-end-color: %s \" BORDER_BLOCK_END_STYLE = \"border-block-end-style: %s \" BORDER_BLOCK_END_WIDTH = \"border-block-end-width: %s \" BORDER_BLOCK_START = \"border-block-start: %s \" BORDER_BLOCK_START_COLOR = \"border-block-start-color: %s \" BORDER_BLOCK_START_STYLE = \"border-block-start-style: %s \" BORDER_BLOCK_START_WIDTH = \"border-block-start-width: %s \" BORDER_BLOCK_STYLE = \"border-block-style: %s \" BORDER_BLOCK_WIDTH = \"border-block-width: %s \" BORDER_BOTTOM = \"border-bottom: %s \" BORDER_BOTTOM_COLOR = \"border-bottom-color: %s \" BORDER_BOTTOM_LEFT_RADIUS = \"border-bottom-left-radius: %s \" BORDER_BOTTOM_RIGHT_RADIUS = \"border-bottom-right-radius: %s \" BORDER_BOTTOM_STYLE = \"border-bottom-style: %s \" BORDER_BOTTOM_WIDTH = \"border-bottom-width: %s \" BORDER_COLLAPSE = \"border-collapse: %s \" BORDER_COLOR = \"border-color: %s \" BORDER_END_END_RADIUS = \"border-end-end-radius: %s \" BORDER_END_START_RADIUS = \"border-end-start-radius: %s \" BORDER_IMAGE = \"border-image: %s \" BORDER_IMAGE_OUTSET = \"border-image-outset: %s \" BORDER_IMAGE_REPEAT = \"border-image-repeat: %s \" BORDER_IMAGE_SLICE = \"border-image-slice: %s \" BORDER_IMAGE_SOURCE = \"border-image-source: %s \" BORDER_IMAGE_WIDTH = \"border-image-width: %s \" BORDER_INLINE = \"border-inline: %s \" BORDER_INLINE_COLOR = \"border-inline-color: %s \" BORDER_INLINE_END = \"border-inline-end: %s \" BORDER_INLINE_END_COLOR = \"border-inline-end-color: %s \" BORDER_INLINE_END_STYLE = \"border-inline-end-style: %s \" BORDER_INLINE_END_WIDTH = \"border-inline-end-width: %s \" BORDER_INLINE_START = \"border-inline-start: %s \" BORDER_INLINE_START_COLOR = \"border-inline-start-color: %s \" BORDER_INLINE_START_STYLE = \"border-inline-start-style: %s \" BORDER_INLINE_START_WIDTH = \"border-inline-start-width: %s \" BORDER_INLINE_STYLE = \"border-inline-style: %s \" BORDER_INLINE_WIDTH = \"border-inline-width: %s \" BORDER_LEFT = \"border-left: %s \" BORDER_LEFT_COLOR = \"border-left-color: %s \" BORDER_LEFT_STYLE = \"border-left-style: %s \" BORDER_LEFT_WIDTH = \"border-left-width: %s \" BORDER_RADIUS = \"border-radius: %s \" BORDER_RIGHT = \"border-right: %s \" BORDER_RIGHT_COLOR = \"border-right-color: %s \" BORDER_RIGHT_STYLE = \"border-right-style: %s \" BORDER_RIGHT_WIDTH = \"border-right-width: %s \" BORDER_SPACING = \"border-spacing: %s \" BORDER_START_END_RADIUS = \"border-start-end-radius: %s \" BORDER_START_START_RADIUS = \"border-start-start-radius: %s \" BORDER_STYLE = \"border-style: %s \" BORDER_TOP = \"border-top: %s \" BORDER_TOP_COLOR = \"border-top-color: %s \" BORDER_TOP_LEFT_RADIUS = \"border-top-left-radius: %s \" BORDER_TOP_RIGHT_RADIUS = \"border-top-right-radius: %s \" BORDER_TOP_STYLE = \"border-top-style: %s \" BORDER_TOP_WIDTH = \"border-top-width: %s \" BORDER_WIDTH = \"border-width: %s \" BOTTOM = \"bottom: %s \" BOX_DECORATION_BREAK = \"box-decoration-break: %s \" BOX_REFLECT = \"box-reflect: %s \" BOX_SHADOW = \"box-shadow: %s \" BOX_SIZING = \"box-sizing: %s \" BREAK_AFTER = \"break-after: %s \" BREAK_BEFORE = \"break-before: %s \" BREAK_INSIDE = \"break-inside: %s \" CAPTION_SIDE = \"caption-side: %s \" CARET_COLOR = \"caret-color: %s \" AT_CHARSET = \"@charset: %s \" CLEAR = \"clear: %s \" CLIP = \"clip: %s \" CLIP_PATH = \"clip-path: %s \" COLOR = \"color: %s \" COLOR_SCHEME = \"color-scheme: %s \" COLUMN_COUNT = \"column-count: %s \" COLUMN_FILL = \"column-fill: %s \" COLUMN_GAP = \"column-gap: %s \" COLUMN_RULE = \"column-rule: %s \" COLUMN_RULE_COLOR = \"column-rule-color: %s \" COLUMN_RULE_STYLE = \"column-rule-style: %s \" COLUMN_RULE_WIDTH = \"column-rule-width: %s \" COLUMN_SPAN = \"column-span: %s \" COLUMN_WIDTH = \"column-width: %s \" COLUMNS = \"columns: %s \" AT_CONTAINER = \"@container: %s \" CONTENT = \"content: %s \" COUNTER_INCREMENT = \"counter-increment: %s \" COUNTER_RESET = \"counter-reset: %s \" COUNTER_SET = \"counter-set: %s \" AT_COUNTER_STYLE = \"@counter-style: %s \" CURSOR = \"cursor: %s \" DIRECTION = \"direction: %s \" DISPLAY = \"display: %s \" EMPTY_CELLS = \"empty-cells: %s \" FILTER = \"filter: %s \" FLEX = \"flex: %s \" FLEX_BASIS = \"flex-basis: %s \" FLEX_DIRECTION = \"flex-direction: %s \" FLEX_FLOW = \"flex-flow: %s \" FLEX_GROW = \"flex-grow: %s \" FLEX_SHRINK = \"flex-shrink: %s \" FLEX_WRAP = \"flex-wrap: %s \" FLOAT = \"float: %s \" FONT = \"font: %s \" AT_FONT_FACE = \"@font-face: %s \" FONT_FAMILY = \"font-family: %s \" FONT_FEATURE_SETTINGS = \"font-feature-settings: %s \" FONT_KERNING = \"font-kerning: %s \" FONT_LANGUAGE_OVERRIDE = \"font-language-override: %s \" AT_FONT_PALETTE_VALUES = \"@font-palette-values: %s \" FONT_SIZE = \"font-size: %s \" FONT_SIZE_ADJUST = \"font-size-adjust: %s \" FONT_STRETCH = \"font-stretch: %s \" FONT_STYLE = \"font-style: %s \" FONT_SYNTHESIS = \"font-synthesis: %s \" FONT_VARIANT = \"font-variant: %s \" FONT_VARIANT_ALTERNATES = \"font-variant-alternates: %s \" FONT_VARIANT_CAPS = \"font-variant-caps: %s \" FONT_VARIANT_EAST_ASIAN = \"font-variant-east-asian: %s \" FONT_VARIANT_LIGATURES = \"font-variant-ligatures: %s \" FONT_VARIANT_NUMERIC = \"font-variant-numeric: %s \" FONT_VARIANT_POSITION = \"font-variant-position: %s \" FONT_WEIGHT = \"font-weight: %s \" GAP = \"gap: %s \" GRID = \"grid: %s \" GRID_AREA = \"grid-area: %s \" GRID_AUTO_COLUMNS = \"grid-auto-columns: %s \" GRID_AUTO_FLOW = \"grid-auto-flow: %s \" GRID_AUTO_ROWS = \"grid-auto-rows: %s \" GRID_COLUMN = \"grid-column: %s \" GRID_COLUMN_END = \"grid-column-end: %s \" GRID_COLUMN_START = \"grid-column-start: %s \" GRID_ROW = \"grid-row: %s \" GRID_ROW_END = \"grid-row-end: %s \" GRID_ROW_START = \"grid-row-start: %s \" GRID_TEMPLATE = \"grid-template: %s \" GRID_TEMPLATE_AREAS = \"grid-template-areas: %s \" GRID_TEMPLATE_COLUMNS = \"grid-template-columns: %s \" GRID_TEMPLATE_ROWS = \"grid-template-rows: %s \" HANGING_PUNCTUATION = \"hanging-punctuation: %s \" HEIGHT = \"height: %s \" HYPHENS = \"hyphens: %s \" HYPHENATE_CHARACTER = \"hyphenate-character: %s \" IMAGE_RENDERING = \"image-rendering: %s \" AT_IMPORT = \"@import: %s \" INITIAL_LETTER = \"initial-letter: %s \" INLINE_SIZE = \"inline-size: %s \" INSET = \"inset: %s \" INSET_BLOCK = \"inset-block: %s \" INSET_BLOCK_END = \"inset-block-end: %s \" INSET_BLOCK_START = \"inset-block-start: %s \" INSET_INLINE = \"inset-inline: %s \" INSET_INLINE_END = \"inset-inline-end: %s \" INSET_INLINE_START = \"inset-inline-start: %s \" ISOLATION = \"isolation: %s \" JUSTIFY_CONTENT = \"justify-content: %s \" JUSTIFY_ITEMS = \"justify-items: %s \" JUSTIFY_SELF = \"justify-self: %s \" AT_KEYFRAMES = \"@keyframes: %s \" AT_LAYER = \"@layer: %s \" LEFT = \"left: %s \" LETTER_SPACING = \"letter-spacing: %s \" LINE_BREAK = \"line-break: %s \" LINE_HEIGHT = \"line-height: %s \" LIST_STYLE = \"list-style: %s \" LIST_STYLE_IMAGE = \"list-style-image: %s \" LIST_STYLE_POSITION = \"list-style-position: %s \" LIST_STYLE_TYPE = \"list-style-type: %s \" MARGIN = \"margin: %s \" MARGIN_BLOCK = \"margin-block: %s \" MARGIN_BLOCK_END = \"margin-block-end: %s \" MARGIN_BLOCK_START = \"margin-block-start: %s \" MARGIN_BOTTOM = \"margin-bottom: %s \" MARGIN_INLINE = \"margin-inline: %s \" MARGIN_INLINE_END = \"margin-inline-end: %s \" MARGIN_INLINE_START = \"margin-inline-start: %s \" MARGIN_LEFT = \"margin-left: %s \" MARGIN_RIGHT = \"margin-right: %s \" MARGIN_TOP = \"margin-top: %s \" MARKER = \"marker: %s \" MARKER_END = \"marker-end: %s \" MARKER_MID = \"marker-mid: %s \" MARKER_START = \"marker-start: %s \" MASK = \"mask: %s \" MASK_CLIP = \"mask-clip: %s \" MASK_COMPOSITE = \"mask-composite: %s \" MASK_IMAGE = \"mask-image: %s \" MASK_MODE = \"mask-mode: %s \" MASK_ORIGIN = \"mask-origin: %s \" MASK_POSITION = \"mask-position: %s \" MASK_REPEAT = \"mask-repeat: %s \" MASK_SIZE = \"mask-size: %s \" MASK_TYPE = \"mask-type: %s \" MAX_HEIGHT = \"max-height: %s \" MAX_WIDTH = \"max-width: %s \" AT_MEDIA = \"@media: %s \" MAX_BLOCK_SIZE = \"max-block-size: %s \" MAX_INLINE_SIZE = \"max-inline-size: %s \" MIN_BLOCK_SIZE = \"min-block-size: %s \" MIN_INLINE_SIZE = \"min-inline-size: %s \" MIN_HEIGHT = \"min-height: %s \" MIN_WIDTH = \"min-width: %s \" MIX_BLEND_MODE = \"mix-blend-mode: %s \" AT_NAMESPACE = \"@namespace: %s \" OBJECT_FIT = \"object-fit: %s \" OBJECT_POSITION = \"object-position: %s \" OFFSET = \"offset: %s \" OFFSET_ANCHOR = \"offset-anchor: %s \" OFFSET_DISTANCE = \"offset-distance: %s \" OFFSET_PATH = \"offset-path: %s \" OFFSET_POSITION = \"offset-position: %s \" OFFSET_ROTATE = \"offset-rotate: %s \" OPACITY = \"opacity: %s \" ORDER = \"order: %s \" ORPHANS = \"orphans: %s \" OUTLINE = \"outline: %s \" OUTLINE_COLOR = \"outline-color: %s \" OUTLINE_OFFSET = \"outline-offset: %s \" OUTLINE_STYLE = \"outline-style: %s \" OUTLINE_WIDTH = \"outline-width: %s \" OVERFLOW = \"overflow: %s \" OVERFLOW_ANCHOR = \"overflow-anchor: %s \" OVERFLOW_WRAP = \"overflow-wrap: %s \" OVERFLOW_X = \"overflow-x: %s \" OVERFLOW_Y = \"overflow-y: %s \" OVERSCROLL_BEHAVIOR = \"overscroll-behavior: %s \" OVERSCROLL_BEHAVIOR_BLOCK = \"overscroll-behavior-block: %s \" OVERSCROLL_BEHAVIOR_INLINE = \"overscroll-behavior-inline: %s \" OVERSCROLL_BEHAVIOR_X = \"overscroll-behavior-x: %s \" OVERSCROLL_BEHAVIOR_Y = \"overscroll-behavior-y: %s \" PADDING = \"padding: %s \" PADDING_BLOCK = \"padding-block: %s \" PADDING_BLOCK_END = \"padding-block-end: %s \" PADDING_BLOCK_START = \"padding-block-start: %s \" PADDING_BOTTOM = \"padding-bottom: %s \" PADDING_INLINE = \"padding-inline: %s \" PADDING_INLINE_END = \"padding-inline-end: %s \" PADDING_INLINE_START = \"padding-inline-start: %s \" PADDING_LEFT = \"padding-left: %s \" PADDING_RIGHT = \"padding-right: %s \" PADDING_TOP = \"padding-top: %s \" AT_PAGE = \"@page: %s \" PAGE_BREAK_AFTER = \"page-break-after: %s \" PAGE_BREAK_BEFORE = \"page-break-before: %s \" PAGE_BREAK_INSIDE = \"page-break-inside: %s \" PAINT_ORDER = \"paint-order: %s \" PERSPECTIVE = \"perspective: %s \" PERSPECTIVE_ORIGIN = \"perspective-origin: %s \" PLACE_CONTENT = \"place-content: %s \" PLACE_ITEMS = \"place-items: %s \" PLACE_SELF = \"place-self: %s \" POINTER_EVENTS = \"pointer-events: %s \" POSITION = \"position: %s \" AT_PROPERTY = \"@property: %s \" QUOTES = \"quotes: %s \" RESIZE = \"resize: %s \" RIGHT = \"right: %s \" ROTATE = \"rotate: %s \" ROW_GAP = \"row-gap: %s \" SCALE = \"scale: %s \" AT_SCOPE = \"@scope: %s \" SCROLL_BEHAVIOR = \"scroll-behavior: %s \" SCROLL_MARGIN = \"scroll-margin: %s \" SCROLL_MARGIN_BLOCK = \"scroll-margin-block: %s \" SCROLL_MARGIN_BLOCK_END = \"scroll-margin-block-end: %s \" SCROLL_MARGIN_BLOCK_START = \"scroll-margin-block-start: %s \" SCROLL_MARGIN_BOTTOM = \"scroll-margin-bottom: %s \" SCROLL_MARGIN_INLINE = \"scroll-margin-inline: %s \" SCROLL_MARGIN_INLINE_END = \"scroll-margin-inline-end: %s \" SCROLL_MARGIN_INLINE_START = \"scroll-margin-inline-start: %s \" SCROLL_MARGIN_LEFT = \"scroll-margin-left: %s \" SCROLL_MARGIN_RIGHT = \"scroll-margin-right: %s \" SCROLL_MARGIN_TOP = \"scroll-margin-top: %s \" SCROLL_PADDING = \"scroll-padding: %s \" SCROLL_PADDING_BLOCK = \"scroll-padding-block: %s \" SCROLL_PADDING_BLOCK_END = \"scroll-padding-block-end: %s \" SCROLL_PADDING_BLOCK_START = \"scroll-padding-block-start: %s \" SCROLL_PADDING_BOTTOM = \"scroll-padding-bottom: %s \" SCROLL_PADDING_INLINE = \"scroll-padding-inline: %s \" SCROLL_PADDING_INLINE_END = \"scroll-padding-inline-end: %s \" SCROLL_PADDING_INLINE_START = \"scroll-padding-inline-start: %s \" SCROLL_PADDING_LEFT = \"scroll-padding-left: %s \" SCROLL_PADDING_RIGHT = \"scroll-padding-right: %s \" SCROLL_PADDING_TOP = \"scroll-padding-top: %s \" SCROLL_SNAP_ALIGN = \"scroll-snap-align: %s \" SCROLL_SNAP_STOP = \"scroll-snap-stop: %s \" SCROLL_SNAP_TYPE = \"scroll-snap-type: %s \" SCROLLBAR_COLOR = \"scrollbar-color: %s \" SHAPE_OUTSIDE = \"shape-outside: %s \" AT_STARTING_STYLE = \"@starting-style: %s \" AT_SUPPORTS = \"@supports: %s \" TAB_SIZE = \"tab-size: %s \" TABLE_LAYOUT = \"table-layout: %s \" TEXT_ALIGN = \"text-align: %s \" TEXT_ALIGN_LAST = \"text-align-last: %s \" TEXT_COMBINE_UPRIGHT = \"text-combine-upright: %s \" TEXT_DECORATION = \"text-decoration: %s \" TEXT_DECORATION_COLOR = \"text-decoration-color: %s \" TEXT_DECORATION_LINE = \"text-decoration-line: %s \" TEXT_DECORATION_STYLE = \"text-decoration-style: %s \" TEXT_DECORATION_THICKNESS = \"text-decoration-thickness: %s \" TEXT_EMPHASIS = \"text-emphasis: %s \" TEXT_EMPHASIS_COLOR = \"text-emphasis-color: %s \" TEXT_EMPHASIS_POSITION = \"text-emphasis-position: %s \" TEXT_EMPHASIS_STYLE = \"text-emphasis-style: %s \" TEXT_INDENT = \"text-indent: %s \" TEXT_JUSTIFY = \"text-justify: %s \" TEXT_ORIENTATION = \"text-orientation: %s \" TEXT_OVERFLOW = \"text-overflow: %s \" TEXT_SHADOW = \"text-shadow: %s \" TEXT_TRANSFORM = \"text-transform: %s \" TEXT_UNDERLINE_OFFSET = \"text-underline-offset: %s \" TEXT_UNDERLINE_POSITION = \"text-underline-position: %s \" TOP = \"top: %s \" TRANSFORM = \"transform: %s \" TRANSFORM_ORIGIN = \"transform-origin: %s \" TRANSFORM_STYLE = \"transform-style: %s \" TRANSITION = \"transition: %s \" TRANSITION_DELAY = \"transition-delay: %s \" TRANSITION_DURATION = \"transition-duration: %s \" TRANSITION_PROPERTY = \"transition-property: %s \" TRANSITION_TIMING_FUNCTION = \"transition-timing-function: %s \" TRANSLATE = \"translate: %s \" UNICODE_BIDI = \"unicode-bidi: %s \" USER_SELECT = \"user-select: %s \" VERTICAL_ALIGN = \"vertical-align: %s \" VISIBILITY = \"visibility: %s \" WHITE_SPACE = \"white-space: %s \" WIDOWS = \"widows: %s \" WIDTH = \"width: %s \" WORD_BREAK = \"word-break: %s \" WORD_SPACING = \"word-spacing: %s \" WORD_WRAP = \"word-wrap: %s \" WRITING_MODE = \"writing-mode: %s \" Z_INDEX = \"z-index: %s \" ZOOM = \"zoom: %s \" __DEFAULT = None def __call__ ( self , value ): \"\"\"Allows syntax like CssPropertyEnum.COLOR('red')\"\"\" return self . value % value @classmethod def get ( cls , name , default = None ): try : return cls [ name . upper ()] except KeyError : return cls . __DEFAULT __call__ ( value ) Allows syntax like CssPropertyEnum.COLOR('red') Source code in src\\probo\\styles\\css_enum.py 377 378 379 def __call__ ( self , value ): \"\"\"Allows syntax like CssPropertyEnum.COLOR('red')\"\"\" return self . value % value PseudoClassEnum Bases: Enum Source code in src\\probo\\styles\\css_enum.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 class PseudoClassEnum ( Enum ): ACTIVE = \":active\" ANY_LINK = \":any-link\" ANYLINK = \":anylink\" # Non-standard, but sometimes used AUTO_FILL = \":auto-fill\" CHECKED = \":checked\" DEFAULT = \":default\" DEFINED = \":defined\" DIR = \":dir()\" DISABLED = \":disabled\" EMPTY = \":empty\" ENABLED = \":enabled\" FIRST = \":first\" # Paged media FIRST_CHILD = \":first-child\" FIRST_OF_TYPE = \":first-of-type\" FOCUS = \":focus\" FOCUS_VISIBLE = \":focus-visible\" FOCUS_WITHIN = \":focus-within\" FULLSCREEN = \":fullscreen\" HAS = \":has()\" HOVER = \":hover\" IN_RANGE = \":in-range\" INDETERMINATE = \":indeterminate\" INVALID = \":invalid\" IS = \":is()\" LANG = \":lang()\" LAST_CHILD = \":last-child\" LAST_OF_TYPE = \":last-of-type\" LEFT = \":left\" # Paged media LINK = \":link\" MODAL = \":modal\" NOT = \":not()\" NTH_CHILD = \":nth-child()\" NTH_LAST_CHILD = \":nth-last-child()\" NTH_LAST_OF_TYPE = \":nth-last-of-type()\" NTH_OF_TYPE = \":nth-of-type()\" ONLY_CHILD = \":only-child\" ONLY_OF_TYPE = \":only-of-type\" OPTIONAL = \":optional\" OUT_OF_RANGE = \":out-of-range\" PLACEHOLDER_SHOWN = \":placeholder-shown\" POPOVER_OPEN = \":popover-open\" READ_ONLY = \":read-only\" READ_WRITE = \":read-write\" REQUIRED = \":required\" RIGHT = \":right\" # Paged media ROOT = \":root\" SCOPE = \":scope\" STATE = \":state()\" TARGET = \":target\" USER_INVALID = \":user-invalid\" USER_VALID = \":user-valid\" VALID = \":valid\" VISITED = \":visited\" WHERE = \":where()\" # Webkit / Vendor specific (Optional, but useful) WEBKIT_SCROLLBAR = \"::-webkit-scrollbar\" @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup that handles different naming conventions. Examples: - get(':hover') -> HOVER - get('first-child') -> FIRST_CHILD - get('FIRST_CHILD') -> FIRST_CHILD \"\"\" # 1. Remove leading colons # 2. Replace dashes with underscores (CSS -> Python Enum) # 3. Uppercase clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default get ( name , default = None ) classmethod Robust lookup that handles different naming conventions. Examples: - get(':hover') -> HOVER - get('first-child') -> FIRST_CHILD - get('FIRST_CHILD') -> FIRST_CHILD Source code in src\\probo\\styles\\css_enum.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup that handles different naming conventions. Examples: - get(':hover') -> HOVER - get('first-child') -> FIRST_CHILD - get('FIRST_CHILD') -> FIRST_CHILD \"\"\" # 1. Remove leading colons # 2. Replace dashes with underscores (CSS -> Python Enum) # 3. Uppercase clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default PseudoElementEnum Bases: Enum Source code in src\\probo\\styles\\css_enum.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 class PseudoElementEnum ( Enum ): AFTER = \"::after\" BACKDROP = \"::backdrop\" BEFORE = \"::before\" CUE = \"::cue\" FILE_SELECTOR_BUTTON = \"::file-selector-button\" FIRST_LETTER = \"::first-letter\" FIRST_LINE = \"::first-line\" GRAMMAR_ERROR = \"::grammar-error\" # Fixed typo HIGHLIGHT = \"::highlight()\" MARKER = \"::marker\" PART = \"::part()\" PLACEHOLDER = \"::placeholder\" SELECTION = \"::selection\" SLOTTED = \"::slotted()\" SPELLING_ERROR = \"::spelling-error\" TARGET_TEXT = \"::target-text\" VIEW_TRANSITION = \"::view-transition\" VIEW_TRANSITION_GROUP = \"::view-transition-group()\" VIEW_TRANSITION_IMAGE_PAIR = \"::view-transition-image-pair()\" VIEW_TRANSITION_NEW = \"::view-transition-new()\" VIEW_TRANSITION_OLD = \"::view-transition-old()\" @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup for pseudo-elements. Examples: - get('::before') -> BEFORE - get('first-line') -> FIRST_LINE \"\"\" clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default get ( name , default = None ) classmethod Robust lookup for pseudo-elements. Examples: - get('::before') -> BEFORE - get('first-line') -> FIRST_LINE Source code in src\\probo\\styles\\css_enum.py 491 492 493 494 495 496 497 498 499 500 501 502 503 @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup for pseudo-elements. Examples: - get('::before') -> BEFORE - get('first-line') -> FIRST_LINE \"\"\" clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default","title":"css_enum"},{"location":"reference/probo/styles/css_enum/#css_enum","text":"","title":"css_enum"},{"location":"reference/probo/styles/css_enum/#probo.styles.css_enum.CssPropertyEnum","text":"Bases: Enum Source code in src\\probo\\styles\\css_enum.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 class CssPropertyEnum ( Enum ): ACCENT_COLOR = \"accent-color: %s \" ALIGN_CONTENT = \"align-content: %s \" ALIGN_ITEMS = \"align-items: %s \" ALIGN_SELF = \"align-self: %s \" ALL = \"all: %s \" ANIMATION = \"animation: %s \" ANIMATION_DELAY = \"animation-delay: %s \" ANIMATION_DIRECTION = \"animation-direction: %s \" ANIMATION_DURATION = \"animation-duration: %s \" ANIMATION_FILL_MODE = \"animation-fill-mode: %s \" ANIMATION_ITERATION_COUNT = \"animation-iteration-count: %s \" ANIMATION_NAME = \"animation-name: %s \" ANIMATION_PLAY_STATE = \"animation-play-state: %s \" ANIMATION_TIMING_FUNCTION = \"animation-timing-function: %s \" APPEARANCE = \"appearance: %s \" ASPECT_RATIO = \"aspect-ratio: %s \" BACKDROP_FILTER = \"backdrop-filter: %s \" BACKFACE_VISIBILITY = \"backface-visibility: %s \" BACKGROUND = \"background: %s \" BACKGROUND_ATTACHMENT = \"background-attachment: %s \" BACKGROUND_BLEND_MODE = \"background-blend-mode: %s \" BACKGROUND_CLIP = \"background-clip: %s \" BACKGROUND_COLOR = \"background-color: %s \" BACKGROUND_IMAGE = \"background-image: %s \" BACKGROUND_ORIGIN = \"background-origin: %s \" BACKGROUND_POSITION = \"background-position: %s \" BACKGROUND_POSITION_X = \"background-position-x: %s \" BACKGROUND_POSITION_Y = \"background-position-y: %s \" BACKGROUND_REPEAT = \"background-repeat: %s \" BACKGROUND_SIZE = \"background-size: %s \" BLOCK_SIZE = \"block-size: %s \" BORDER = \"border: %s \" BORDER_BLOCK = \"border-block: %s \" BORDER_BLOCK_COLOR = \"border-block-color: %s \" BORDER_BLOCK_END = \"border-block-end: %s \" BORDER_BLOCK_END_COLOR = \"border-block-end-color: %s \" BORDER_BLOCK_END_STYLE = \"border-block-end-style: %s \" BORDER_BLOCK_END_WIDTH = \"border-block-end-width: %s \" BORDER_BLOCK_START = \"border-block-start: %s \" BORDER_BLOCK_START_COLOR = \"border-block-start-color: %s \" BORDER_BLOCK_START_STYLE = \"border-block-start-style: %s \" BORDER_BLOCK_START_WIDTH = \"border-block-start-width: %s \" BORDER_BLOCK_STYLE = \"border-block-style: %s \" BORDER_BLOCK_WIDTH = \"border-block-width: %s \" BORDER_BOTTOM = \"border-bottom: %s \" BORDER_BOTTOM_COLOR = \"border-bottom-color: %s \" BORDER_BOTTOM_LEFT_RADIUS = \"border-bottom-left-radius: %s \" BORDER_BOTTOM_RIGHT_RADIUS = \"border-bottom-right-radius: %s \" BORDER_BOTTOM_STYLE = \"border-bottom-style: %s \" BORDER_BOTTOM_WIDTH = \"border-bottom-width: %s \" BORDER_COLLAPSE = \"border-collapse: %s \" BORDER_COLOR = \"border-color: %s \" BORDER_END_END_RADIUS = \"border-end-end-radius: %s \" BORDER_END_START_RADIUS = \"border-end-start-radius: %s \" BORDER_IMAGE = \"border-image: %s \" BORDER_IMAGE_OUTSET = \"border-image-outset: %s \" BORDER_IMAGE_REPEAT = \"border-image-repeat: %s \" BORDER_IMAGE_SLICE = \"border-image-slice: %s \" BORDER_IMAGE_SOURCE = \"border-image-source: %s \" BORDER_IMAGE_WIDTH = \"border-image-width: %s \" BORDER_INLINE = \"border-inline: %s \" BORDER_INLINE_COLOR = \"border-inline-color: %s \" BORDER_INLINE_END = \"border-inline-end: %s \" BORDER_INLINE_END_COLOR = \"border-inline-end-color: %s \" BORDER_INLINE_END_STYLE = \"border-inline-end-style: %s \" BORDER_INLINE_END_WIDTH = \"border-inline-end-width: %s \" BORDER_INLINE_START = \"border-inline-start: %s \" BORDER_INLINE_START_COLOR = \"border-inline-start-color: %s \" BORDER_INLINE_START_STYLE = \"border-inline-start-style: %s \" BORDER_INLINE_START_WIDTH = \"border-inline-start-width: %s \" BORDER_INLINE_STYLE = \"border-inline-style: %s \" BORDER_INLINE_WIDTH = \"border-inline-width: %s \" BORDER_LEFT = \"border-left: %s \" BORDER_LEFT_COLOR = \"border-left-color: %s \" BORDER_LEFT_STYLE = \"border-left-style: %s \" BORDER_LEFT_WIDTH = \"border-left-width: %s \" BORDER_RADIUS = \"border-radius: %s \" BORDER_RIGHT = \"border-right: %s \" BORDER_RIGHT_COLOR = \"border-right-color: %s \" BORDER_RIGHT_STYLE = \"border-right-style: %s \" BORDER_RIGHT_WIDTH = \"border-right-width: %s \" BORDER_SPACING = \"border-spacing: %s \" BORDER_START_END_RADIUS = \"border-start-end-radius: %s \" BORDER_START_START_RADIUS = \"border-start-start-radius: %s \" BORDER_STYLE = \"border-style: %s \" BORDER_TOP = \"border-top: %s \" BORDER_TOP_COLOR = \"border-top-color: %s \" BORDER_TOP_LEFT_RADIUS = \"border-top-left-radius: %s \" BORDER_TOP_RIGHT_RADIUS = \"border-top-right-radius: %s \" BORDER_TOP_STYLE = \"border-top-style: %s \" BORDER_TOP_WIDTH = \"border-top-width: %s \" BORDER_WIDTH = \"border-width: %s \" BOTTOM = \"bottom: %s \" BOX_DECORATION_BREAK = \"box-decoration-break: %s \" BOX_REFLECT = \"box-reflect: %s \" BOX_SHADOW = \"box-shadow: %s \" BOX_SIZING = \"box-sizing: %s \" BREAK_AFTER = \"break-after: %s \" BREAK_BEFORE = \"break-before: %s \" BREAK_INSIDE = \"break-inside: %s \" CAPTION_SIDE = \"caption-side: %s \" CARET_COLOR = \"caret-color: %s \" AT_CHARSET = \"@charset: %s \" CLEAR = \"clear: %s \" CLIP = \"clip: %s \" CLIP_PATH = \"clip-path: %s \" COLOR = \"color: %s \" COLOR_SCHEME = \"color-scheme: %s \" COLUMN_COUNT = \"column-count: %s \" COLUMN_FILL = \"column-fill: %s \" COLUMN_GAP = \"column-gap: %s \" COLUMN_RULE = \"column-rule: %s \" COLUMN_RULE_COLOR = \"column-rule-color: %s \" COLUMN_RULE_STYLE = \"column-rule-style: %s \" COLUMN_RULE_WIDTH = \"column-rule-width: %s \" COLUMN_SPAN = \"column-span: %s \" COLUMN_WIDTH = \"column-width: %s \" COLUMNS = \"columns: %s \" AT_CONTAINER = \"@container: %s \" CONTENT = \"content: %s \" COUNTER_INCREMENT = \"counter-increment: %s \" COUNTER_RESET = \"counter-reset: %s \" COUNTER_SET = \"counter-set: %s \" AT_COUNTER_STYLE = \"@counter-style: %s \" CURSOR = \"cursor: %s \" DIRECTION = \"direction: %s \" DISPLAY = \"display: %s \" EMPTY_CELLS = \"empty-cells: %s \" FILTER = \"filter: %s \" FLEX = \"flex: %s \" FLEX_BASIS = \"flex-basis: %s \" FLEX_DIRECTION = \"flex-direction: %s \" FLEX_FLOW = \"flex-flow: %s \" FLEX_GROW = \"flex-grow: %s \" FLEX_SHRINK = \"flex-shrink: %s \" FLEX_WRAP = \"flex-wrap: %s \" FLOAT = \"float: %s \" FONT = \"font: %s \" AT_FONT_FACE = \"@font-face: %s \" FONT_FAMILY = \"font-family: %s \" FONT_FEATURE_SETTINGS = \"font-feature-settings: %s \" FONT_KERNING = \"font-kerning: %s \" FONT_LANGUAGE_OVERRIDE = \"font-language-override: %s \" AT_FONT_PALETTE_VALUES = \"@font-palette-values: %s \" FONT_SIZE = \"font-size: %s \" FONT_SIZE_ADJUST = \"font-size-adjust: %s \" FONT_STRETCH = \"font-stretch: %s \" FONT_STYLE = \"font-style: %s \" FONT_SYNTHESIS = \"font-synthesis: %s \" FONT_VARIANT = \"font-variant: %s \" FONT_VARIANT_ALTERNATES = \"font-variant-alternates: %s \" FONT_VARIANT_CAPS = \"font-variant-caps: %s \" FONT_VARIANT_EAST_ASIAN = \"font-variant-east-asian: %s \" FONT_VARIANT_LIGATURES = \"font-variant-ligatures: %s \" FONT_VARIANT_NUMERIC = \"font-variant-numeric: %s \" FONT_VARIANT_POSITION = \"font-variant-position: %s \" FONT_WEIGHT = \"font-weight: %s \" GAP = \"gap: %s \" GRID = \"grid: %s \" GRID_AREA = \"grid-area: %s \" GRID_AUTO_COLUMNS = \"grid-auto-columns: %s \" GRID_AUTO_FLOW = \"grid-auto-flow: %s \" GRID_AUTO_ROWS = \"grid-auto-rows: %s \" GRID_COLUMN = \"grid-column: %s \" GRID_COLUMN_END = \"grid-column-end: %s \" GRID_COLUMN_START = \"grid-column-start: %s \" GRID_ROW = \"grid-row: %s \" GRID_ROW_END = \"grid-row-end: %s \" GRID_ROW_START = \"grid-row-start: %s \" GRID_TEMPLATE = \"grid-template: %s \" GRID_TEMPLATE_AREAS = \"grid-template-areas: %s \" GRID_TEMPLATE_COLUMNS = \"grid-template-columns: %s \" GRID_TEMPLATE_ROWS = \"grid-template-rows: %s \" HANGING_PUNCTUATION = \"hanging-punctuation: %s \" HEIGHT = \"height: %s \" HYPHENS = \"hyphens: %s \" HYPHENATE_CHARACTER = \"hyphenate-character: %s \" IMAGE_RENDERING = \"image-rendering: %s \" AT_IMPORT = \"@import: %s \" INITIAL_LETTER = \"initial-letter: %s \" INLINE_SIZE = \"inline-size: %s \" INSET = \"inset: %s \" INSET_BLOCK = \"inset-block: %s \" INSET_BLOCK_END = \"inset-block-end: %s \" INSET_BLOCK_START = \"inset-block-start: %s \" INSET_INLINE = \"inset-inline: %s \" INSET_INLINE_END = \"inset-inline-end: %s \" INSET_INLINE_START = \"inset-inline-start: %s \" ISOLATION = \"isolation: %s \" JUSTIFY_CONTENT = \"justify-content: %s \" JUSTIFY_ITEMS = \"justify-items: %s \" JUSTIFY_SELF = \"justify-self: %s \" AT_KEYFRAMES = \"@keyframes: %s \" AT_LAYER = \"@layer: %s \" LEFT = \"left: %s \" LETTER_SPACING = \"letter-spacing: %s \" LINE_BREAK = \"line-break: %s \" LINE_HEIGHT = \"line-height: %s \" LIST_STYLE = \"list-style: %s \" LIST_STYLE_IMAGE = \"list-style-image: %s \" LIST_STYLE_POSITION = \"list-style-position: %s \" LIST_STYLE_TYPE = \"list-style-type: %s \" MARGIN = \"margin: %s \" MARGIN_BLOCK = \"margin-block: %s \" MARGIN_BLOCK_END = \"margin-block-end: %s \" MARGIN_BLOCK_START = \"margin-block-start: %s \" MARGIN_BOTTOM = \"margin-bottom: %s \" MARGIN_INLINE = \"margin-inline: %s \" MARGIN_INLINE_END = \"margin-inline-end: %s \" MARGIN_INLINE_START = \"margin-inline-start: %s \" MARGIN_LEFT = \"margin-left: %s \" MARGIN_RIGHT = \"margin-right: %s \" MARGIN_TOP = \"margin-top: %s \" MARKER = \"marker: %s \" MARKER_END = \"marker-end: %s \" MARKER_MID = \"marker-mid: %s \" MARKER_START = \"marker-start: %s \" MASK = \"mask: %s \" MASK_CLIP = \"mask-clip: %s \" MASK_COMPOSITE = \"mask-composite: %s \" MASK_IMAGE = \"mask-image: %s \" MASK_MODE = \"mask-mode: %s \" MASK_ORIGIN = \"mask-origin: %s \" MASK_POSITION = \"mask-position: %s \" MASK_REPEAT = \"mask-repeat: %s \" MASK_SIZE = \"mask-size: %s \" MASK_TYPE = \"mask-type: %s \" MAX_HEIGHT = \"max-height: %s \" MAX_WIDTH = \"max-width: %s \" AT_MEDIA = \"@media: %s \" MAX_BLOCK_SIZE = \"max-block-size: %s \" MAX_INLINE_SIZE = \"max-inline-size: %s \" MIN_BLOCK_SIZE = \"min-block-size: %s \" MIN_INLINE_SIZE = \"min-inline-size: %s \" MIN_HEIGHT = \"min-height: %s \" MIN_WIDTH = \"min-width: %s \" MIX_BLEND_MODE = \"mix-blend-mode: %s \" AT_NAMESPACE = \"@namespace: %s \" OBJECT_FIT = \"object-fit: %s \" OBJECT_POSITION = \"object-position: %s \" OFFSET = \"offset: %s \" OFFSET_ANCHOR = \"offset-anchor: %s \" OFFSET_DISTANCE = \"offset-distance: %s \" OFFSET_PATH = \"offset-path: %s \" OFFSET_POSITION = \"offset-position: %s \" OFFSET_ROTATE = \"offset-rotate: %s \" OPACITY = \"opacity: %s \" ORDER = \"order: %s \" ORPHANS = \"orphans: %s \" OUTLINE = \"outline: %s \" OUTLINE_COLOR = \"outline-color: %s \" OUTLINE_OFFSET = \"outline-offset: %s \" OUTLINE_STYLE = \"outline-style: %s \" OUTLINE_WIDTH = \"outline-width: %s \" OVERFLOW = \"overflow: %s \" OVERFLOW_ANCHOR = \"overflow-anchor: %s \" OVERFLOW_WRAP = \"overflow-wrap: %s \" OVERFLOW_X = \"overflow-x: %s \" OVERFLOW_Y = \"overflow-y: %s \" OVERSCROLL_BEHAVIOR = \"overscroll-behavior: %s \" OVERSCROLL_BEHAVIOR_BLOCK = \"overscroll-behavior-block: %s \" OVERSCROLL_BEHAVIOR_INLINE = \"overscroll-behavior-inline: %s \" OVERSCROLL_BEHAVIOR_X = \"overscroll-behavior-x: %s \" OVERSCROLL_BEHAVIOR_Y = \"overscroll-behavior-y: %s \" PADDING = \"padding: %s \" PADDING_BLOCK = \"padding-block: %s \" PADDING_BLOCK_END = \"padding-block-end: %s \" PADDING_BLOCK_START = \"padding-block-start: %s \" PADDING_BOTTOM = \"padding-bottom: %s \" PADDING_INLINE = \"padding-inline: %s \" PADDING_INLINE_END = \"padding-inline-end: %s \" PADDING_INLINE_START = \"padding-inline-start: %s \" PADDING_LEFT = \"padding-left: %s \" PADDING_RIGHT = \"padding-right: %s \" PADDING_TOP = \"padding-top: %s \" AT_PAGE = \"@page: %s \" PAGE_BREAK_AFTER = \"page-break-after: %s \" PAGE_BREAK_BEFORE = \"page-break-before: %s \" PAGE_BREAK_INSIDE = \"page-break-inside: %s \" PAINT_ORDER = \"paint-order: %s \" PERSPECTIVE = \"perspective: %s \" PERSPECTIVE_ORIGIN = \"perspective-origin: %s \" PLACE_CONTENT = \"place-content: %s \" PLACE_ITEMS = \"place-items: %s \" PLACE_SELF = \"place-self: %s \" POINTER_EVENTS = \"pointer-events: %s \" POSITION = \"position: %s \" AT_PROPERTY = \"@property: %s \" QUOTES = \"quotes: %s \" RESIZE = \"resize: %s \" RIGHT = \"right: %s \" ROTATE = \"rotate: %s \" ROW_GAP = \"row-gap: %s \" SCALE = \"scale: %s \" AT_SCOPE = \"@scope: %s \" SCROLL_BEHAVIOR = \"scroll-behavior: %s \" SCROLL_MARGIN = \"scroll-margin: %s \" SCROLL_MARGIN_BLOCK = \"scroll-margin-block: %s \" SCROLL_MARGIN_BLOCK_END = \"scroll-margin-block-end: %s \" SCROLL_MARGIN_BLOCK_START = \"scroll-margin-block-start: %s \" SCROLL_MARGIN_BOTTOM = \"scroll-margin-bottom: %s \" SCROLL_MARGIN_INLINE = \"scroll-margin-inline: %s \" SCROLL_MARGIN_INLINE_END = \"scroll-margin-inline-end: %s \" SCROLL_MARGIN_INLINE_START = \"scroll-margin-inline-start: %s \" SCROLL_MARGIN_LEFT = \"scroll-margin-left: %s \" SCROLL_MARGIN_RIGHT = \"scroll-margin-right: %s \" SCROLL_MARGIN_TOP = \"scroll-margin-top: %s \" SCROLL_PADDING = \"scroll-padding: %s \" SCROLL_PADDING_BLOCK = \"scroll-padding-block: %s \" SCROLL_PADDING_BLOCK_END = \"scroll-padding-block-end: %s \" SCROLL_PADDING_BLOCK_START = \"scroll-padding-block-start: %s \" SCROLL_PADDING_BOTTOM = \"scroll-padding-bottom: %s \" SCROLL_PADDING_INLINE = \"scroll-padding-inline: %s \" SCROLL_PADDING_INLINE_END = \"scroll-padding-inline-end: %s \" SCROLL_PADDING_INLINE_START = \"scroll-padding-inline-start: %s \" SCROLL_PADDING_LEFT = \"scroll-padding-left: %s \" SCROLL_PADDING_RIGHT = \"scroll-padding-right: %s \" SCROLL_PADDING_TOP = \"scroll-padding-top: %s \" SCROLL_SNAP_ALIGN = \"scroll-snap-align: %s \" SCROLL_SNAP_STOP = \"scroll-snap-stop: %s \" SCROLL_SNAP_TYPE = \"scroll-snap-type: %s \" SCROLLBAR_COLOR = \"scrollbar-color: %s \" SHAPE_OUTSIDE = \"shape-outside: %s \" AT_STARTING_STYLE = \"@starting-style: %s \" AT_SUPPORTS = \"@supports: %s \" TAB_SIZE = \"tab-size: %s \" TABLE_LAYOUT = \"table-layout: %s \" TEXT_ALIGN = \"text-align: %s \" TEXT_ALIGN_LAST = \"text-align-last: %s \" TEXT_COMBINE_UPRIGHT = \"text-combine-upright: %s \" TEXT_DECORATION = \"text-decoration: %s \" TEXT_DECORATION_COLOR = \"text-decoration-color: %s \" TEXT_DECORATION_LINE = \"text-decoration-line: %s \" TEXT_DECORATION_STYLE = \"text-decoration-style: %s \" TEXT_DECORATION_THICKNESS = \"text-decoration-thickness: %s \" TEXT_EMPHASIS = \"text-emphasis: %s \" TEXT_EMPHASIS_COLOR = \"text-emphasis-color: %s \" TEXT_EMPHASIS_POSITION = \"text-emphasis-position: %s \" TEXT_EMPHASIS_STYLE = \"text-emphasis-style: %s \" TEXT_INDENT = \"text-indent: %s \" TEXT_JUSTIFY = \"text-justify: %s \" TEXT_ORIENTATION = \"text-orientation: %s \" TEXT_OVERFLOW = \"text-overflow: %s \" TEXT_SHADOW = \"text-shadow: %s \" TEXT_TRANSFORM = \"text-transform: %s \" TEXT_UNDERLINE_OFFSET = \"text-underline-offset: %s \" TEXT_UNDERLINE_POSITION = \"text-underline-position: %s \" TOP = \"top: %s \" TRANSFORM = \"transform: %s \" TRANSFORM_ORIGIN = \"transform-origin: %s \" TRANSFORM_STYLE = \"transform-style: %s \" TRANSITION = \"transition: %s \" TRANSITION_DELAY = \"transition-delay: %s \" TRANSITION_DURATION = \"transition-duration: %s \" TRANSITION_PROPERTY = \"transition-property: %s \" TRANSITION_TIMING_FUNCTION = \"transition-timing-function: %s \" TRANSLATE = \"translate: %s \" UNICODE_BIDI = \"unicode-bidi: %s \" USER_SELECT = \"user-select: %s \" VERTICAL_ALIGN = \"vertical-align: %s \" VISIBILITY = \"visibility: %s \" WHITE_SPACE = \"white-space: %s \" WIDOWS = \"widows: %s \" WIDTH = \"width: %s \" WORD_BREAK = \"word-break: %s \" WORD_SPACING = \"word-spacing: %s \" WORD_WRAP = \"word-wrap: %s \" WRITING_MODE = \"writing-mode: %s \" Z_INDEX = \"z-index: %s \" ZOOM = \"zoom: %s \" __DEFAULT = None def __call__ ( self , value ): \"\"\"Allows syntax like CssPropertyEnum.COLOR('red')\"\"\" return self . value % value @classmethod def get ( cls , name , default = None ): try : return cls [ name . upper ()] except KeyError : return cls . __DEFAULT","title":"CssPropertyEnum"},{"location":"reference/probo/styles/css_enum/#probo.styles.css_enum.CssPropertyEnum.__call__","text":"Allows syntax like CssPropertyEnum.COLOR('red') Source code in src\\probo\\styles\\css_enum.py 377 378 379 def __call__ ( self , value ): \"\"\"Allows syntax like CssPropertyEnum.COLOR('red')\"\"\" return self . value % value","title":"__call__"},{"location":"reference/probo/styles/css_enum/#probo.styles.css_enum.PseudoClassEnum","text":"Bases: Enum Source code in src\\probo\\styles\\css_enum.py 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 class PseudoClassEnum ( Enum ): ACTIVE = \":active\" ANY_LINK = \":any-link\" ANYLINK = \":anylink\" # Non-standard, but sometimes used AUTO_FILL = \":auto-fill\" CHECKED = \":checked\" DEFAULT = \":default\" DEFINED = \":defined\" DIR = \":dir()\" DISABLED = \":disabled\" EMPTY = \":empty\" ENABLED = \":enabled\" FIRST = \":first\" # Paged media FIRST_CHILD = \":first-child\" FIRST_OF_TYPE = \":first-of-type\" FOCUS = \":focus\" FOCUS_VISIBLE = \":focus-visible\" FOCUS_WITHIN = \":focus-within\" FULLSCREEN = \":fullscreen\" HAS = \":has()\" HOVER = \":hover\" IN_RANGE = \":in-range\" INDETERMINATE = \":indeterminate\" INVALID = \":invalid\" IS = \":is()\" LANG = \":lang()\" LAST_CHILD = \":last-child\" LAST_OF_TYPE = \":last-of-type\" LEFT = \":left\" # Paged media LINK = \":link\" MODAL = \":modal\" NOT = \":not()\" NTH_CHILD = \":nth-child()\" NTH_LAST_CHILD = \":nth-last-child()\" NTH_LAST_OF_TYPE = \":nth-last-of-type()\" NTH_OF_TYPE = \":nth-of-type()\" ONLY_CHILD = \":only-child\" ONLY_OF_TYPE = \":only-of-type\" OPTIONAL = \":optional\" OUT_OF_RANGE = \":out-of-range\" PLACEHOLDER_SHOWN = \":placeholder-shown\" POPOVER_OPEN = \":popover-open\" READ_ONLY = \":read-only\" READ_WRITE = \":read-write\" REQUIRED = \":required\" RIGHT = \":right\" # Paged media ROOT = \":root\" SCOPE = \":scope\" STATE = \":state()\" TARGET = \":target\" USER_INVALID = \":user-invalid\" USER_VALID = \":user-valid\" VALID = \":valid\" VISITED = \":visited\" WHERE = \":where()\" # Webkit / Vendor specific (Optional, but useful) WEBKIT_SCROLLBAR = \"::-webkit-scrollbar\" @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup that handles different naming conventions. Examples: - get(':hover') -> HOVER - get('first-child') -> FIRST_CHILD - get('FIRST_CHILD') -> FIRST_CHILD \"\"\" # 1. Remove leading colons # 2. Replace dashes with underscores (CSS -> Python Enum) # 3. Uppercase clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default","title":"PseudoClassEnum"},{"location":"reference/probo/styles/css_enum/#probo.styles.css_enum.PseudoClassEnum.get","text":"Robust lookup that handles different naming conventions. Examples: - get(':hover') -> HOVER - get('first-child') -> FIRST_CHILD - get('FIRST_CHILD') -> FIRST_CHILD Source code in src\\probo\\styles\\css_enum.py 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup that handles different naming conventions. Examples: - get(':hover') -> HOVER - get('first-child') -> FIRST_CHILD - get('FIRST_CHILD') -> FIRST_CHILD \"\"\" # 1. Remove leading colons # 2. Replace dashes with underscores (CSS -> Python Enum) # 3. Uppercase clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default","title":"get"},{"location":"reference/probo/styles/css_enum/#probo.styles.css_enum.PseudoElementEnum","text":"Bases: Enum Source code in src\\probo\\styles\\css_enum.py 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 class PseudoElementEnum ( Enum ): AFTER = \"::after\" BACKDROP = \"::backdrop\" BEFORE = \"::before\" CUE = \"::cue\" FILE_SELECTOR_BUTTON = \"::file-selector-button\" FIRST_LETTER = \"::first-letter\" FIRST_LINE = \"::first-line\" GRAMMAR_ERROR = \"::grammar-error\" # Fixed typo HIGHLIGHT = \"::highlight()\" MARKER = \"::marker\" PART = \"::part()\" PLACEHOLDER = \"::placeholder\" SELECTION = \"::selection\" SLOTTED = \"::slotted()\" SPELLING_ERROR = \"::spelling-error\" TARGET_TEXT = \"::target-text\" VIEW_TRANSITION = \"::view-transition\" VIEW_TRANSITION_GROUP = \"::view-transition-group()\" VIEW_TRANSITION_IMAGE_PAIR = \"::view-transition-image-pair()\" VIEW_TRANSITION_NEW = \"::view-transition-new()\" VIEW_TRANSITION_OLD = \"::view-transition-old()\" @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup for pseudo-elements. Examples: - get('::before') -> BEFORE - get('first-line') -> FIRST_LINE \"\"\" clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default","title":"PseudoElementEnum"},{"location":"reference/probo/styles/css_enum/#probo.styles.css_enum.PseudoElementEnum.get","text":"Robust lookup for pseudo-elements. Examples: - get('::before') -> BEFORE - get('first-line') -> FIRST_LINE Source code in src\\probo\\styles\\css_enum.py 491 492 493 494 495 496 497 498 499 500 501 502 503 @classmethod def get ( cls , name , default = None ): \"\"\" Robust lookup for pseudo-elements. Examples: - get('::before') -> BEFORE - get('first-line') -> FIRST_LINE \"\"\" clean_name = name . lstrip ( \":\" ) . replace ( \"-\" , \"_\" ) . upper () try : return cls [ clean_name ] . value except KeyError : return default","title":"get"},{"location":"reference/probo/styles/elements/","text":"elements ComponentStyle A class to represent the css style of a Component object. args: template: a html representation to validate selectors against *css: the css is tuple of SelectorRuleBridge objects Source code in src\\probo\\styles\\elements.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class ComponentStyle : \"\"\" A class to represent the css style of a Component object. args: template: a html representation to validate selectors against *css: the css is tuple of SelectorRuleBridge objects \"\"\" Css_rule = CssRule Css_animatable = CssAnimatable def __init__ ( self , template : str = \"\" , * css ): self . template = template self . css_rules : tuple [ \"SelectorRuleBridge\" ] = css self . template_representation = str () if template : self . template_info = CssSelector ( self . template ) . template_info def link_component ( self , cmp_str : str ): self . template = cmp_str return self def render ( self , as_string = True , with_style_tag = False ): container = [ self . _validate_css ( bridge ) for bridge in self . css_rules ] if with_style_tag : as_string = True self . template_representation = container if not as_string : return self . template_representation else : from probo.components.tag_functions.block_tags import style return ( \"\" . join ( self . template_representation ) if not with_style_tag else style ( \"\" . join ( self . template_representation )) ) def _validate_css ( self , bridge ): s , r = bridge . selector_str , bridge . rule . render () from probo.utility import exists_in_dict if \"_$_\" in s : if all ( [ exists_in_dict ( self . template_info , ss . strip ( \".\" ) . strip ( \"#\" )) for ss in s . split ( \"_$_\" ) ] ): selectors = \" \" . join ( s . split ( \"_$_\" )) else : raise ValueError ( \"invalid selectors\" ) else : if exists_in_dict ( self . template_info , s ): selectors = s else : raise ValueError ( \"invalid selectors\" ) # css_rules = f\"{' '.join([ c for cr in self.css_rules])}\" return f \" { selectors } { r } \\n \" SelectorRuleBridge dataclass The atomic unit of the Style Engine. Binds a specific Selector to a specific Rule definition and unifizes CssSelectort and CssRule objects Source code in src\\probo\\styles\\elements.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @dataclass class SelectorRuleBridge : \"\"\" The atomic unit of the Style Engine. Binds a specific Selector to a specific Rule definition and unifizes CssSelectort and CssRule objects \"\"\" selector : Union [ CssSelector , str ] rule : CssRule def __post_init__ ( self ): \"\"\" Automatically runs after the object is created. Ensures self.selector is normalized to a CssSelector object. \"\"\" self . make_selector_obj () @property def selector_str ( self ) -> str : \"\"\"Helper to get the raw string for lxml/cssselect.\"\"\" if hasattr ( self . selector , \"render\" ): return self . selector . render () return str ( self . selector ) def make_selector_obj ( self , ) -> None : if isinstance ( self . selector , CssSelector ): return None if isinstance ( self . selector , str ): sel_obj = CssSelector () for x in resolve_complex_selector ( self . selector ): sel_obj . add_selector ( x ) self . selector = sel_obj else : raise TypeError ( \"selector must be str or CssSelector\" , self . selector ) def render ( self ) -> str : \"\"\" Renders the full CSS block for this bridge. Example: .btn { color: red; } \"\"\" # CssRule.render_declarations() is assumed to return just the body \"prop: val;\" # If CssRule.render() includes selectors, we might need to adjust CssRule # or just use the rule's properties here. body = self . rule . render () if body : return f \" { self . selector_str } { body } \" else : return \"\" # No styles to render # f'{k.strip(':')}:{v.strip(';')};\\n'.replace('_','-') @classmethod def make_bridge_list ( cls , source : Dict ) -> List [ \"SelectorRuleBridge\" ]: \"\"\" Factory: Converts a User Dictionary into a Strict List of Bridges. Preserves insertion order (Python 3.7+ dicts are ordered). Input: { CssSelector('.btn'): CssRule(color='red') } Output: [SRB(selector=..., rule=...)] \"\"\" bridges = [] for sel , rule_def in source . items (): # 1. Normalize Rule # If user passed a dict {'color': 'red'}, wrap it in CssRule if isinstance ( rule_def , dict ): final_rule = CssRule ( ** rule_def ) elif isinstance ( rule_def , CssRule ): final_rule = rule_def else : continue # Skip invalid if not isinstance ( sel , CssSelector ): sel_obj = CssSelector () for x in resolve_complex_selector ( sel ): sel_obj . add_selector ( x ) else : continue # 2. Create Bridge bridges . append ( cls ( selector = sel_obj , rule = final_rule )) return bridges selector_str property Helper to get the raw string for lxml/cssselect. __post_init__ () Automatically runs after the object is created. Ensures self.selector is normalized to a CssSelector object. Source code in src\\probo\\styles\\elements.py 99 100 101 102 103 104 def __post_init__ ( self ): \"\"\" Automatically runs after the object is created. Ensures self.selector is normalized to a CssSelector object. \"\"\" self . make_selector_obj () make_bridge_list ( source ) classmethod Factory: Converts a User Dictionary into a Strict List of Bridges. Preserves insertion order (Python 3.7+ dicts are ordered). Input: { CssSelector('.btn'): CssRule(color='red') } Output: [SRB(selector=..., rule=...)] Source code in src\\probo\\styles\\elements.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @classmethod def make_bridge_list ( cls , source : Dict ) -> List [ \"SelectorRuleBridge\" ]: \"\"\" Factory: Converts a User Dictionary into a Strict List of Bridges. Preserves insertion order (Python 3.7+ dicts are ordered). Input: { CssSelector('.btn'): CssRule(color='red') } Output: [SRB(selector=..., rule=...)] \"\"\" bridges = [] for sel , rule_def in source . items (): # 1. Normalize Rule # If user passed a dict {'color': 'red'}, wrap it in CssRule if isinstance ( rule_def , dict ): final_rule = CssRule ( ** rule_def ) elif isinstance ( rule_def , CssRule ): final_rule = rule_def else : continue # Skip invalid if not isinstance ( sel , CssSelector ): sel_obj = CssSelector () for x in resolve_complex_selector ( sel ): sel_obj . add_selector ( x ) else : continue # 2. Create Bridge bridges . append ( cls ( selector = sel_obj , rule = final_rule )) return bridges render () Renders the full CSS block for this bridge. Example: .btn { color: red; } Source code in src\\probo\\styles\\elements.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def render ( self ) -> str : \"\"\" Renders the full CSS block for this bridge. Example: .btn { color: red; } \"\"\" # CssRule.render_declarations() is assumed to return just the body \"prop: val;\" # If CssRule.render() includes selectors, we might need to adjust CssRule # or just use the rule's properties here. body = self . rule . render () if body : return f \" { self . selector_str } { body } \" else : return \"\" # No styles to render element_style ( with_style_attr = False , ** prop_val ) A function to represent inline styles for an HTML element. Source code in src\\probo\\styles\\elements.py 73 74 75 76 77 78 79 80 81 82 83 84 85 def element_style ( with_style_attr = False , ** prop_val , ): \"\"\"A function to represent inline styles for an HTML element.\"\"\" style_string = ( \" \" . join ([ f \" { k } : { v } ;\" for k , v in CssRule ( ** prop_val ) . declarations . items ()]) or \"\" ) if with_style_attr : return f 'style=\" { style_string } \"' else : return style_string element_style_state ( template , rslvd_el , * css ) Validate CSS selectors against the rendered template and element state. Cases Case 2 (Error Thrower): - Selector state is managed (in rslvd_el) - BUT selector does NOT exist in final template \u2192 Skip it. Case 1: - Managed AND present in template \u2192 Keep it Case 3: - Not managed \u2192 Keep it Source code in src\\probo\\styles\\elements.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def element_style_state ( template : str , rslvd_el : Dict [ str , Any ], # Dict[str, ElementState] * css : SelectorRuleBridge , ): \"\"\" Validate CSS selectors against the rendered template and element state. Cases: Case 2 (Error Thrower): - Selector state is managed (in rslvd_el) - BUT selector does NOT exist in final template \u2192 Skip it. Case 1: - Managed AND present in template \u2192 Keep it Case 3: - Not managed \u2192 Keep it \"\"\" # Pair selectors with css blocks # selectors: (\"h1.big\", \"a.btn\") # css: {\"h1_big\": {\"color\":\"red\"}, \"a_btn\": {\"font\":\"12px\"}} valid_css = [] for sel in css : selector : List [ str ] = [ s . strip ( \".\" ) . strip ( \"#\" ) . strip ( \"[\" ) . strip ( \"]\" ) for s in resolve_complex_selector ( sel . selector_str ) if not s . startswith ( \":\" ) ] exists_in_template = _check_selector_in_template_re ( selector , template ) # Check if selector is managed in rslvd_el is_managed = ( any ( [ ( all ([ s in x . attrs for s in selector ]) or all ([ s in x . attrs . values () for s in selector ]) ) if not x . props . display_it else True for x in rslvd_el . values () ] ) if rslvd_el else True ) # --- Case 2: ERROR THROWER --- if is_managed and not exists_in_template : continue # skip it entirely if sel in css : valid_css . append ( sel ) return valid_css","title":"elements"},{"location":"reference/probo/styles/elements/#elements","text":"","title":"elements"},{"location":"reference/probo/styles/elements/#probo.styles.elements.ComponentStyle","text":"A class to represent the css style of a Component object. args: template: a html representation to validate selectors against *css: the css is tuple of SelectorRuleBridge objects Source code in src\\probo\\styles\\elements.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 class ComponentStyle : \"\"\" A class to represent the css style of a Component object. args: template: a html representation to validate selectors against *css: the css is tuple of SelectorRuleBridge objects \"\"\" Css_rule = CssRule Css_animatable = CssAnimatable def __init__ ( self , template : str = \"\" , * css ): self . template = template self . css_rules : tuple [ \"SelectorRuleBridge\" ] = css self . template_representation = str () if template : self . template_info = CssSelector ( self . template ) . template_info def link_component ( self , cmp_str : str ): self . template = cmp_str return self def render ( self , as_string = True , with_style_tag = False ): container = [ self . _validate_css ( bridge ) for bridge in self . css_rules ] if with_style_tag : as_string = True self . template_representation = container if not as_string : return self . template_representation else : from probo.components.tag_functions.block_tags import style return ( \"\" . join ( self . template_representation ) if not with_style_tag else style ( \"\" . join ( self . template_representation )) ) def _validate_css ( self , bridge ): s , r = bridge . selector_str , bridge . rule . render () from probo.utility import exists_in_dict if \"_$_\" in s : if all ( [ exists_in_dict ( self . template_info , ss . strip ( \".\" ) . strip ( \"#\" )) for ss in s . split ( \"_$_\" ) ] ): selectors = \" \" . join ( s . split ( \"_$_\" )) else : raise ValueError ( \"invalid selectors\" ) else : if exists_in_dict ( self . template_info , s ): selectors = s else : raise ValueError ( \"invalid selectors\" ) # css_rules = f\"{' '.join([ c for cr in self.css_rules])}\" return f \" { selectors } { r } \\n \"","title":"ComponentStyle"},{"location":"reference/probo/styles/elements/#probo.styles.elements.SelectorRuleBridge","text":"The atomic unit of the Style Engine. Binds a specific Selector to a specific Rule definition and unifizes CssSelectort and CssRule objects Source code in src\\probo\\styles\\elements.py 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @dataclass class SelectorRuleBridge : \"\"\" The atomic unit of the Style Engine. Binds a specific Selector to a specific Rule definition and unifizes CssSelectort and CssRule objects \"\"\" selector : Union [ CssSelector , str ] rule : CssRule def __post_init__ ( self ): \"\"\" Automatically runs after the object is created. Ensures self.selector is normalized to a CssSelector object. \"\"\" self . make_selector_obj () @property def selector_str ( self ) -> str : \"\"\"Helper to get the raw string for lxml/cssselect.\"\"\" if hasattr ( self . selector , \"render\" ): return self . selector . render () return str ( self . selector ) def make_selector_obj ( self , ) -> None : if isinstance ( self . selector , CssSelector ): return None if isinstance ( self . selector , str ): sel_obj = CssSelector () for x in resolve_complex_selector ( self . selector ): sel_obj . add_selector ( x ) self . selector = sel_obj else : raise TypeError ( \"selector must be str or CssSelector\" , self . selector ) def render ( self ) -> str : \"\"\" Renders the full CSS block for this bridge. Example: .btn { color: red; } \"\"\" # CssRule.render_declarations() is assumed to return just the body \"prop: val;\" # If CssRule.render() includes selectors, we might need to adjust CssRule # or just use the rule's properties here. body = self . rule . render () if body : return f \" { self . selector_str } { body } \" else : return \"\" # No styles to render # f'{k.strip(':')}:{v.strip(';')};\\n'.replace('_','-') @classmethod def make_bridge_list ( cls , source : Dict ) -> List [ \"SelectorRuleBridge\" ]: \"\"\" Factory: Converts a User Dictionary into a Strict List of Bridges. Preserves insertion order (Python 3.7+ dicts are ordered). Input: { CssSelector('.btn'): CssRule(color='red') } Output: [SRB(selector=..., rule=...)] \"\"\" bridges = [] for sel , rule_def in source . items (): # 1. Normalize Rule # If user passed a dict {'color': 'red'}, wrap it in CssRule if isinstance ( rule_def , dict ): final_rule = CssRule ( ** rule_def ) elif isinstance ( rule_def , CssRule ): final_rule = rule_def else : continue # Skip invalid if not isinstance ( sel , CssSelector ): sel_obj = CssSelector () for x in resolve_complex_selector ( sel ): sel_obj . add_selector ( x ) else : continue # 2. Create Bridge bridges . append ( cls ( selector = sel_obj , rule = final_rule )) return bridges","title":"SelectorRuleBridge"},{"location":"reference/probo/styles/elements/#probo.styles.elements.SelectorRuleBridge.selector_str","text":"Helper to get the raw string for lxml/cssselect.","title":"selector_str"},{"location":"reference/probo/styles/elements/#probo.styles.elements.SelectorRuleBridge.__post_init__","text":"Automatically runs after the object is created. Ensures self.selector is normalized to a CssSelector object. Source code in src\\probo\\styles\\elements.py 99 100 101 102 103 104 def __post_init__ ( self ): \"\"\" Automatically runs after the object is created. Ensures self.selector is normalized to a CssSelector object. \"\"\" self . make_selector_obj ()","title":"__post_init__"},{"location":"reference/probo/styles/elements/#probo.styles.elements.SelectorRuleBridge.make_bridge_list","text":"Factory: Converts a User Dictionary into a Strict List of Bridges. Preserves insertion order (Python 3.7+ dicts are ordered). Input: { CssSelector('.btn'): CssRule(color='red') } Output: [SRB(selector=..., rule=...)] Source code in src\\probo\\styles\\elements.py 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 @classmethod def make_bridge_list ( cls , source : Dict ) -> List [ \"SelectorRuleBridge\" ]: \"\"\" Factory: Converts a User Dictionary into a Strict List of Bridges. Preserves insertion order (Python 3.7+ dicts are ordered). Input: { CssSelector('.btn'): CssRule(color='red') } Output: [SRB(selector=..., rule=...)] \"\"\" bridges = [] for sel , rule_def in source . items (): # 1. Normalize Rule # If user passed a dict {'color': 'red'}, wrap it in CssRule if isinstance ( rule_def , dict ): final_rule = CssRule ( ** rule_def ) elif isinstance ( rule_def , CssRule ): final_rule = rule_def else : continue # Skip invalid if not isinstance ( sel , CssSelector ): sel_obj = CssSelector () for x in resolve_complex_selector ( sel ): sel_obj . add_selector ( x ) else : continue # 2. Create Bridge bridges . append ( cls ( selector = sel_obj , rule = final_rule )) return bridges","title":"make_bridge_list"},{"location":"reference/probo/styles/elements/#probo.styles.elements.SelectorRuleBridge.render","text":"Renders the full CSS block for this bridge. Example: .btn { color: red; } Source code in src\\probo\\styles\\elements.py 127 128 129 130 131 132 133 134 135 136 137 138 139 140 def render ( self ) -> str : \"\"\" Renders the full CSS block for this bridge. Example: .btn { color: red; } \"\"\" # CssRule.render_declarations() is assumed to return just the body \"prop: val;\" # If CssRule.render() includes selectors, we might need to adjust CssRule # or just use the rule's properties here. body = self . rule . render () if body : return f \" { self . selector_str } { body } \" else : return \"\" # No styles to render","title":"render"},{"location":"reference/probo/styles/elements/#probo.styles.elements.element_style","text":"A function to represent inline styles for an HTML element. Source code in src\\probo\\styles\\elements.py 73 74 75 76 77 78 79 80 81 82 83 84 85 def element_style ( with_style_attr = False , ** prop_val , ): \"\"\"A function to represent inline styles for an HTML element.\"\"\" style_string = ( \" \" . join ([ f \" { k } : { v } ;\" for k , v in CssRule ( ** prop_val ) . declarations . items ()]) or \"\" ) if with_style_attr : return f 'style=\" { style_string } \"' else : return style_string","title":"element_style"},{"location":"reference/probo/styles/elements/#probo.styles.elements.element_style_state","text":"Validate CSS selectors against the rendered template and element state. Cases Case 2 (Error Thrower): - Selector state is managed (in rslvd_el) - BUT selector does NOT exist in final template \u2192 Skip it. Case 1: - Managed AND present in template \u2192 Keep it Case 3: - Not managed \u2192 Keep it Source code in src\\probo\\styles\\elements.py 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 def element_style_state ( template : str , rslvd_el : Dict [ str , Any ], # Dict[str, ElementState] * css : SelectorRuleBridge , ): \"\"\" Validate CSS selectors against the rendered template and element state. Cases: Case 2 (Error Thrower): - Selector state is managed (in rslvd_el) - BUT selector does NOT exist in final template \u2192 Skip it. Case 1: - Managed AND present in template \u2192 Keep it Case 3: - Not managed \u2192 Keep it \"\"\" # Pair selectors with css blocks # selectors: (\"h1.big\", \"a.btn\") # css: {\"h1_big\": {\"color\":\"red\"}, \"a_btn\": {\"font\":\"12px\"}} valid_css = [] for sel in css : selector : List [ str ] = [ s . strip ( \".\" ) . strip ( \"#\" ) . strip ( \"[\" ) . strip ( \"]\" ) for s in resolve_complex_selector ( sel . selector_str ) if not s . startswith ( \":\" ) ] exists_in_template = _check_selector_in_template_re ( selector , template ) # Check if selector is managed in rslvd_el is_managed = ( any ( [ ( all ([ s in x . attrs for s in selector ]) or all ([ s in x . attrs . values () for s in selector ]) ) if not x . props . display_it else True for x in rslvd_el . values () ] ) if rslvd_el else True ) # --- Case 2: ERROR THROWER --- if is_managed and not exists_in_template : continue # skip it entirely if sel in css : valid_css . append ( sel ) return valid_css","title":"element_style_state"},{"location":"reference/probo/styles/plain_css/","text":"plain_css Animation Source code in src\\probo\\styles\\plain_css.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 class Animation : def __init__ ( self , name , ): self . name = name self . animation_body = str () self . frames = {} # Store frames as dict to allow incremental updates def add_frame ( self , step : str , ** properties ): \"\"\" Adds a keyframe step. step: '0%', '100%', 'from', 'to' properties: CSS properties (e.g., opacity=0, top='10px') \"\"\" # OPTIONAL: Add strict validation here # self.__check_animatable(properties) # Use CssRule logic to clean up properties (snake_case -> kebab-case) # We use a temporary CssRule just to get the clean dict clean_props = CssRule ( ** properties ) self . __check_animatable ( clean_props . declarations ) self . frames [ step ] = clean_props . render () return self def __check_animatable ( self , props : dict ): for prop in props . keys (): if CssAnimatableEnum . get ( prop . lower () . replace ( \"-\" , \"_\" )) is None : raise ValueError ( f \"Property ' { prop } ' is not animatable.\" ) def animate_from_to ( self , from_props : dict , to_props : dict ): \"\"\" @keyframes myAnimation { from {background-color: red;} to {background-color: yellow;} } \"\"\" self . add_frame ( \"from\" , ** from_props ) self . add_frame ( \"to\" , ** to_props ) # self.animation_body= f' from {{ {' '.join([f'{k}:{v};' for k,v in from_block.items()])} }} to {{ {' '.join([f'{k}:{v};' for k,v in to_block.items()])} }} ' return self def animate_percent ( self , blocks : dict [ str , dict ]): \"\"\" @keyframes myAnimation { 0% {background-color: red;} 25% {background-color: yellow;} 50% {background-color: blue;} 100% {background-color: green;} } \"\"\" for percent , props in blocks . items (): self . add_frame ( percent , ** props ) return self def render ( self , ): declaration_name = f \"@keyframes { self . name } \" if self . animation_body : return f \" { declaration_name } {{ { self . animation_body } }} \" frames = \"\" for step , props in self . frames . items (): frames += f \" { step } { props } \" return f \" { declaration_name } {{ { frames } }} \" add_frame ( step , ** properties ) Adds a keyframe step. step: '0%', '100%', 'from', 'to' properties: CSS properties (e.g., opacity=0, top='10px') Source code in src\\probo\\styles\\plain_css.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def add_frame ( self , step : str , ** properties ): \"\"\" Adds a keyframe step. step: '0%', '100%', 'from', 'to' properties: CSS properties (e.g., opacity=0, top='10px') \"\"\" # OPTIONAL: Add strict validation here # self.__check_animatable(properties) # Use CssRule logic to clean up properties (snake_case -> kebab-case) # We use a temporary CssRule just to get the clean dict clean_props = CssRule ( ** properties ) self . __check_animatable ( clean_props . declarations ) self . frames [ step ] = clean_props . render () return self animate_from_to ( from_props , to_props ) @keyframes myAnimation { from {background-color: red;} to {background-color: yellow;} } Source code in src\\probo\\styles\\plain_css.py 431 432 433 434 435 436 437 438 439 440 441 def animate_from_to ( self , from_props : dict , to_props : dict ): \"\"\" @keyframes myAnimation { from {background-color: red;} to {background-color: yellow;} } \"\"\" self . add_frame ( \"from\" , ** from_props ) self . add_frame ( \"to\" , ** to_props ) # self.animation_body= f' from {{ {' '.join([f'{k}:{v};' for k,v in from_block.items()])} }} to {{ {' '.join([f'{k}:{v};' for k,v in to_block.items()])} }} ' return self animate_percent ( blocks ) @keyframes myAnimation { 0% {background-color: red;} 25% {background-color: yellow;} 50% {background-color: blue;} 100% {background-color: green;} } Source code in src\\probo\\styles\\plain_css.py 443 444 445 446 447 448 449 450 451 452 453 454 def animate_percent ( self , blocks : dict [ str , dict ]): \"\"\" @keyframes myAnimation { 0% {background-color: red;} 25% {background-color: yellow;} 50% {background-color: blue;} 100% {background-color: green;} } \"\"\" for percent , props in blocks . items (): self . add_frame ( percent , ** props ) return self CssRule Source code in src\\probo\\styles\\plain_css.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class CssRule : validator = CssRuleValidator () def __init__ ( self , ** declarations ): self . declarations : dict = self . __check_declarations ( ** declarations ) def set_rule ( self , ** prop_val ): valid_decs = self . __check_declarations ( ** prop_val ) self . declarations . update ( valid_decs ) return self def __check_declarations ( self , ** decs ): valid_decs = {} for prop , value in decs . items (): normalized_key = ( prop . strip ( \" \" , ) . strip ( \":\" ) . strip ( \"_\" ) . replace ( \"-\" , \"_\" ) . replace ( \"@\" , \"at_\" ) ) enum_value = CssPropertyEnum . get ( normalized_key ) css_declaration = ( enum_value ( value ) if enum_value and \" %s \" in enum_value . value else f \" { prop . replace ( '_' , '-' ) . strip ( ':' ) } : { value } ;\" ) prop_name = css_declaration . split ( \":\" )[ 0 ] if self . validator . validate_css ( css_declaration ) and enum_value : valid_decs [ prop_name ] = value else : valid_decs [ f \"/* { prop_name } \" ] = f \" { value } ; CSS ERROR */\" return valid_decs def css_var ( self , ** dec ): self . declarations . update ( { f \"-- { k . strip ( '-' ) . strip ( '_' ) . replace ( '_' , '-' ) } \" : v for k , v in dec . items () } ) return self def apply_css_function ( self , prop , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFunctionsEnum , name , * args ) if string : self . declarations [ prop ] = string return self def apply_css_fonts ( self , prop , name : str , * args ): \"\"\"Apply a CSS font function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFontsEnum , name , * args ) if string : self . declarations [ prop ] = string return self def __apply_css_enums ( self , __enum_cls , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" try : func_enum = __enum_cls . get ( name . upper ()) if func_enum and \" %s \" in func_enum . value : string = func_enum . value % \", \" . join ( map ( str , args )) else : string = func_enum . value return string except Exception as e : print ( \"e\" , e ) return False def render ( self , ): if self . declarations : return ( f \" {{ { '' . join ([ f ' { p } : { v } ; ' for p , v in self . declarations . items ()]) } }} \" ) else : return str () __apply_css_enums ( __enum_cls , name , * args ) Apply a CSS function to the given arguments. Source code in src\\probo\\styles\\plain_css.py 129 130 131 132 133 134 135 136 137 138 139 140 def __apply_css_enums ( self , __enum_cls , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" try : func_enum = __enum_cls . get ( name . upper ()) if func_enum and \" %s \" in func_enum . value : string = func_enum . value % \", \" . join ( map ( str , args )) else : string = func_enum . value return string except Exception as e : print ( \"e\" , e ) return False apply_css_fonts ( prop , name , * args ) Apply a CSS font function to the given arguments. Source code in src\\probo\\styles\\plain_css.py 122 123 124 125 126 127 def apply_css_fonts ( self , prop , name : str , * args ): \"\"\"Apply a CSS font function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFontsEnum , name , * args ) if string : self . declarations [ prop ] = string return self apply_css_function ( prop , name , * args ) Apply a CSS function to the given arguments. Source code in src\\probo\\styles\\plain_css.py 115 116 117 118 119 120 def apply_css_function ( self , prop , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFunctionsEnum , name , * args ) if string : self . declarations [ prop ] = string return self css_style ( selectors_rules = None , ** declarations ) Create a CSS style string from selectors and declarations. Source code in src\\probo\\styles\\plain_css.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 def css_style ( selectors_rules : dict [ CssSelector , CssRule ] = None , ** declarations ): \"\"\"Create a CSS style string from selectors and declarations.\"\"\" if selectors_rules is not None and not all ( [ isinstance ( sel , CssSelector ) for sel in selectors_rules ] ): raise TypeError ( \"selectors must be an instance of CssSelector\" ) if selectors_rules is not None and not all ( [ isinstance ( sel , CssRule ) for sel in selectors_rules . values ()] ): raise ValueError ( \"No valid CSS declarations provided\" ) if selectors_rules : css_string = \"\" . join ( [ f \" { s . render () } {{ { r . render () } }} \" for s , r in selectors_rules . items ()] ) else : css_string = \"\" . join ( [ f \" { s } {{ { CssRule ( ** { k : v . strip ( ';' ) for k , v in [ item . split ( ':' ) for item in r . split ( ';' ) if item ]}) . render () } }} \" for s , r in declarations . items () ] ) return css_string","title":"plain_css"},{"location":"reference/probo/styles/plain_css/#plain_css","text":"","title":"plain_css"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.Animation","text":"Source code in src\\probo\\styles\\plain_css.py 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 class Animation : def __init__ ( self , name , ): self . name = name self . animation_body = str () self . frames = {} # Store frames as dict to allow incremental updates def add_frame ( self , step : str , ** properties ): \"\"\" Adds a keyframe step. step: '0%', '100%', 'from', 'to' properties: CSS properties (e.g., opacity=0, top='10px') \"\"\" # OPTIONAL: Add strict validation here # self.__check_animatable(properties) # Use CssRule logic to clean up properties (snake_case -> kebab-case) # We use a temporary CssRule just to get the clean dict clean_props = CssRule ( ** properties ) self . __check_animatable ( clean_props . declarations ) self . frames [ step ] = clean_props . render () return self def __check_animatable ( self , props : dict ): for prop in props . keys (): if CssAnimatableEnum . get ( prop . lower () . replace ( \"-\" , \"_\" )) is None : raise ValueError ( f \"Property ' { prop } ' is not animatable.\" ) def animate_from_to ( self , from_props : dict , to_props : dict ): \"\"\" @keyframes myAnimation { from {background-color: red;} to {background-color: yellow;} } \"\"\" self . add_frame ( \"from\" , ** from_props ) self . add_frame ( \"to\" , ** to_props ) # self.animation_body= f' from {{ {' '.join([f'{k}:{v};' for k,v in from_block.items()])} }} to {{ {' '.join([f'{k}:{v};' for k,v in to_block.items()])} }} ' return self def animate_percent ( self , blocks : dict [ str , dict ]): \"\"\" @keyframes myAnimation { 0% {background-color: red;} 25% {background-color: yellow;} 50% {background-color: blue;} 100% {background-color: green;} } \"\"\" for percent , props in blocks . items (): self . add_frame ( percent , ** props ) return self def render ( self , ): declaration_name = f \"@keyframes { self . name } \" if self . animation_body : return f \" { declaration_name } {{ { self . animation_body } }} \" frames = \"\" for step , props in self . frames . items (): frames += f \" { step } { props } \" return f \" { declaration_name } {{ { frames } }} \"","title":"Animation"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.Animation.add_frame","text":"Adds a keyframe step. step: '0%', '100%', 'from', 'to' properties: CSS properties (e.g., opacity=0, top='10px') Source code in src\\probo\\styles\\plain_css.py 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 def add_frame ( self , step : str , ** properties ): \"\"\" Adds a keyframe step. step: '0%', '100%', 'from', 'to' properties: CSS properties (e.g., opacity=0, top='10px') \"\"\" # OPTIONAL: Add strict validation here # self.__check_animatable(properties) # Use CssRule logic to clean up properties (snake_case -> kebab-case) # We use a temporary CssRule just to get the clean dict clean_props = CssRule ( ** properties ) self . __check_animatable ( clean_props . declarations ) self . frames [ step ] = clean_props . render () return self","title":"add_frame"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.Animation.animate_from_to","text":"@keyframes myAnimation { from {background-color: red;} to {background-color: yellow;} } Source code in src\\probo\\styles\\plain_css.py 431 432 433 434 435 436 437 438 439 440 441 def animate_from_to ( self , from_props : dict , to_props : dict ): \"\"\" @keyframes myAnimation { from {background-color: red;} to {background-color: yellow;} } \"\"\" self . add_frame ( \"from\" , ** from_props ) self . add_frame ( \"to\" , ** to_props ) # self.animation_body= f' from {{ {' '.join([f'{k}:{v};' for k,v in from_block.items()])} }} to {{ {' '.join([f'{k}:{v};' for k,v in to_block.items()])} }} ' return self","title":"animate_from_to"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.Animation.animate_percent","text":"@keyframes myAnimation { 0% {background-color: red;} 25% {background-color: yellow;} 50% {background-color: blue;} 100% {background-color: green;} } Source code in src\\probo\\styles\\plain_css.py 443 444 445 446 447 448 449 450 451 452 453 454 def animate_percent ( self , blocks : dict [ str , dict ]): \"\"\" @keyframes myAnimation { 0% {background-color: red;} 25% {background-color: yellow;} 50% {background-color: blue;} 100% {background-color: green;} } \"\"\" for percent , props in blocks . items (): self . add_frame ( percent , ** props ) return self","title":"animate_percent"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.CssRule","text":"Source code in src\\probo\\styles\\plain_css.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 class CssRule : validator = CssRuleValidator () def __init__ ( self , ** declarations ): self . declarations : dict = self . __check_declarations ( ** declarations ) def set_rule ( self , ** prop_val ): valid_decs = self . __check_declarations ( ** prop_val ) self . declarations . update ( valid_decs ) return self def __check_declarations ( self , ** decs ): valid_decs = {} for prop , value in decs . items (): normalized_key = ( prop . strip ( \" \" , ) . strip ( \":\" ) . strip ( \"_\" ) . replace ( \"-\" , \"_\" ) . replace ( \"@\" , \"at_\" ) ) enum_value = CssPropertyEnum . get ( normalized_key ) css_declaration = ( enum_value ( value ) if enum_value and \" %s \" in enum_value . value else f \" { prop . replace ( '_' , '-' ) . strip ( ':' ) } : { value } ;\" ) prop_name = css_declaration . split ( \":\" )[ 0 ] if self . validator . validate_css ( css_declaration ) and enum_value : valid_decs [ prop_name ] = value else : valid_decs [ f \"/* { prop_name } \" ] = f \" { value } ; CSS ERROR */\" return valid_decs def css_var ( self , ** dec ): self . declarations . update ( { f \"-- { k . strip ( '-' ) . strip ( '_' ) . replace ( '_' , '-' ) } \" : v for k , v in dec . items () } ) return self def apply_css_function ( self , prop , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFunctionsEnum , name , * args ) if string : self . declarations [ prop ] = string return self def apply_css_fonts ( self , prop , name : str , * args ): \"\"\"Apply a CSS font function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFontsEnum , name , * args ) if string : self . declarations [ prop ] = string return self def __apply_css_enums ( self , __enum_cls , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" try : func_enum = __enum_cls . get ( name . upper ()) if func_enum and \" %s \" in func_enum . value : string = func_enum . value % \", \" . join ( map ( str , args )) else : string = func_enum . value return string except Exception as e : print ( \"e\" , e ) return False def render ( self , ): if self . declarations : return ( f \" {{ { '' . join ([ f ' { p } : { v } ; ' for p , v in self . declarations . items ()]) } }} \" ) else : return str ()","title":"CssRule"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.CssRule.__apply_css_enums","text":"Apply a CSS function to the given arguments. Source code in src\\probo\\styles\\plain_css.py 129 130 131 132 133 134 135 136 137 138 139 140 def __apply_css_enums ( self , __enum_cls , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" try : func_enum = __enum_cls . get ( name . upper ()) if func_enum and \" %s \" in func_enum . value : string = func_enum . value % \", \" . join ( map ( str , args )) else : string = func_enum . value return string except Exception as e : print ( \"e\" , e ) return False","title":"__apply_css_enums"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.CssRule.apply_css_fonts","text":"Apply a CSS font function to the given arguments. Source code in src\\probo\\styles\\plain_css.py 122 123 124 125 126 127 def apply_css_fonts ( self , prop , name : str , * args ): \"\"\"Apply a CSS font function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFontsEnum , name , * args ) if string : self . declarations [ prop ] = string return self","title":"apply_css_fonts"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.CssRule.apply_css_function","text":"Apply a CSS function to the given arguments. Source code in src\\probo\\styles\\plain_css.py 115 116 117 118 119 120 def apply_css_function ( self , prop , name : str , * args ): \"\"\"Apply a CSS function to the given arguments.\"\"\" string = self . __apply_css_enums ( CssFunctionsEnum , name , * args ) if string : self . declarations [ prop ] = string return self","title":"apply_css_function"},{"location":"reference/probo/styles/plain_css/#probo.styles.plain_css.css_style","text":"Create a CSS style string from selectors and declarations. Source code in src\\probo\\styles\\plain_css.py 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 def css_style ( selectors_rules : dict [ CssSelector , CssRule ] = None , ** declarations ): \"\"\"Create a CSS style string from selectors and declarations.\"\"\" if selectors_rules is not None and not all ( [ isinstance ( sel , CssSelector ) for sel in selectors_rules ] ): raise TypeError ( \"selectors must be an instance of CssSelector\" ) if selectors_rules is not None and not all ( [ isinstance ( sel , CssRule ) for sel in selectors_rules . values ()] ): raise ValueError ( \"No valid CSS declarations provided\" ) if selectors_rules : css_string = \"\" . join ( [ f \" { s . render () } {{ { r . render () } }} \" for s , r in selectors_rules . items ()] ) else : css_string = \"\" . join ( [ f \" { s } {{ { CssRule ( ** { k : v . strip ( ';' ) for k , v in [ item . split ( ':' ) for item in r . split ( ';' ) if item ]}) . render () } }} \" for s , r in declarations . items () ] ) return css_string","title":"css_style"},{"location":"reference/probo/styles/utils/","text":"utils resolve_complex_selector ( selector_str ) Deconstructs a complex CSS selector into its atomic checkable parts. Examples: \"div.container\" -> ['div', '.container'] \"#main > span[data-id]\" -> ['#main', 'span', '[data-id]'] \"input.btn:hover\" -> ['input', '.btn', ':hover'] Useful for JIT validation: checking if these atomic parts exist in the template before committing to compiling the full rule. Source code in src\\probo\\styles\\utils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def resolve_complex_selector ( selector_str : str ) -> List [ str ]: \"\"\" Deconstructs a complex CSS selector into its atomic checkable parts. Examples: \"div.container\" -> ['div', '.container'] \"#main > span[data-id]\" -> ['#main', 'span', '[data-id]'] \"input.btn:hover\" -> ['input', '.btn', ':hover'] Useful for JIT validation: checking if these atomic parts exist in the template before committing to compiling the full rule. \"\"\" # 1. Clean Combinators # Replace >, +, ~ with spaces to treat them as separate compound selectors # We keep the space as a delimiter clean_sel = re . sub ( r \"\\s*[>+~]\\s*\" , \" \" , selector_str ) # 2. Identify Atomic Parts using Regex # Group 1: Attributes [type=\"text\"] (Greedy match inside brackets) # Group 2: IDs #header # Group 3: Classes .btn # Group 4: Pseudo-classes/elements :hover, ::before, :not(.x) # Group 5: Tags div, h1 (Must start with letter) token_pattern = re . compile ( r \"(\\[[^\\]]+\\])|\" # [Attribute] r \"(#[a-zA-Z0-9_-]+)|\" # #ID r \"(\\.[a-zA-Z0-9_-]+)|\" # .Class r \"(::?[a-zA-Z0-9_-]+(?:\\(.*?\\))?)|\" # :Pseudo / ::Pseudo r \"([a-zA-Z][a-zA-Z0-9_-]*)\" # Tag ) parts = [] # Scan the string matches = token_pattern . findall ( clean_sel ) for groups in matches : # 'groups' is a tuple like ('', '#main', '', '', '') # We want the one non-empty string from the group token = next (( g for g in groups if g ), None ) if token : parts . append ( token ) return parts selector_type_identifier ( token ) Identifies the type of a single CSS selector token. Returns tuple: (clean_value, type_code) Type Codes: - EL : Element/Tag (div) - CLS : Class (.btn) - ID : ID (#header) - ATR : Attribute ([type=\"text\"]) - PSD-C : Pseudo-Class (:hover) - PSD-E : Pseudo-Element (::before) - CHLD : Child Combinator (>) - SIB : Sibling Combinator (~ or +) Source code in src\\probo\\styles\\utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def selector_type_identifier ( token : str ) -> tuple [ str , str ]: \"\"\" Identifies the type of a single CSS selector token. Returns tuple: (clean_value, type_code) Type Codes: - EL : Element/Tag (div) - CLS : Class (.btn) - ID : ID (#header) - ATR : Attribute ([type=\"text\"]) - PSD-C : Pseudo-Class (:hover) - PSD-E : Pseudo-Element (::before) - CHLD : Child Combinator (>) - SIB : Sibling Combinator (~ or +) \"\"\" token = token . strip () if not token : return \"\" , \"UNKNOWN\" # 1. Pseudo-Element (::) # Must check before Pseudo-Class because it starts with : too if token . startswith ( \"::\" ): return token [ 2 :], \"PSEUDO_ELEMENT\" # 2. Pseudo-Class (:) elif token . startswith ( \":\" ): return token [ 1 :], \"PSEUDO_CLASS\" # 3. ID (#) elif token . startswith ( \"#\" ): return token [ 1 :], \"ID\" # 4. Class (.) elif token . startswith ( \".\" ): return token [ 1 :], \"CLS\" # 5. Attribute ([...]) elif token . startswith ( \"[\" ) and token . endswith ( \"]\" ): # Return content inside brackets return token [ 1 : - 1 ], \"ATR\" # 6. Combinators elif token . startswith ( \">\" ): return token , \"COMBINATOR >\" elif token . startswith ( \"~\" ): return token , \"COMBINATOR ~\" elif token . startswith ( \"+\" ): return token , \"COMBINATOR +\" elif token . startswith ( \",\" ): return token , \"COMBINATOR ,\" elif token . startswith ( \" \" ): return token , \"COMBINATOR \" # 7. Element / Tag (Default) # Basic validation to ensure it looks like a tag else : return token , \"EL\"","title":"utils"},{"location":"reference/probo/styles/utils/#utils","text":"","title":"utils"},{"location":"reference/probo/styles/utils/#probo.styles.utils.resolve_complex_selector","text":"Deconstructs a complex CSS selector into its atomic checkable parts. Examples: \"div.container\" -> ['div', '.container'] \"#main > span[data-id]\" -> ['#main', 'span', '[data-id]'] \"input.btn:hover\" -> ['input', '.btn', ':hover'] Useful for JIT validation: checking if these atomic parts exist in the template before committing to compiling the full rule. Source code in src\\probo\\styles\\utils.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def resolve_complex_selector ( selector_str : str ) -> List [ str ]: \"\"\" Deconstructs a complex CSS selector into its atomic checkable parts. Examples: \"div.container\" -> ['div', '.container'] \"#main > span[data-id]\" -> ['#main', 'span', '[data-id]'] \"input.btn:hover\" -> ['input', '.btn', ':hover'] Useful for JIT validation: checking if these atomic parts exist in the template before committing to compiling the full rule. \"\"\" # 1. Clean Combinators # Replace >, +, ~ with spaces to treat them as separate compound selectors # We keep the space as a delimiter clean_sel = re . sub ( r \"\\s*[>+~]\\s*\" , \" \" , selector_str ) # 2. Identify Atomic Parts using Regex # Group 1: Attributes [type=\"text\"] (Greedy match inside brackets) # Group 2: IDs #header # Group 3: Classes .btn # Group 4: Pseudo-classes/elements :hover, ::before, :not(.x) # Group 5: Tags div, h1 (Must start with letter) token_pattern = re . compile ( r \"(\\[[^\\]]+\\])|\" # [Attribute] r \"(#[a-zA-Z0-9_-]+)|\" # #ID r \"(\\.[a-zA-Z0-9_-]+)|\" # .Class r \"(::?[a-zA-Z0-9_-]+(?:\\(.*?\\))?)|\" # :Pseudo / ::Pseudo r \"([a-zA-Z][a-zA-Z0-9_-]*)\" # Tag ) parts = [] # Scan the string matches = token_pattern . findall ( clean_sel ) for groups in matches : # 'groups' is a tuple like ('', '#main', '', '', '') # We want the one non-empty string from the group token = next (( g for g in groups if g ), None ) if token : parts . append ( token ) return parts","title":"resolve_complex_selector"},{"location":"reference/probo/styles/utils/#probo.styles.utils.selector_type_identifier","text":"Identifies the type of a single CSS selector token. Returns tuple: (clean_value, type_code) Type Codes: - EL : Element/Tag (div) - CLS : Class (.btn) - ID : ID (#header) - ATR : Attribute ([type=\"text\"]) - PSD-C : Pseudo-Class (:hover) - PSD-E : Pseudo-Element (::before) - CHLD : Child Combinator (>) - SIB : Sibling Combinator (~ or +) Source code in src\\probo\\styles\\utils.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 def selector_type_identifier ( token : str ) -> tuple [ str , str ]: \"\"\" Identifies the type of a single CSS selector token. Returns tuple: (clean_value, type_code) Type Codes: - EL : Element/Tag (div) - CLS : Class (.btn) - ID : ID (#header) - ATR : Attribute ([type=\"text\"]) - PSD-C : Pseudo-Class (:hover) - PSD-E : Pseudo-Element (::before) - CHLD : Child Combinator (>) - SIB : Sibling Combinator (~ or +) \"\"\" token = token . strip () if not token : return \"\" , \"UNKNOWN\" # 1. Pseudo-Element (::) # Must check before Pseudo-Class because it starts with : too if token . startswith ( \"::\" ): return token [ 2 :], \"PSEUDO_ELEMENT\" # 2. Pseudo-Class (:) elif token . startswith ( \":\" ): return token [ 1 :], \"PSEUDO_CLASS\" # 3. ID (#) elif token . startswith ( \"#\" ): return token [ 1 :], \"ID\" # 4. Class (.) elif token . startswith ( \".\" ): return token [ 1 :], \"CLS\" # 5. Attribute ([...]) elif token . startswith ( \"[\" ) and token . endswith ( \"]\" ): # Return content inside brackets return token [ 1 : - 1 ], \"ATR\" # 6. Combinators elif token . startswith ( \">\" ): return token , \"COMBINATOR >\" elif token . startswith ( \"~\" ): return token , \"COMBINATOR ~\" elif token . startswith ( \"+\" ): return token , \"COMBINATOR +\" elif token . startswith ( \",\" ): return token , \"COMBINATOR ,\" elif token . startswith ( \" \" ): return token , \"COMBINATOR \" # 7. Element / Tag (Default) # Basic validation to ensure it looks like a tag else : return token , \"EL\"","title":"selector_type_identifier"},{"location":"reference/probo/styles/frameworks/bs5/bs5/","text":"bs5 BS5 Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class BS5 : def __init__ ( self , ** styles : BS5ElementStyle ): self . elements = {} self . registry = styles def render ( self , target_elemnt = None , ) -> str : if target_elemnt is not None and target_elemnt in self . elements : return self . elements [ target_elemnt ] else : return \" \" . join ([ v . render () for k , v in self . registry . items ()]) def __str__ ( self ): return self . render () def add_new ( self , element = None , class_obj = None ): if element is not None and class_obj is not None : self . elements [ element ] = class_obj . render () self . registry [ element ] = class_obj return self def get_cls_string ( self , key : str ) -> str : \"\"\"Returns just the class string (Old behavior).\"\"\" # Convert selector-like key 'btn#x2' -> internal key 'btn__x2' if needed # For now assuming direct mapping based on your snippet clean_key = key . replace ( \"#\" , \"__\" ) . replace ( \".\" , \"_\" ) if clean_key in self . registry : return \" \" . join ( self . registry [ clean_key ] . classes ) return \"\" def _normalize_key ( self , key : str ) -> str : \"\"\" Converts a selector-style key to a python-valid kwarg key. Mappings: - '#' (ID) -> '__' (Double Underscore) - '.' (Class) -> '_' (Single Underscore) - '-' (Kebab) -> '_' (Single Underscore) Example: 'h5.card-title' -> 'h5_card_title' Example: 'btn#submit-btn' -> 'btn__submit_btn' \"\"\" return key . replace ( \"#\" , \"__\" ) . replace ( \".\" , \"_\" ) . replace ( \"-\" , \"_\" ) def get_element ( self , key : str , content : str = \"\" , ** attrs ) -> BS5Element : \"\"\" Returns a BS5Element configured with the stored styles. Usage: bs5.get_element('btn#x2', 'Click Me') \"\"\" clean_key = self . _normalize_key ( key ) if clean_key in self . registry : style_obj = self . registry [ clean_key ] # Create the element using the stored Tag and Classes return BS5Element ( tag = style_obj . tag , content = content , classes = style_obj . classes . copy (), # Copy to prevent mutation of the registry ** attrs , ) # Fallback if key not found (or raise error) raise ValueError ( f \"BS5 Style ' { key } ' not found in registry.\" ) get_cls_string ( key ) Returns just the class string (Old behavior). Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 167 168 169 170 171 172 173 174 def get_cls_string ( self , key : str ) -> str : \"\"\"Returns just the class string (Old behavior).\"\"\" # Convert selector-like key 'btn#x2' -> internal key 'btn__x2' if needed # For now assuming direct mapping based on your snippet clean_key = key . replace ( \"#\" , \"__\" ) . replace ( \".\" , \"_\" ) if clean_key in self . registry : return \" \" . join ( self . registry [ clean_key ] . classes ) return \"\" get_element ( key , content = '' , ** attrs ) Returns a BS5Element configured with the stored styles. Usage: bs5.get_element('btn#x2', 'Click Me') Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def get_element ( self , key : str , content : str = \"\" , ** attrs ) -> BS5Element : \"\"\" Returns a BS5Element configured with the stored styles. Usage: bs5.get_element('btn#x2', 'Click Me') \"\"\" clean_key = self . _normalize_key ( key ) if clean_key in self . registry : style_obj = self . registry [ clean_key ] # Create the element using the stored Tag and Classes return BS5Element ( tag = style_obj . tag , content = content , classes = style_obj . classes . copy (), # Copy to prevent mutation of the registry ** attrs , ) # Fallback if key not found (or raise error) raise ValueError ( f \"BS5 Style ' { key } ' not found in registry.\" ) BS5Element A dedicated builder for Bootstrap 5 elements. Manages the 'class' attribute specifically while delegating rendering to Element. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class BS5Element : \"\"\" A dedicated builder for Bootstrap 5 elements. Manages the 'class' attribute specifically while delegating rendering to Element. \"\"\" def __init__ ( self , tag : str , content : str = \"\" , classes : Optional [ list ] = None , ** attrs ): self . tag = tag self . content = content . render () if hasattr ( content , \"render\" ) else content # Ensure classes is a list, avoiding shared mutable defaults self . classes = ( [ c for c in classes if c is not None ] if classes is not None else [] ) self . attrs = attrs self . attr_manager = ElementAttributeManipulator ( self . attrs ) def add ( self , * new_classes : str ): \"\"\"Fluent API to add Bootstrap classes.\"\"\" self . classes . extend ( new_classes ) return self def include ( self , * content , first = False , override = False ): \"\"\" Adds content to the element. If content is another BS5Element, it renders it. \"\"\" rendered_content = [] for item in content : if hasattr ( item , \"render\" ): rendered_content . append ( item . render ()) else : rendered_content . append ( str ( item )) # Append to existing content if override : self . content = \"\" . join ( rendered_content ) elif first and not override : self . content = \"\" . join ( rendered_content ) + self . content else : self . content += \"\" . join ( rendered_content ) return self def render ( self ) -> str : \"\"\" Constructs the final Element with the combined class string. \"\"\" # Join classes with spaces final_class_str = \" \" . join ( self . classes ) # Merge with any class passed in attrs (avoiding overwrites) if \"Class\" in self . attrs : # Handling your alias final_class_str += f \" { self . attrs . pop ( 'Class' ) } \" if final_class_str : self . attrs [ \"Class\" ] = final_class_str . strip () # Delegate to the Core Engine from probo.components.elements import Element return Element ( tag = self . tag , content = str ( self . content ), ** self . attrs ) . element add ( * new_classes ) Fluent API to add Bootstrap classes. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 100 101 102 103 def add ( self , * new_classes : str ): \"\"\"Fluent API to add Bootstrap classes.\"\"\" self . classes . extend ( new_classes ) return self include ( * content , first = False , override = False ) Adds content to the element. If content is another BS5Element, it renders it. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def include ( self , * content , first = False , override = False ): \"\"\" Adds content to the element. If content is another BS5Element, it renders it. \"\"\" rendered_content = [] for item in content : if hasattr ( item , \"render\" ): rendered_content . append ( item . render ()) else : rendered_content . append ( str ( item )) # Append to existing content if override : self . content = \"\" . join ( rendered_content ) elif first and not override : self . content = \"\" . join ( rendered_content ) + self . content else : self . content += \"\" . join ( rendered_content ) return self render () Constructs the final Element with the combined class string. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def render ( self ) -> str : \"\"\" Constructs the final Element with the combined class string. \"\"\" # Join classes with spaces final_class_str = \" \" . join ( self . classes ) # Merge with any class passed in attrs (avoiding overwrites) if \"Class\" in self . attrs : # Handling your alias final_class_str += f \" { self . attrs . pop ( 'Class' ) } \" if final_class_str : self . attrs [ \"Class\" ] = final_class_str . strip () # Delegate to the Core Engine from probo.components.elements import Element return Element ( tag = self . tag , content = str ( self . content ), ** self . attrs ) . element","title":"bs5"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#bs5","text":"","title":"bs5"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5","text":"Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 class BS5 : def __init__ ( self , ** styles : BS5ElementStyle ): self . elements = {} self . registry = styles def render ( self , target_elemnt = None , ) -> str : if target_elemnt is not None and target_elemnt in self . elements : return self . elements [ target_elemnt ] else : return \" \" . join ([ v . render () for k , v in self . registry . items ()]) def __str__ ( self ): return self . render () def add_new ( self , element = None , class_obj = None ): if element is not None and class_obj is not None : self . elements [ element ] = class_obj . render () self . registry [ element ] = class_obj return self def get_cls_string ( self , key : str ) -> str : \"\"\"Returns just the class string (Old behavior).\"\"\" # Convert selector-like key 'btn#x2' -> internal key 'btn__x2' if needed # For now assuming direct mapping based on your snippet clean_key = key . replace ( \"#\" , \"__\" ) . replace ( \".\" , \"_\" ) if clean_key in self . registry : return \" \" . join ( self . registry [ clean_key ] . classes ) return \"\" def _normalize_key ( self , key : str ) -> str : \"\"\" Converts a selector-style key to a python-valid kwarg key. Mappings: - '#' (ID) -> '__' (Double Underscore) - '.' (Class) -> '_' (Single Underscore) - '-' (Kebab) -> '_' (Single Underscore) Example: 'h5.card-title' -> 'h5_card_title' Example: 'btn#submit-btn' -> 'btn__submit_btn' \"\"\" return key . replace ( \"#\" , \"__\" ) . replace ( \".\" , \"_\" ) . replace ( \"-\" , \"_\" ) def get_element ( self , key : str , content : str = \"\" , ** attrs ) -> BS5Element : \"\"\" Returns a BS5Element configured with the stored styles. Usage: bs5.get_element('btn#x2', 'Click Me') \"\"\" clean_key = self . _normalize_key ( key ) if clean_key in self . registry : style_obj = self . registry [ clean_key ] # Create the element using the stored Tag and Classes return BS5Element ( tag = style_obj . tag , content = content , classes = style_obj . classes . copy (), # Copy to prevent mutation of the registry ** attrs , ) # Fallback if key not found (or raise error) raise ValueError ( f \"BS5 Style ' { key } ' not found in registry.\" )","title":"BS5"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5.get_cls_string","text":"Returns just the class string (Old behavior). Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 167 168 169 170 171 172 173 174 def get_cls_string ( self , key : str ) -> str : \"\"\"Returns just the class string (Old behavior).\"\"\" # Convert selector-like key 'btn#x2' -> internal key 'btn__x2' if needed # For now assuming direct mapping based on your snippet clean_key = key . replace ( \"#\" , \"__\" ) . replace ( \".\" , \"_\" ) if clean_key in self . registry : return \" \" . join ( self . registry [ clean_key ] . classes ) return \"\"","title":"get_cls_string"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5.get_element","text":"Returns a BS5Element configured with the stored styles. Usage: bs5.get_element('btn#x2', 'Click Me') Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def get_element ( self , key : str , content : str = \"\" , ** attrs ) -> BS5Element : \"\"\" Returns a BS5Element configured with the stored styles. Usage: bs5.get_element('btn#x2', 'Click Me') \"\"\" clean_key = self . _normalize_key ( key ) if clean_key in self . registry : style_obj = self . registry [ clean_key ] # Create the element using the stored Tag and Classes return BS5Element ( tag = style_obj . tag , content = content , classes = style_obj . classes . copy (), # Copy to prevent mutation of the registry ** attrs , ) # Fallback if key not found (or raise error) raise ValueError ( f \"BS5 Style ' { key } ' not found in registry.\" )","title":"get_element"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5Element","text":"A dedicated builder for Bootstrap 5 elements. Manages the 'class' attribute specifically while delegating rendering to Element. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 class BS5Element : \"\"\" A dedicated builder for Bootstrap 5 elements. Manages the 'class' attribute specifically while delegating rendering to Element. \"\"\" def __init__ ( self , tag : str , content : str = \"\" , classes : Optional [ list ] = None , ** attrs ): self . tag = tag self . content = content . render () if hasattr ( content , \"render\" ) else content # Ensure classes is a list, avoiding shared mutable defaults self . classes = ( [ c for c in classes if c is not None ] if classes is not None else [] ) self . attrs = attrs self . attr_manager = ElementAttributeManipulator ( self . attrs ) def add ( self , * new_classes : str ): \"\"\"Fluent API to add Bootstrap classes.\"\"\" self . classes . extend ( new_classes ) return self def include ( self , * content , first = False , override = False ): \"\"\" Adds content to the element. If content is another BS5Element, it renders it. \"\"\" rendered_content = [] for item in content : if hasattr ( item , \"render\" ): rendered_content . append ( item . render ()) else : rendered_content . append ( str ( item )) # Append to existing content if override : self . content = \"\" . join ( rendered_content ) elif first and not override : self . content = \"\" . join ( rendered_content ) + self . content else : self . content += \"\" . join ( rendered_content ) return self def render ( self ) -> str : \"\"\" Constructs the final Element with the combined class string. \"\"\" # Join classes with spaces final_class_str = \" \" . join ( self . classes ) # Merge with any class passed in attrs (avoiding overwrites) if \"Class\" in self . attrs : # Handling your alias final_class_str += f \" { self . attrs . pop ( 'Class' ) } \" if final_class_str : self . attrs [ \"Class\" ] = final_class_str . strip () # Delegate to the Core Engine from probo.components.elements import Element return Element ( tag = self . tag , content = str ( self . content ), ** self . attrs ) . element","title":"BS5Element"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5Element.add","text":"Fluent API to add Bootstrap classes. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 100 101 102 103 def add ( self , * new_classes : str ): \"\"\"Fluent API to add Bootstrap classes.\"\"\" self . classes . extend ( new_classes ) return self","title":"add"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5Element.include","text":"Adds content to the element. If content is another BS5Element, it renders it. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 def include ( self , * content , first = False , override = False ): \"\"\" Adds content to the element. If content is another BS5Element, it renders it. \"\"\" rendered_content = [] for item in content : if hasattr ( item , \"render\" ): rendered_content . append ( item . render ()) else : rendered_content . append ( str ( item )) # Append to existing content if override : self . content = \"\" . join ( rendered_content ) elif first and not override : self . content = \"\" . join ( rendered_content ) + self . content else : self . content += \"\" . join ( rendered_content ) return self","title":"include"},{"location":"reference/probo/styles/frameworks/bs5/bs5/#probo.styles.frameworks.bs5.bs5.BS5Element.render","text":"Constructs the final Element with the combined class string. Source code in src\\probo\\styles\\frameworks\\bs5\\bs5.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 def render ( self ) -> str : \"\"\" Constructs the final Element with the combined class string. \"\"\" # Join classes with spaces final_class_str = \" \" . join ( self . classes ) # Merge with any class passed in attrs (avoiding overwrites) if \"Class\" in self . attrs : # Handling your alias final_class_str += f \" { self . attrs . pop ( 'Class' ) } \" if final_class_str : self . attrs [ \"Class\" ] = final_class_str . strip () # Delegate to the Core Engine from probo.components.elements import Element return Element ( tag = self . tag , content = str ( self . content ), ** self . attrs ) . element","title":"render"},{"location":"reference/probo/styles/frameworks/bs5/comp_enum/","text":"comp_enum Lists Bases: Enum Bootstrap Lists classes. These are used for styling lists. Source code in src\\probo\\styles\\frameworks\\bs5\\comp_enum.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class Lists ( Enum ): \"\"\" Bootstrap Lists classes. These are used for styling lists. \"\"\" UNSTYLED = \"list-unstyled\" # Unordered list without bullets INLINE = \"list-inline\" # Inline ordered list INLINE_ITEM = \"list-inline-item\" # Inline list item LIST_GROUP = \"list-group\" # Main list group container LIST_GROUP_ITEM = \"list-group-item\" # Basic list group item LIST_GROUP_ITEM_ACTIVE = \"list-group-item active\" # Active list group item LIST_GROUP_ITEM_DISABLED = \"list-group-item disabled\" # Disabled list group item LIST_GROUP_ITEM_ACTION = \"list-group-item list-group-item-action\" # Actionable list group item (links or buttons) LIST_GROUP_FLUSH = ( \"list-group-flush\" # Flush list group (no borders and rounded corners) ) LIST_GROUP_HORIZONTAL = ( \"list-group-horizontal\" # Horizontal list group (default breakpoint) ) LIST_GROUP_HORIZONTAL_SM = \"list-group-horizontal-sm\" # Horizontal on small devices LIST_GROUP_HORIZONTAL_MD = ( \"list-group-horizontal-md\" # Horizontal on medium devices ) LIST_GROUP_HORIZONTAL_LG = \"list-group-horizontal-lg\" # Horizontal on large devices LIST_GROUP_HORIZONTAL_XL = ( \"list-group-horizontal-xl\" # Horizontal on extra large devices ) LIST_GROUP_HORIZONTAL_XXL = \"list-group-horizontal-xxl\" # Horizontal on XXL devices LIST_GROUP_ITEM_PRIMARY = \"list-group-item-primary\" # Contextual color variants LIST_GROUP_ITEM_SECONDARY = \"list-group-item-secondary\" LIST_GROUP_ITEM_SUCCESS = \"list-group-item-success\" LIST_GROUP_ITEM_DANGER = \"list-group-item-danger\" LIST_GROUP_ITEM_WARNING = \"list-group-item-warning\" LIST_GROUP_ITEM_INFO = \"list-group-item-info\" LIST_GROUP_ITEM_LIGHT = \"list-group-item-light\" LIST_GROUP_ITEM_DARK = \"list-group-item-dark\" Table Bases: Enum Bootstrap Table classes. These are used for styling tables. Source code in src\\probo\\styles\\frameworks\\bs5\\comp_enum.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class Table ( Enum ): \"\"\" Bootstrap Table classes. These are used for styling tables. \"\"\" STRIPED = \"table-striped\" # Striped table rowsk BORDERED = \"table-bordered\" # Bordered table BORDERLESS = \"table-borderless\" # Borderless table HOVER = \"table-hover\" # Hover effect on table rows RESPONSIVE = \"table-responsive\" # Responsive table DARK = f \"table- { Color . DARK . value } \" # Dark themed table LIGHT = f \"table- { Color . LIGHT . value } \" # Light themed table PRIMARY = f \"table- { Color . PRIMARY . value } \" # Primary themed table SECONDARY = f \"table- { Color . SECONDARY . value } \" # Secondary themed table SUCCESS = f \"table- { Color . SUCCESS . value } \" # Success themed table DANGER = f \"table- { Color . DANGER . value } \" # Danger themed table WARNING = f \"table- { Color . WARNING . value } \" # Warning themed table INFO = f \"table- { Color . INFO . value } \" # Info themed table WHITE = f \"table- { Color . WHITE . value } \" # White themed table MUTED = f \"table- { Color . MUTED . value } \" # Muted themed table ACTIVE = \"table-active\" TABLE = \"table\" SM = f \"table- { Breakpoint . SM . value } \" MD = f \"table- { Breakpoint . MD . value } \" # table for large screens LG = f \"table- { Breakpoint . LG . value } \" # table for large screens XL = f \"table- { Breakpoint . XL . value } \" # table for extra large screens XXL = f \"table- { Breakpoint . XXL . value } \" # table for extra extra large screens RESPONSIVE_SM = f \"table-responsive- { Breakpoint . SM . value } \" # Responsive table for small screens RESPONSIVE_MD = f \"table-responsive- { Breakpoint . MD . value } \" # Responsive table for large screens RESPONSIVE_LG = f \"table-responsive- { Breakpoint . LG . value } \" # Responsive table for large screens) RESPONSIVE_XL = f \"table-responsive- { Breakpoint . XL . value } \" # Responsive table for extra large screens RESPONSIVE_XXL = f \"table-responsive- { Breakpoint . XXL . value } \" # Responsive table for extra extra large screens CAPTION = \"caption-top\" TABLE_GROUP_DIVIDER = \"table-group-divider\"","title":"comp_enum"},{"location":"reference/probo/styles/frameworks/bs5/comp_enum/#comp_enum","text":"","title":"comp_enum"},{"location":"reference/probo/styles/frameworks/bs5/comp_enum/#probo.styles.frameworks.bs5.comp_enum.Lists","text":"Bases: Enum Bootstrap Lists classes. These are used for styling lists. Source code in src\\probo\\styles\\frameworks\\bs5\\comp_enum.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 class Lists ( Enum ): \"\"\" Bootstrap Lists classes. These are used for styling lists. \"\"\" UNSTYLED = \"list-unstyled\" # Unordered list without bullets INLINE = \"list-inline\" # Inline ordered list INLINE_ITEM = \"list-inline-item\" # Inline list item LIST_GROUP = \"list-group\" # Main list group container LIST_GROUP_ITEM = \"list-group-item\" # Basic list group item LIST_GROUP_ITEM_ACTIVE = \"list-group-item active\" # Active list group item LIST_GROUP_ITEM_DISABLED = \"list-group-item disabled\" # Disabled list group item LIST_GROUP_ITEM_ACTION = \"list-group-item list-group-item-action\" # Actionable list group item (links or buttons) LIST_GROUP_FLUSH = ( \"list-group-flush\" # Flush list group (no borders and rounded corners) ) LIST_GROUP_HORIZONTAL = ( \"list-group-horizontal\" # Horizontal list group (default breakpoint) ) LIST_GROUP_HORIZONTAL_SM = \"list-group-horizontal-sm\" # Horizontal on small devices LIST_GROUP_HORIZONTAL_MD = ( \"list-group-horizontal-md\" # Horizontal on medium devices ) LIST_GROUP_HORIZONTAL_LG = \"list-group-horizontal-lg\" # Horizontal on large devices LIST_GROUP_HORIZONTAL_XL = ( \"list-group-horizontal-xl\" # Horizontal on extra large devices ) LIST_GROUP_HORIZONTAL_XXL = \"list-group-horizontal-xxl\" # Horizontal on XXL devices LIST_GROUP_ITEM_PRIMARY = \"list-group-item-primary\" # Contextual color variants LIST_GROUP_ITEM_SECONDARY = \"list-group-item-secondary\" LIST_GROUP_ITEM_SUCCESS = \"list-group-item-success\" LIST_GROUP_ITEM_DANGER = \"list-group-item-danger\" LIST_GROUP_ITEM_WARNING = \"list-group-item-warning\" LIST_GROUP_ITEM_INFO = \"list-group-item-info\" LIST_GROUP_ITEM_LIGHT = \"list-group-item-light\" LIST_GROUP_ITEM_DARK = \"list-group-item-dark\"","title":"Lists"},{"location":"reference/probo/styles/frameworks/bs5/comp_enum/#probo.styles.frameworks.bs5.comp_enum.Table","text":"Bases: Enum Bootstrap Table classes. These are used for styling tables. Source code in src\\probo\\styles\\frameworks\\bs5\\comp_enum.py 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class Table ( Enum ): \"\"\" Bootstrap Table classes. These are used for styling tables. \"\"\" STRIPED = \"table-striped\" # Striped table rowsk BORDERED = \"table-bordered\" # Bordered table BORDERLESS = \"table-borderless\" # Borderless table HOVER = \"table-hover\" # Hover effect on table rows RESPONSIVE = \"table-responsive\" # Responsive table DARK = f \"table- { Color . DARK . value } \" # Dark themed table LIGHT = f \"table- { Color . LIGHT . value } \" # Light themed table PRIMARY = f \"table- { Color . PRIMARY . value } \" # Primary themed table SECONDARY = f \"table- { Color . SECONDARY . value } \" # Secondary themed table SUCCESS = f \"table- { Color . SUCCESS . value } \" # Success themed table DANGER = f \"table- { Color . DANGER . value } \" # Danger themed table WARNING = f \"table- { Color . WARNING . value } \" # Warning themed table INFO = f \"table- { Color . INFO . value } \" # Info themed table WHITE = f \"table- { Color . WHITE . value } \" # White themed table MUTED = f \"table- { Color . MUTED . value } \" # Muted themed table ACTIVE = \"table-active\" TABLE = \"table\" SM = f \"table- { Breakpoint . SM . value } \" MD = f \"table- { Breakpoint . MD . value } \" # table for large screens LG = f \"table- { Breakpoint . LG . value } \" # table for large screens XL = f \"table- { Breakpoint . XL . value } \" # table for extra large screens XXL = f \"table- { Breakpoint . XXL . value } \" # table for extra extra large screens RESPONSIVE_SM = f \"table-responsive- { Breakpoint . SM . value } \" # Responsive table for small screens RESPONSIVE_MD = f \"table-responsive- { Breakpoint . MD . value } \" # Responsive table for large screens RESPONSIVE_LG = f \"table-responsive- { Breakpoint . LG . value } \" # Responsive table for large screens) RESPONSIVE_XL = f \"table-responsive- { Breakpoint . XL . value } \" # Responsive table for extra large screens RESPONSIVE_XXL = f \"table-responsive- { Breakpoint . XXL . value } \" # Responsive table for extra extra large screens CAPTION = \"caption-top\" TABLE_GROUP_DIVIDER = \"table-group-divider\"","title":"Table"},{"location":"reference/probo/styles/frameworks/bs5/forms/","text":"forms","title":"forms"},{"location":"reference/probo/styles/frameworks/bs5/forms/#forms","text":"","title":"forms"},{"location":"reference/probo/styles/frameworks/bs5/layout/","text":"layout Button Bases: Enum Bootstrap Button classes. Source code in src\\probo\\styles\\frameworks\\bs5\\layout.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 class Button ( Enum ): \"\"\"Bootstrap Button classes.\"\"\" BTN = \"btn\" # Base class for buttons PRIMARY = f \"btn- { Color . PRIMARY . value } \" SECONDARY = f \"btn- { Color . SECONDARY . value } \" SUCCESS = f \"btn- { Color . SUCCESS . value } \" DANGER = f \"btn- { Color . DANGER . value } \" WARNING = f \"btn- { Color . WARNING . value } \" INFO = f \"btn- { Color . INFO . value } \" LIGHT = f \"btn- { Color . LIGHT . value } \" DARK = f \"btn- { Color . DARK . value } \" LINK = \"btn-link\" OUTLINE_PRIMARY = f \"btn-outline- { Color . PRIMARY . value } \" OUTLINE_SECONDARY = f \"btn-outline- { Color . SECONDARY . value } \" OUTLINE_SUCCESS = f \"btn-outline- { Color . SUCCESS . value } \" OUTLINE_DANGER = f \"btn-outline- { Color . DANGER . value } \" OUTLINE_WARNING = f \"btn-outline- { Color . WARNING . value } \" OUTLINE_INFO = f \"btn-outline- { Color . INFO . value } \" OUTLINE_LIGHT = f \"btn-outline- { Color . LIGHT . value } \" OUTLINE_DARK = f \"btn-outline- { Color . DARK . value } \" SM = f \"btn- { Breakpoint . SM . value } \" LG = f \"btn- { Breakpoint . LG . value } \" BLOCK = \"d-grid\" GROUP = \"btn-group\" GROUP_SM = f \"btn-group- { Breakpoint . SM . value } \" GROUP_MD = f \"btn-group- { Breakpoint . MD . value } \" GROUP_LG = f \"btn-group- { Breakpoint . LG . value } \" GROUP_XL = f \"btn-group- { Breakpoint . XL . value } \" GROUP_XXL = f \"btn-group- { Breakpoint . XXL . value } \" GROUP_VERTICAL = \"btn-group-vertical\" CLOSE = \"btn-close\" # Close button def __call__ ( self ): return self . value @classmethod def get ( cls , name = None , ): if not name : return cls . BTN try : return cls [ name . upper () . replace ( '-' , '_' )] . value except KeyError : return None Layout dataclass ALL 6 OBJ ARE ENUMS Source code in src\\probo\\styles\\frameworks\\bs5\\layout.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 @dataclass class Layout : \"\"\"ALL 6 OBJ ARE ENUMS\"\"\" CONTAINER = Container ROW = Row COLUMN = Column GUTTER = Gutter BUTTON = Button __BREAKPOINT = Breakpoint @property def values_as_list ( self ): vals = [] vals . extend ([ x . value for x in self . COLUMN ]) vals . extend ([ x . value for x in self . CONTAINER ]) vals . extend ([ x . value for x in self . GUTTER ]) vals . extend ([ x . value for x in self . ROW ]) vals . extend ([ x . value for x in self . __BREAKPOINT ]) vals . extend ([ x . value for x in self . BUTTON ]) return vals Row Bases: Enum Bootstrap Row utilities. Represents the row class for the Bootstrap grid system. Source code in src\\probo\\styles\\frameworks\\bs5\\layout.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Row ( Enum ): \"\"\"Bootstrap Row utilities. Represents the row class for the Bootstrap grid system.\"\"\" BASE = \"row\" SM = f \"row- { Breakpoint . SM . value } \" MD = f \"row- { Breakpoint . MD . value } \" LG = f \"row- { Breakpoint . LG . value } \" XL = f \"row- { Breakpoint . XL . value } \" XXL = f \"row- { Breakpoint . XXL . value } \" SM_COL_1 = f \"row-cols- { Breakpoint . SM . value } -1\" MD_COL_1 = f \"row-cols- { Breakpoint . MD . value } -1\" LG_COL_1 = f \"row-cols- { Breakpoint . LG . value } -1\" XL_COL_1 = f \"row-cols- { Breakpoint . XL . value } -1\" XXL_COL_1 = f \"row-cols- { Breakpoint . XXL . value } -1\" def __call__ ( self ): return self . value @classmethod def get ( cls , name = None , ): if not name : return cls . BASE try : return cls [ name ] except KeyError : return None","title":"layout"},{"location":"reference/probo/styles/frameworks/bs5/layout/#layout","text":"","title":"layout"},{"location":"reference/probo/styles/frameworks/bs5/layout/#probo.styles.frameworks.bs5.layout.Button","text":"Bases: Enum Bootstrap Button classes. Source code in src\\probo\\styles\\frameworks\\bs5\\layout.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 class Button ( Enum ): \"\"\"Bootstrap Button classes.\"\"\" BTN = \"btn\" # Base class for buttons PRIMARY = f \"btn- { Color . PRIMARY . value } \" SECONDARY = f \"btn- { Color . SECONDARY . value } \" SUCCESS = f \"btn- { Color . SUCCESS . value } \" DANGER = f \"btn- { Color . DANGER . value } \" WARNING = f \"btn- { Color . WARNING . value } \" INFO = f \"btn- { Color . INFO . value } \" LIGHT = f \"btn- { Color . LIGHT . value } \" DARK = f \"btn- { Color . DARK . value } \" LINK = \"btn-link\" OUTLINE_PRIMARY = f \"btn-outline- { Color . PRIMARY . value } \" OUTLINE_SECONDARY = f \"btn-outline- { Color . SECONDARY . value } \" OUTLINE_SUCCESS = f \"btn-outline- { Color . SUCCESS . value } \" OUTLINE_DANGER = f \"btn-outline- { Color . DANGER . value } \" OUTLINE_WARNING = f \"btn-outline- { Color . WARNING . value } \" OUTLINE_INFO = f \"btn-outline- { Color . INFO . value } \" OUTLINE_LIGHT = f \"btn-outline- { Color . LIGHT . value } \" OUTLINE_DARK = f \"btn-outline- { Color . DARK . value } \" SM = f \"btn- { Breakpoint . SM . value } \" LG = f \"btn- { Breakpoint . LG . value } \" BLOCK = \"d-grid\" GROUP = \"btn-group\" GROUP_SM = f \"btn-group- { Breakpoint . SM . value } \" GROUP_MD = f \"btn-group- { Breakpoint . MD . value } \" GROUP_LG = f \"btn-group- { Breakpoint . LG . value } \" GROUP_XL = f \"btn-group- { Breakpoint . XL . value } \" GROUP_XXL = f \"btn-group- { Breakpoint . XXL . value } \" GROUP_VERTICAL = \"btn-group-vertical\" CLOSE = \"btn-close\" # Close button def __call__ ( self ): return self . value @classmethod def get ( cls , name = None , ): if not name : return cls . BTN try : return cls [ name . upper () . replace ( '-' , '_' )] . value except KeyError : return None","title":"Button"},{"location":"reference/probo/styles/frameworks/bs5/layout/#probo.styles.frameworks.bs5.layout.Layout","text":"ALL 6 OBJ ARE ENUMS Source code in src\\probo\\styles\\frameworks\\bs5\\layout.py 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 @dataclass class Layout : \"\"\"ALL 6 OBJ ARE ENUMS\"\"\" CONTAINER = Container ROW = Row COLUMN = Column GUTTER = Gutter BUTTON = Button __BREAKPOINT = Breakpoint @property def values_as_list ( self ): vals = [] vals . extend ([ x . value for x in self . COLUMN ]) vals . extend ([ x . value for x in self . CONTAINER ]) vals . extend ([ x . value for x in self . GUTTER ]) vals . extend ([ x . value for x in self . ROW ]) vals . extend ([ x . value for x in self . __BREAKPOINT ]) vals . extend ([ x . value for x in self . BUTTON ]) return vals","title":"Layout"},{"location":"reference/probo/styles/frameworks/bs5/layout/#probo.styles.frameworks.bs5.layout.Row","text":"Bases: Enum Bootstrap Row utilities. Represents the row class for the Bootstrap grid system. Source code in src\\probo\\styles\\frameworks\\bs5\\layout.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 class Row ( Enum ): \"\"\"Bootstrap Row utilities. Represents the row class for the Bootstrap grid system.\"\"\" BASE = \"row\" SM = f \"row- { Breakpoint . SM . value } \" MD = f \"row- { Breakpoint . MD . value } \" LG = f \"row- { Breakpoint . LG . value } \" XL = f \"row- { Breakpoint . XL . value } \" XXL = f \"row- { Breakpoint . XXL . value } \" SM_COL_1 = f \"row-cols- { Breakpoint . SM . value } -1\" MD_COL_1 = f \"row-cols- { Breakpoint . MD . value } -1\" LG_COL_1 = f \"row-cols- { Breakpoint . LG . value } -1\" XL_COL_1 = f \"row-cols- { Breakpoint . XL . value } -1\" XXL_COL_1 = f \"row-cols- { Breakpoint . XXL . value } -1\" def __call__ ( self ): return self . value @classmethod def get ( cls , name = None , ): if not name : return cls . BASE try : return cls [ name ] except KeyError : return None","title":"Row"},{"location":"reference/probo/styles/frameworks/bs5/typography/","text":"typography Abbreviation Bases: Enum Bootstrap Abbreviations classes. These are used for defining abbreviations and acronyms. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 72 73 74 75 76 77 78 79 class Abbreviation ( Enum ): \"\"\" Bootstrap Abbreviations classes. These are used for defining abbreviations and acronyms. \"\"\" ABBREVIATION = \"abbreviation\" INITIALISM = \"initialism\" Blockquote Bases: Enum Bootstrap Blockquote class. Used for quoting sections of text. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 82 83 84 85 86 87 88 89 class Blockquote ( Enum ): \"\"\" Bootstrap Blockquote class. Used for quoting sections of text. \"\"\" BLOCKQUOTE = \"blockquote\" NAMING_A_SOURCE = \"blockquote-footer\" Image Bases: Enum Bootstrap Images classes. These are used for styling images. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Image ( Enum ): \"\"\" Bootstrap Images classes. These are used for styling images. \"\"\" RESPONSIVE = \"img-fluid\" # Responsive image THUMBNAIL = \"img-thumbnail\" # Thumbnail image ROUND = \"rounded\" # Rounded corners CIRCLE = \"rounded-circle\" # Circle shape FIGURE_IMG = \"figure-img\" FIGURE = \"figure\" CAPTION = \"figure-caption\" PICTURE = \"picture\" Lead Bases: Enum Bootstrap Lead class for larger paragraph text. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 66 67 68 69 class Lead ( Enum ): \"\"\"Bootstrap Lead class for larger paragraph text.\"\"\" LEAD = \"lead\" Text Bases: Enum Bootstrap Text colors and alignment. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Text ( Enum ): \"\"\"Bootstrap Text colors and alignment.\"\"\" PRIMARY = \"text-primary\" SECONDARY = \"text-secondary\" SUCCESS = \"text-success\" DANGER = \"text-danger\" WARNING = \"text-warning\" INFO = \"text-info\" LIGHT = \"text-light\" DARK = \"text-dark\" WHITE = \"text-white\" MUTED = \"text-muted\" BG_PRIMARY = \"text-bg-primary\" BG_SECONDARY = \"text-bg-secondary\" BG_SUCCESS = \"text-bg-success\" BG_DANGER = \"text-bg-danger\" BG_WARNING = \"text-bg-warning\" BG_INFO = \"text-bg-info\" BG_LIGHT = \"text-bg-light\" BG_DARK = \"text-bg-dark\" BG_WHITE = \"text-bg-white\" BG_MUTED = \"text-bg-muted\" START = \"text-start\" CENTER = \"text-center\" END = \"text-end\" UNDERLINE = \"text-decoration-underline\" DELETED = \"text-decoration-line-through\" JUSTIFY = \"text-justify\" # Justify text WRAP = \"text-wrap\" # Wrap text NO_WRAP = \"text-nowrap\" # NONE = \"text-decoration-none\" LOWER = \"text-lowercase\" UPPER = \"text-uppercase\" BODY = \"text-body\" BLACK_50 = \"text-black-50\" WHITE_50 = \"text-white-50\" LEFT = \"text-left\" RIGHT = \"text-right\" CAPITALIZE = \"text-capitalize\" TRUNCATE = \"text-truncate\" BREAK = \"text-break\" Typography Bootstrap Typography classes. These are used for text styling and formatting. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 class Typography : \"\"\" Bootstrap Typography classes. These are used for text styling and formatting. \"\"\" HEADING = Heading TEXT = Text LEAD = Lead ABBREVIATION = Abbreviation BLOCK_QUOTE = Blockquote IMAGE = Image @property def values_as_list ( self ): vals = [] vals . extend ([ x . value for x in self . HEADING ]) vals . extend ([ x . value for x in self . TEXT ]) vals . extend ([ x . value for x in self . LEAD ]) vals . extend ([ x . value for x in self . ABBREVIATION ]) vals . extend ([ x . value for x in self . BLOCK_QUOTE ]) vals . extend ([ x . value for x in self . IMAGE ]) return vals","title":"typography"},{"location":"reference/probo/styles/frameworks/bs5/typography/#typography","text":"","title":"typography"},{"location":"reference/probo/styles/frameworks/bs5/typography/#probo.styles.frameworks.bs5.typography.Abbreviation","text":"Bases: Enum Bootstrap Abbreviations classes. These are used for defining abbreviations and acronyms. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 72 73 74 75 76 77 78 79 class Abbreviation ( Enum ): \"\"\" Bootstrap Abbreviations classes. These are used for defining abbreviations and acronyms. \"\"\" ABBREVIATION = \"abbreviation\" INITIALISM = \"initialism\"","title":"Abbreviation"},{"location":"reference/probo/styles/frameworks/bs5/typography/#probo.styles.frameworks.bs5.typography.Blockquote","text":"Bases: Enum Bootstrap Blockquote class. Used for quoting sections of text. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 82 83 84 85 86 87 88 89 class Blockquote ( Enum ): \"\"\" Bootstrap Blockquote class. Used for quoting sections of text. \"\"\" BLOCKQUOTE = \"blockquote\" NAMING_A_SOURCE = \"blockquote-footer\"","title":"Blockquote"},{"location":"reference/probo/styles/frameworks/bs5/typography/#probo.styles.frameworks.bs5.typography.Image","text":"Bases: Enum Bootstrap Images classes. These are used for styling images. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class Image ( Enum ): \"\"\" Bootstrap Images classes. These are used for styling images. \"\"\" RESPONSIVE = \"img-fluid\" # Responsive image THUMBNAIL = \"img-thumbnail\" # Thumbnail image ROUND = \"rounded\" # Rounded corners CIRCLE = \"rounded-circle\" # Circle shape FIGURE_IMG = \"figure-img\" FIGURE = \"figure\" CAPTION = \"figure-caption\" PICTURE = \"picture\"","title":"Image"},{"location":"reference/probo/styles/frameworks/bs5/typography/#probo.styles.frameworks.bs5.typography.Lead","text":"Bases: Enum Bootstrap Lead class for larger paragraph text. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 66 67 68 69 class Lead ( Enum ): \"\"\"Bootstrap Lead class for larger paragraph text.\"\"\" LEAD = \"lead\"","title":"Lead"},{"location":"reference/probo/styles/frameworks/bs5/typography/#probo.styles.frameworks.bs5.typography.Text","text":"Bases: Enum Bootstrap Text colors and alignment. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Text ( Enum ): \"\"\"Bootstrap Text colors and alignment.\"\"\" PRIMARY = \"text-primary\" SECONDARY = \"text-secondary\" SUCCESS = \"text-success\" DANGER = \"text-danger\" WARNING = \"text-warning\" INFO = \"text-info\" LIGHT = \"text-light\" DARK = \"text-dark\" WHITE = \"text-white\" MUTED = \"text-muted\" BG_PRIMARY = \"text-bg-primary\" BG_SECONDARY = \"text-bg-secondary\" BG_SUCCESS = \"text-bg-success\" BG_DANGER = \"text-bg-danger\" BG_WARNING = \"text-bg-warning\" BG_INFO = \"text-bg-info\" BG_LIGHT = \"text-bg-light\" BG_DARK = \"text-bg-dark\" BG_WHITE = \"text-bg-white\" BG_MUTED = \"text-bg-muted\" START = \"text-start\" CENTER = \"text-center\" END = \"text-end\" UNDERLINE = \"text-decoration-underline\" DELETED = \"text-decoration-line-through\" JUSTIFY = \"text-justify\" # Justify text WRAP = \"text-wrap\" # Wrap text NO_WRAP = \"text-nowrap\" # NONE = \"text-decoration-none\" LOWER = \"text-lowercase\" UPPER = \"text-uppercase\" BODY = \"text-body\" BLACK_50 = \"text-black-50\" WHITE_50 = \"text-white-50\" LEFT = \"text-left\" RIGHT = \"text-right\" CAPITALIZE = \"text-capitalize\" TRUNCATE = \"text-truncate\" BREAK = \"text-break\"","title":"Text"},{"location":"reference/probo/styles/frameworks/bs5/typography/#probo.styles.frameworks.bs5.typography.Typography","text":"Bootstrap Typography classes. These are used for text styling and formatting. Source code in src\\probo\\styles\\frameworks\\bs5\\typography.py 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 class Typography : \"\"\" Bootstrap Typography classes. These are used for text styling and formatting. \"\"\" HEADING = Heading TEXT = Text LEAD = Lead ABBREVIATION = Abbreviation BLOCK_QUOTE = Blockquote IMAGE = Image @property def values_as_list ( self ): vals = [] vals . extend ([ x . value for x in self . HEADING ]) vals . extend ([ x . value for x in self . TEXT ]) vals . extend ([ x . value for x in self . LEAD ]) vals . extend ([ x . value for x in self . ABBREVIATION ]) vals . extend ([ x . value for x in self . BLOCK_QUOTE ]) vals . extend ([ x . value for x in self . IMAGE ]) return vals","title":"Typography"},{"location":"reference/probo/styles/frameworks/bs5/utilities/","text":"utilities Background Bases: Enum Bootstrap Background colors. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class Background ( Enum ): \"\"\"Bootstrap Background colors.\"\"\" PRIMARY = \"bg-primary\" SECONDARY = \"bg-secondary\" SUCCESS = \"bg-success\" DANGER = \"bg-danger\" WARNING = \"bg-warning\" INFO = \"bg-info\" LIGHT = \"bg-light\" DARK = \"bg-dark\" WHITE = \"bg-white\" TRANSPARENT = \"bg-transparent\" BODY = \"bg-body\" Display Bases: Enum Bootstrap Display utilities. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class Display ( Enum ): \"\"\"Bootstrap Display utilities.\"\"\" NONE = \"d-none\" INLINE = \"d-inline\" INLINE_BLOCK = \"d-inline-block\" BLOCK = \"d-block\" GRID = \"d-grid\" FLEX = \"d-flex\" TABLE = \"d-table\" # Responsive display SM_BLOCK = f \"d- { Breakpoint . SM . value } -block\" MD_BLOCK = f \"d- { Breakpoint . MD . value } -block\" LG_BLOCK = f \"d- { Breakpoint . LG . value } -block\" XL_BLOCK = f \"d- { Breakpoint . XL . value } -block\" XXL_BLOCK = f \"d- { Breakpoint . XXL . value } -block\" SM_FLEX = f \"d- { Breakpoint . SM . value } -flex\" MD_FLEX = f \"d- { Breakpoint . MD . value } -flex\" LG_FLEX = f \"d- { Breakpoint . LG . value } -flex\" XL_FLEX = f \"d- { Breakpoint . XL . value } -flex\" XXL_FLEX = f \"d- { Breakpoint . XXL . value } -flex\" SM_NONE = f \"d- { Breakpoint . SM . value } -none\" MD_NONE = f \"d- { Breakpoint . MD . value } -none\" LG_NONE = f \"d- { Breakpoint . LG . value } -none\" XL_NONE = f \"d- { Breakpoint . XL . value } -none\" XXL_NONE = f \"d- { Breakpoint . XXL . value } -none\" Font Bases: Enum Bootstrap Inline Text Elements classes. These are used for inline text formatting. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class Font ( Enum ): \"\"\" Bootstrap Inline Text Elements classes. These are used for inline text formatting. \"\"\" BOLD = \"fw-bold\" # Strong emphasis (bold) NORMAL_FW = \"fw-normal\" # Emphasis (italic) NORMAL_FST = \"fst-normal\" # Emphasis (italic) ITALIC = \"fst-italic\" # Italic text SMALL = \"small\" # Smaller text SUBSCRIPT = \"sub\" # Subscript text SUPERSCRIPT = \"sup\" # Superscript text MARK = \"mark\" GridFunc Bootstrap Grid System classes. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 class GridFunc : \"\"\"Bootstrap Grid System classes.\"\"\" @staticmethod def COL ( self , value : int ): return f \"col- { value } \" @staticmethod def COL_AUTO ( self , ): return \"col-auto\" @staticmethod def COL_SM ( self , value : int ): return f \"col-sm- { value } \" @staticmethod def COL_MD ( self , value : int ): return f \"col-md- { value } \" @staticmethod def COL_LG ( self , value : int ): return f \"col-lg- { value } \" @staticmethod def ROW ( self , ): return \"row\" @staticmethod def CONTAINER ( self , ): return \"container\" @staticmethod def CONTAINER_FLUID ( self , ): return \"container-fluid\" Offset Bases: Enum Bootstrap offset classes for grid columns. Provides offset classes to create space between columns in Bootstrap's grid system. Supports responsive offsets for all breakpoints. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class Offset ( Enum ): \"\"\"Bootstrap offset classes for grid columns. Provides offset classes to create space between columns in Bootstrap's grid system. Supports responsive offsets for all breakpoints. \"\"\" # Base offsets OFFSET_1 = \"offset-1\" OFFSET_2 = \"offset-2\" OFFSET_3 = \"offset-3\" OFFSET_4 = \"offset-4\" OFFSET_5 = \"offset-5\" OFFSET_6 = \"offset-6\" OFFSET_7 = \"offset-7\" OFFSET_8 = \"offset-8\" OFFSET_9 = \"offset-9\" OFFSET_10 = \"offset-10\" OFFSET_11 = \"offset-11\" # Responsive offsets - SM SM_OFFSET_1 = \"offset-sm-1\" SM_OFFSET_2 = \"offset-sm-2\" SM_OFFSET_3 = \"offset-sm-3\" SM_OFFSET_4 = \"offset-sm-4\" SM_OFFSET_5 = \"offset-sm-5\" SM_OFFSET_6 = \"offset-sm-6\" SM_OFFSET_7 = \"offset-sm-7\" SM_OFFSET_8 = \"offset-sm-8\" SM_OFFSET_9 = \"offset-sm-9\" SM_OFFSET_10 = \"offset-sm-10\" SM_OFFSET_11 = \"offset-sm-11\" # Responsive offsets - MD MD_OFFSET_1 = \"offset-md-1\" MD_OFFSET_2 = \"offset-md-2\" MD_OFFSET_3 = \"offset-md-3\" MD_OFFSET_4 = \"offset-md-4\" MD_OFFSET_5 = \"offset-md-5\" MD_OFFSET_6 = \"offset-md-6\" MD_OFFSET_7 = \"offset-md-7\" MD_OFFSET_8 = \"offset-md-8\" MD_OFFSET_9 = \"offset-md-9\" MD_OFFSET_10 = \"offset-md-10\" MD_OFFSET_11 = \"offset-md-11\" # Responsive offsets - LG LG_OFFSET_1 = \"offset-lg-1\" LG_OFFSET_2 = \"offset-lg-2\" LG_OFFSET_3 = \"offset-lg-3\" LG_OFFSET_4 = \"offset-lg-4\" LG_OFFSET_5 = \"offset-lg-5\" LG_OFFSET_6 = \"offset-lg-6\" LG_OFFSET_7 = \"offset-lg-7\" LG_OFFSET_8 = \"offset-lg-8\" LG_OFFSET_9 = \"offset-lg-9\" LG_OFFSET_10 = \"offset-lg-10\" LG_OFFSET_11 = \"offset-lg-11\" # Responsive offsets - XL XL_OFFSET_1 = \"offset-xl-1\" XL_OFFSET_2 = \"offset-xl-2\" XL_OFFSET_3 = \"offset-xl-3\" XL_OFFSET_4 = \"offset-xl-4\" XL_OFFSET_5 = \"offset-xl-5\" XL_OFFSET_6 = \"offset-xl-6\" XL_OFFSET_7 = \"offset-xl-7\" XL_OFFSET_8 = \"offset-xl-8\" XL_OFFSET_9 = \"offset-xl-9\" XL_OFFSET_10 = \"offset-xl-10\" XL_OFFSET_11 = \"offset-xl-11\" # Responsive offsets - XXL XXL_OFFSET_1 = \"offset-xxl-1\" XXL_OFFSET_2 = \"offset-xxl-2\" XXL_OFFSET_3 = \"offset-xxl-3\" XXL_OFFSET_4 = \"offset-xxl-4\" XXL_OFFSET_5 = \"offset-xxl-5\" XXL_OFFSET_6 = \"offset-xxl-6\" XXL_OFFSET_7 = \"offset-xxl-7\" XXL_OFFSET_8 = \"offset-xxl-8\" XXL_OFFSET_9 = \"offset-xxl-9\" XXL_OFFSET_10 = \"offset-xxl-10\" XXL_OFFSET_11 = \"offset-xxl-11\" Spacing Bases: Enum Bootstrap Spacing utilities (margin and padding). Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class Spacing ( Enum ): \"\"\"Bootstrap Spacing utilities (margin and padding).\"\"\" PX1 = \"px-1\" # Padding on X-axis PX2 = \"px-2\" # Padding on X-axis PX3 = \"px-3\" # Padding on X-axis PX4 = \"px-4\" # Padding on X-axis PX5 = \"px-5\" # Padding on X-axis PY1 = \"py-1\" # Padding on Y-axis PY2 = \"py-2\" # Padding on Y-axis PY3 = \"py-3\" # Padding on Y-axis PY4 = \"py-4\" # Padding on Y-axis PY5 = \"py-5\" # Padding on Y-axis PT1 = \"pt-1\" # Padding Top PT2 = \"pt-2\" # Padding Top PT3 = \"pt-3\" # Padding Top PT4 = \"pt-4\" # Padding Top PT5 = \"pt-5\" # Padding Top PB1 = \"pb-1\" # Padding Bottom PB2 = \"pb-2\" # Padding Bottom PB3 = \"pb-3\" # Padding Bottom PB4 = \"pb-4\" # Padding Bottom PB5 = \"pb-5\" # Padding Bottom PS1 = \"ps-1\" # Padding Start (left in LTR) PS2 = \"ps-2\" # Padding Start (left in LTR) PS3 = \"ps-3\" # Padding Start (left in LTR) PS4 = \"ps-4\" # Padding Start (left in LTR) PS5 = \"ps-5\" # Padding Start (left in LTR) PE1 = \"pe-1\" # Padding End (right in LTR) PE2 = \"pe-2\" # Padding End (right in LTR) PE3 = \"pe-3\" # Padding End (right in LTR) PE4 = \"pe-4\" # Padding End (right in LTR) PE5 = \"pe-5\" # Padding End (right in LTR) P1 = \"p-1\" # Padding all sides P2 = \"p-2\" # Padding all sides P3 = \"p-3\" # Padding all sides P4 = \"p-4\" # Padding all sides P5 = \"p-5\" # Padding all sides MX1 = \"mx-1\" # Margin on X-axis MX2 = \"mx-2\" # Margin on X-axis MX3 = \"mx-3\" # Margin on X-axis MX4 = \"mx-4\" # Margin on X-axis MX5 = \"mx-5\" # Margin on X-axis MY1 = \"my-1\" # Margin on Y-axis MY2 = \"my-2\" # Margin on Y-axis MY3 = \"my-3\" # Margin on Y-axis MY4 = \"my-4\" # Margin on Y-axis MY5 = \"my-5\" # Margin on Y-axis MT1 = \"mt-1\" # Margin Top MT2 = \"mt-2\" # Margin Top MT3 = \"mt-3\" # Margin Top MT4 = \"mt-4\" # Margin Top MT5 = \"mt-5\" # Margin Top MB1 = \"mb-1\" # Margin Bottom MB2 = \"mb-2\" # Margin Bottom MB3 = \"mb-3\" # Margin Bottom MB4 = \"mb-4\" # Margin Bottom MB5 = \"mb-5\" # Margin Bottom MS1 = \"ms-1\" # Margin Start (left in LTR) MS2 = \"ms-2\" # Margin Start (left in LTR) MS3 = \"ms-3\" # Margin Start (left in LTR) MS4 = \"ms-4\" # Margin Start (left in LTR) MS5 = \"ms-5\" # Margin Start (left in LTR) ME1 = \"me-1\" # Margin End (right in LTR) ME2 = \"me-2\" # Margin End (right in LTR) ME3 = \"me-3\" # Margin End (right in LTR) ME4 = \"me-4\" # Margin End (right in LTR) ME5 = \"me-5\" # Margin End (right in LTR) M1 = \"m-1\" # Margin all sides M2 = \"m-2\" # Margin all sides M3 = \"m-3\" # Margin all sides M4 = \"m-4\" # Margin all sides M5 = \"m-5\" # Margin all sides GAP1 = \"gap-1\" GAP2 = \"gap-2\" GAP3 = \"gap-3\" GAP4 = \"gap-4\" GAP5 = \"gap-5\" AUTO_MX = \"mx-auto\" # Center horizontally SpacingFunc Bootstrap Spacing utilities (margin and padding). Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 class SpacingFunc : \"\"\"Bootstrap Spacing utilities (margin and padding).\"\"\" @staticmethod def PX ( self , value : int ): return f \"px- { value } \" # Padding on X-axis @staticmethod def PY ( self , value : int ): return f \"py- { value } \" # Padding on Y-axis @staticmethod def PT ( self , value : int ): return f \"pt- { value } \" # Padding Top @staticmethod def PB ( self , value : int ): return f \"pb- { value } \" # Padding Bottom @staticmethod def PS ( self , value : int ): return f \"ps- { value } \" # Padding Start (self,left in LTR) @staticmethod def PE ( self , value : int ): return f \"pe- { value } \" # Padding End (self,right in LTR) @staticmethod def P ( self , value : int ): return f \"p- { value } \" # Padding all sides @staticmethod def MX ( self , value : int ): return f \"mx- { value } \" # Margin on X-axis @staticmethod def MY ( self , value : int ): return f \"my- { value } \" # Margin on Y-axis @staticmethod def MT ( self , value : int ): return f \"mt- { value } \" # Margin Top @staticmethod def MB ( self , value : int ): return f \"mb- { value } \" # Margin Bottom @staticmethod def MS ( self , value : int ): return f \"ms- { value } \" # Margin Start (self,left in LTR) @staticmethod def ME ( self , value : int ): return f \"me- { value } \" # Margin End (self,right in LTR) @staticmethod def M ( self , value : int ): return f \"m- { value } \" # Margin all sides @staticmethod def AUTO_MX ( self , ): return \"mx-auto\" # Center horizontally","title":"utilities"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#utilities","text":"","title":"utilities"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.Background","text":"Bases: Enum Bootstrap Background colors. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 189 190 191 192 193 194 195 196 197 198 199 200 201 202 class Background ( Enum ): \"\"\"Bootstrap Background colors.\"\"\" PRIMARY = \"bg-primary\" SECONDARY = \"bg-secondary\" SUCCESS = \"bg-success\" DANGER = \"bg-danger\" WARNING = \"bg-warning\" INFO = \"bg-info\" LIGHT = \"bg-light\" DARK = \"bg-dark\" WHITE = \"bg-white\" TRANSPARENT = \"bg-transparent\" BODY = \"bg-body\"","title":"Background"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.Display","text":"Bases: Enum Bootstrap Display utilities. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 class Display ( Enum ): \"\"\"Bootstrap Display utilities.\"\"\" NONE = \"d-none\" INLINE = \"d-inline\" INLINE_BLOCK = \"d-inline-block\" BLOCK = \"d-block\" GRID = \"d-grid\" FLEX = \"d-flex\" TABLE = \"d-table\" # Responsive display SM_BLOCK = f \"d- { Breakpoint . SM . value } -block\" MD_BLOCK = f \"d- { Breakpoint . MD . value } -block\" LG_BLOCK = f \"d- { Breakpoint . LG . value } -block\" XL_BLOCK = f \"d- { Breakpoint . XL . value } -block\" XXL_BLOCK = f \"d- { Breakpoint . XXL . value } -block\" SM_FLEX = f \"d- { Breakpoint . SM . value } -flex\" MD_FLEX = f \"d- { Breakpoint . MD . value } -flex\" LG_FLEX = f \"d- { Breakpoint . LG . value } -flex\" XL_FLEX = f \"d- { Breakpoint . XL . value } -flex\" XXL_FLEX = f \"d- { Breakpoint . XXL . value } -flex\" SM_NONE = f \"d- { Breakpoint . SM . value } -none\" MD_NONE = f \"d- { Breakpoint . MD . value } -none\" LG_NONE = f \"d- { Breakpoint . LG . value } -none\" XL_NONE = f \"d- { Breakpoint . XL . value } -none\" XXL_NONE = f \"d- { Breakpoint . XXL . value } -none\"","title":"Display"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.Font","text":"Bases: Enum Bootstrap Inline Text Elements classes. These are used for inline text formatting. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class Font ( Enum ): \"\"\" Bootstrap Inline Text Elements classes. These are used for inline text formatting. \"\"\" BOLD = \"fw-bold\" # Strong emphasis (bold) NORMAL_FW = \"fw-normal\" # Emphasis (italic) NORMAL_FST = \"fst-normal\" # Emphasis (italic) ITALIC = \"fst-italic\" # Italic text SMALL = \"small\" # Smaller text SUBSCRIPT = \"sub\" # Subscript text SUPERSCRIPT = \"sup\" # Superscript text MARK = \"mark\"","title":"Font"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.GridFunc","text":"Bootstrap Grid System classes. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 class GridFunc : \"\"\"Bootstrap Grid System classes.\"\"\" @staticmethod def COL ( self , value : int ): return f \"col- { value } \" @staticmethod def COL_AUTO ( self , ): return \"col-auto\" @staticmethod def COL_SM ( self , value : int ): return f \"col-sm- { value } \" @staticmethod def COL_MD ( self , value : int ): return f \"col-md- { value } \" @staticmethod def COL_LG ( self , value : int ): return f \"col-lg- { value } \" @staticmethod def ROW ( self , ): return \"row\" @staticmethod def CONTAINER ( self , ): return \"container\" @staticmethod def CONTAINER_FLUID ( self , ): return \"container-fluid\"","title":"GridFunc"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.Offset","text":"Bases: Enum Bootstrap offset classes for grid columns. Provides offset classes to create space between columns in Bootstrap's grid system. Supports responsive offsets for all breakpoints. Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 class Offset ( Enum ): \"\"\"Bootstrap offset classes for grid columns. Provides offset classes to create space between columns in Bootstrap's grid system. Supports responsive offsets for all breakpoints. \"\"\" # Base offsets OFFSET_1 = \"offset-1\" OFFSET_2 = \"offset-2\" OFFSET_3 = \"offset-3\" OFFSET_4 = \"offset-4\" OFFSET_5 = \"offset-5\" OFFSET_6 = \"offset-6\" OFFSET_7 = \"offset-7\" OFFSET_8 = \"offset-8\" OFFSET_9 = \"offset-9\" OFFSET_10 = \"offset-10\" OFFSET_11 = \"offset-11\" # Responsive offsets - SM SM_OFFSET_1 = \"offset-sm-1\" SM_OFFSET_2 = \"offset-sm-2\" SM_OFFSET_3 = \"offset-sm-3\" SM_OFFSET_4 = \"offset-sm-4\" SM_OFFSET_5 = \"offset-sm-5\" SM_OFFSET_6 = \"offset-sm-6\" SM_OFFSET_7 = \"offset-sm-7\" SM_OFFSET_8 = \"offset-sm-8\" SM_OFFSET_9 = \"offset-sm-9\" SM_OFFSET_10 = \"offset-sm-10\" SM_OFFSET_11 = \"offset-sm-11\" # Responsive offsets - MD MD_OFFSET_1 = \"offset-md-1\" MD_OFFSET_2 = \"offset-md-2\" MD_OFFSET_3 = \"offset-md-3\" MD_OFFSET_4 = \"offset-md-4\" MD_OFFSET_5 = \"offset-md-5\" MD_OFFSET_6 = \"offset-md-6\" MD_OFFSET_7 = \"offset-md-7\" MD_OFFSET_8 = \"offset-md-8\" MD_OFFSET_9 = \"offset-md-9\" MD_OFFSET_10 = \"offset-md-10\" MD_OFFSET_11 = \"offset-md-11\" # Responsive offsets - LG LG_OFFSET_1 = \"offset-lg-1\" LG_OFFSET_2 = \"offset-lg-2\" LG_OFFSET_3 = \"offset-lg-3\" LG_OFFSET_4 = \"offset-lg-4\" LG_OFFSET_5 = \"offset-lg-5\" LG_OFFSET_6 = \"offset-lg-6\" LG_OFFSET_7 = \"offset-lg-7\" LG_OFFSET_8 = \"offset-lg-8\" LG_OFFSET_9 = \"offset-lg-9\" LG_OFFSET_10 = \"offset-lg-10\" LG_OFFSET_11 = \"offset-lg-11\" # Responsive offsets - XL XL_OFFSET_1 = \"offset-xl-1\" XL_OFFSET_2 = \"offset-xl-2\" XL_OFFSET_3 = \"offset-xl-3\" XL_OFFSET_4 = \"offset-xl-4\" XL_OFFSET_5 = \"offset-xl-5\" XL_OFFSET_6 = \"offset-xl-6\" XL_OFFSET_7 = \"offset-xl-7\" XL_OFFSET_8 = \"offset-xl-8\" XL_OFFSET_9 = \"offset-xl-9\" XL_OFFSET_10 = \"offset-xl-10\" XL_OFFSET_11 = \"offset-xl-11\" # Responsive offsets - XXL XXL_OFFSET_1 = \"offset-xxl-1\" XXL_OFFSET_2 = \"offset-xxl-2\" XXL_OFFSET_3 = \"offset-xxl-3\" XXL_OFFSET_4 = \"offset-xxl-4\" XXL_OFFSET_5 = \"offset-xxl-5\" XXL_OFFSET_6 = \"offset-xxl-6\" XXL_OFFSET_7 = \"offset-xxl-7\" XXL_OFFSET_8 = \"offset-xxl-8\" XXL_OFFSET_9 = \"offset-xxl-9\" XXL_OFFSET_10 = \"offset-xxl-10\" XXL_OFFSET_11 = \"offset-xxl-11\"","title":"Offset"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.Spacing","text":"Bases: Enum Bootstrap Spacing utilities (margin and padding). Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 class Spacing ( Enum ): \"\"\"Bootstrap Spacing utilities (margin and padding).\"\"\" PX1 = \"px-1\" # Padding on X-axis PX2 = \"px-2\" # Padding on X-axis PX3 = \"px-3\" # Padding on X-axis PX4 = \"px-4\" # Padding on X-axis PX5 = \"px-5\" # Padding on X-axis PY1 = \"py-1\" # Padding on Y-axis PY2 = \"py-2\" # Padding on Y-axis PY3 = \"py-3\" # Padding on Y-axis PY4 = \"py-4\" # Padding on Y-axis PY5 = \"py-5\" # Padding on Y-axis PT1 = \"pt-1\" # Padding Top PT2 = \"pt-2\" # Padding Top PT3 = \"pt-3\" # Padding Top PT4 = \"pt-4\" # Padding Top PT5 = \"pt-5\" # Padding Top PB1 = \"pb-1\" # Padding Bottom PB2 = \"pb-2\" # Padding Bottom PB3 = \"pb-3\" # Padding Bottom PB4 = \"pb-4\" # Padding Bottom PB5 = \"pb-5\" # Padding Bottom PS1 = \"ps-1\" # Padding Start (left in LTR) PS2 = \"ps-2\" # Padding Start (left in LTR) PS3 = \"ps-3\" # Padding Start (left in LTR) PS4 = \"ps-4\" # Padding Start (left in LTR) PS5 = \"ps-5\" # Padding Start (left in LTR) PE1 = \"pe-1\" # Padding End (right in LTR) PE2 = \"pe-2\" # Padding End (right in LTR) PE3 = \"pe-3\" # Padding End (right in LTR) PE4 = \"pe-4\" # Padding End (right in LTR) PE5 = \"pe-5\" # Padding End (right in LTR) P1 = \"p-1\" # Padding all sides P2 = \"p-2\" # Padding all sides P3 = \"p-3\" # Padding all sides P4 = \"p-4\" # Padding all sides P5 = \"p-5\" # Padding all sides MX1 = \"mx-1\" # Margin on X-axis MX2 = \"mx-2\" # Margin on X-axis MX3 = \"mx-3\" # Margin on X-axis MX4 = \"mx-4\" # Margin on X-axis MX5 = \"mx-5\" # Margin on X-axis MY1 = \"my-1\" # Margin on Y-axis MY2 = \"my-2\" # Margin on Y-axis MY3 = \"my-3\" # Margin on Y-axis MY4 = \"my-4\" # Margin on Y-axis MY5 = \"my-5\" # Margin on Y-axis MT1 = \"mt-1\" # Margin Top MT2 = \"mt-2\" # Margin Top MT3 = \"mt-3\" # Margin Top MT4 = \"mt-4\" # Margin Top MT5 = \"mt-5\" # Margin Top MB1 = \"mb-1\" # Margin Bottom MB2 = \"mb-2\" # Margin Bottom MB3 = \"mb-3\" # Margin Bottom MB4 = \"mb-4\" # Margin Bottom MB5 = \"mb-5\" # Margin Bottom MS1 = \"ms-1\" # Margin Start (left in LTR) MS2 = \"ms-2\" # Margin Start (left in LTR) MS3 = \"ms-3\" # Margin Start (left in LTR) MS4 = \"ms-4\" # Margin Start (left in LTR) MS5 = \"ms-5\" # Margin Start (left in LTR) ME1 = \"me-1\" # Margin End (right in LTR) ME2 = \"me-2\" # Margin End (right in LTR) ME3 = \"me-3\" # Margin End (right in LTR) ME4 = \"me-4\" # Margin End (right in LTR) ME5 = \"me-5\" # Margin End (right in LTR) M1 = \"m-1\" # Margin all sides M2 = \"m-2\" # Margin all sides M3 = \"m-3\" # Margin all sides M4 = \"m-4\" # Margin all sides M5 = \"m-5\" # Margin all sides GAP1 = \"gap-1\" GAP2 = \"gap-2\" GAP3 = \"gap-3\" GAP4 = \"gap-4\" GAP5 = \"gap-5\" AUTO_MX = \"mx-auto\" # Center horizontally","title":"Spacing"},{"location":"reference/probo/styles/frameworks/bs5/utilities/#probo.styles.frameworks.bs5.utilities.SpacingFunc","text":"Bootstrap Spacing utilities (margin and padding). Source code in src\\probo\\styles\\frameworks\\bs5\\utilities.py 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 class SpacingFunc : \"\"\"Bootstrap Spacing utilities (margin and padding).\"\"\" @staticmethod def PX ( self , value : int ): return f \"px- { value } \" # Padding on X-axis @staticmethod def PY ( self , value : int ): return f \"py- { value } \" # Padding on Y-axis @staticmethod def PT ( self , value : int ): return f \"pt- { value } \" # Padding Top @staticmethod def PB ( self , value : int ): return f \"pb- { value } \" # Padding Bottom @staticmethod def PS ( self , value : int ): return f \"ps- { value } \" # Padding Start (self,left in LTR) @staticmethod def PE ( self , value : int ): return f \"pe- { value } \" # Padding End (self,right in LTR) @staticmethod def P ( self , value : int ): return f \"p- { value } \" # Padding all sides @staticmethod def MX ( self , value : int ): return f \"mx- { value } \" # Margin on X-axis @staticmethod def MY ( self , value : int ): return f \"my- { value } \" # Margin on Y-axis @staticmethod def MT ( self , value : int ): return f \"mt- { value } \" # Margin Top @staticmethod def MB ( self , value : int ): return f \"mb- { value } \" # Margin Bottom @staticmethod def MS ( self , value : int ): return f \"ms- { value } \" # Margin Start (self,left in LTR) @staticmethod def ME ( self , value : int ): return f \"me- { value } \" # Margin End (self,right in LTR) @staticmethod def M ( self , value : int ): return f \"m- { value } \" # Margin all sides @staticmethod def AUTO_MX ( self , ): return \"mx-auto\" # Center horizontally","title":"SpacingFunc"},{"location":"reference/probo/styles/frameworks/bs5/components/accordion/","text":"accordion","title":"accordion"},{"location":"reference/probo/styles/frameworks/bs5/components/accordion/#accordion","text":"","title":"accordion"},{"location":"reference/probo/styles/frameworks/bs5/components/alert/","text":"alert","title":"alert"},{"location":"reference/probo/styles/frameworks/bs5/components/alert/#alert","text":"","title":"alert"},{"location":"reference/probo/styles/frameworks/bs5/components/badge/","text":"badge BS5Badge Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\badge.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class BS5Badge ( BS5Component ): def __init__ ( self , content , variant = \"primary\" , render_constraints = None , ** attrs ): self . variant = variant self . attrs = attrs self . render_constraints = render_constraints or {} self . content = content # self.template = self._render_comp() self . badge_classes = [ 'badge' , Background [ self . variant . upper ()] . value ] self . tag = 'span' super () . __init__ ( name = 'BS5-badge' , state_props = self . render_constraints ) def _add_parent_badge ( self , content , tag , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' comp = BS5Element ( tag , content , ** attrs ) comp . include ( self . template ) self . template . include ( comp , override = True ) return self def add_heading_badge ( self , heading_content , heading = 'h1' , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' self . _add_parent_badge ( heading_content , tag = heading , ** attrs ) return self def add_button_badge ( self , button_content , tag = 'button' , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' self . _add_parent_badge ( button_content , tag = tag , ** attrs ) return self def _render_comp ( self ): badge = BS5Element ( self . tag , self . content , classes = self . badge_classes , ** self . attrs ) return badge add_button_badge ( button_content , tag = 'button' , ** attrs ) Example heading New Source code in src\\probo\\styles\\frameworks\\bs5\\components\\badge.py 29 30 31 32 def add_button_badge ( self , button_content , tag = 'button' , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' self . _add_parent_badge ( button_content , tag = tag , ** attrs ) return self add_heading_badge ( heading_content , heading = 'h1' , ** attrs ) Example heading New Source code in src\\probo\\styles\\frameworks\\bs5\\components\\badge.py 25 26 27 28 def add_heading_badge ( self , heading_content , heading = 'h1' , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' self . _add_parent_badge ( heading_content , tag = heading , ** attrs ) return self","title":"badge"},{"location":"reference/probo/styles/frameworks/bs5/components/badge/#badge","text":"","title":"badge"},{"location":"reference/probo/styles/frameworks/bs5/components/badge/#probo.styles.frameworks.bs5.components.badge.BS5Badge","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\badge.py 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class BS5Badge ( BS5Component ): def __init__ ( self , content , variant = \"primary\" , render_constraints = None , ** attrs ): self . variant = variant self . attrs = attrs self . render_constraints = render_constraints or {} self . content = content # self.template = self._render_comp() self . badge_classes = [ 'badge' , Background [ self . variant . upper ()] . value ] self . tag = 'span' super () . __init__ ( name = 'BS5-badge' , state_props = self . render_constraints ) def _add_parent_badge ( self , content , tag , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' comp = BS5Element ( tag , content , ** attrs ) comp . include ( self . template ) self . template . include ( comp , override = True ) return self def add_heading_badge ( self , heading_content , heading = 'h1' , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' self . _add_parent_badge ( heading_content , tag = heading , ** attrs ) return self def add_button_badge ( self , button_content , tag = 'button' , ** attrs ): '''<h1>Example heading <span class=\"badge bg-secondary\">New</span></h1>''' self . _add_parent_badge ( button_content , tag = tag , ** attrs ) return self def _render_comp ( self ): badge = BS5Element ( self . tag , self . content , classes = self . badge_classes , ** self . attrs ) return badge","title":"BS5Badge"},{"location":"reference/probo/styles/frameworks/bs5/components/badge/#probo.styles.frameworks.bs5.components.badge.BS5Badge.add_button_badge","text":"","title":"add_button_badge"},{"location":"reference/probo/styles/frameworks/bs5/components/badge/#probo.styles.frameworks.bs5.components.badge.BS5Badge.add_heading_badge","text":"","title":"add_heading_badge"},{"location":"reference/probo/styles/frameworks/bs5/components/base/","text":"base BS5Component Bases: BaseComponent Base class for all Bootstrap 5 components. Source code in src\\probo\\styles\\frameworks\\bs5\\components\\base.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class BS5Component ( BaseComponent ): \"\"\" Base class for all Bootstrap 5 components. \"\"\" def __init__ ( self , name : str , state_props : dict = None , props : dict = None ,): # 1. Set the Tag (Allow override, fallback to default) self . DEFAULT_BS5_VARIANTS = [] self . STATE = None self . children = [] self . DEFAULT_ATTRS = {} if self . STATE == 'dynamic' : raise ValueError ( \"Dynamic components require a state object.\" ) self . template = self . _render_comp () if self . children : self . template . content += '' . join ( self . children ) state = None if isinstance ( state_props , dict ): state = ComponentState ( ** state_props ) super () . __init__ ( name = name , state = state , template = self . template , props = props ) def include_env_props ( self , ** props ): self . props . update ( props ) return self def add_child ( self , child ): self . children . append (( child . render () if hasattr ( child , 'render' ) else str ( child ))) return self def swap_element ( self , tag ): self . tag = tag self . template . tag = tag return self def include_content_parts ( self , * parts , first = False ): self . template . include ( * parts , first = first ) return self def _render_comp ( self , * args , ** kwargs ): \"\"\" Override in subclasses to provide component-specific rendering logic. \"\"\" raise NotImplementedError ( \"_render_comp must be implemented in subclasses.\" ) BaseComponent Bases: Component The Single Source of Truth. Handles: 1. HTML Generation (render) 2. Attribute Management (id, class, data-*) 3. Content Nesting (children) Source code in src\\probo\\styles\\frameworks\\bs5\\components\\base.py 5 6 7 8 9 10 11 12 13 14 15 16 class BaseComponent ( Component ): \"\"\" The Single Source of Truth. Handles: 1. HTML Generation (render) 2. Attribute Management (id, class, data-*) 3. Content Nesting (children) \"\"\" def __init__ ( self , name : str , state : 'ComponentState' = None , template : str = str (), props : dict = None ,): # 1. Set the Tag (Allow override, fallback to default) super () . __init__ ( name = name , state = state , template = template , props = props )","title":"base"},{"location":"reference/probo/styles/frameworks/bs5/components/base/#base","text":"","title":"base"},{"location":"reference/probo/styles/frameworks/bs5/components/base/#probo.styles.frameworks.bs5.components.base.BS5Component","text":"Bases: BaseComponent Base class for all Bootstrap 5 components. Source code in src\\probo\\styles\\frameworks\\bs5\\components\\base.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class BS5Component ( BaseComponent ): \"\"\" Base class for all Bootstrap 5 components. \"\"\" def __init__ ( self , name : str , state_props : dict = None , props : dict = None ,): # 1. Set the Tag (Allow override, fallback to default) self . DEFAULT_BS5_VARIANTS = [] self . STATE = None self . children = [] self . DEFAULT_ATTRS = {} if self . STATE == 'dynamic' : raise ValueError ( \"Dynamic components require a state object.\" ) self . template = self . _render_comp () if self . children : self . template . content += '' . join ( self . children ) state = None if isinstance ( state_props , dict ): state = ComponentState ( ** state_props ) super () . __init__ ( name = name , state = state , template = self . template , props = props ) def include_env_props ( self , ** props ): self . props . update ( props ) return self def add_child ( self , child ): self . children . append (( child . render () if hasattr ( child , 'render' ) else str ( child ))) return self def swap_element ( self , tag ): self . tag = tag self . template . tag = tag return self def include_content_parts ( self , * parts , first = False ): self . template . include ( * parts , first = first ) return self def _render_comp ( self , * args , ** kwargs ): \"\"\" Override in subclasses to provide component-specific rendering logic. \"\"\" raise NotImplementedError ( \"_render_comp must be implemented in subclasses.\" )","title":"BS5Component"},{"location":"reference/probo/styles/frameworks/bs5/components/base/#probo.styles.frameworks.bs5.components.base.BaseComponent","text":"Bases: Component The Single Source of Truth. Handles: 1. HTML Generation (render) 2. Attribute Management (id, class, data-*) 3. Content Nesting (children) Source code in src\\probo\\styles\\frameworks\\bs5\\components\\base.py 5 6 7 8 9 10 11 12 13 14 15 16 class BaseComponent ( Component ): \"\"\" The Single Source of Truth. Handles: 1. HTML Generation (render) 2. Attribute Management (id, class, data-*) 3. Content Nesting (children) \"\"\" def __init__ ( self , name : str , state : 'ComponentState' = None , template : str = str (), props : dict = None ,): # 1. Set the Tag (Allow override, fallback to default) super () . __init__ ( name = name , state = state , template = template , props = props )","title":"BaseComponent"},{"location":"reference/probo/styles/frameworks/bs5/components/breadcrumb/","text":"breadcrumb BS5Breadcrumb Bases: BS5Component Home Library Data Source code in src\\probo\\styles\\frameworks\\bs5\\components\\breadcrumb.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class BS5Breadcrumb ( BS5Component ): ''' <nav aria-label=\"breadcrumb\"> <ol class=\"breadcrumb\"> <li class=\"breadcrumb-item active \"aria-current=\"page\"><a href=\"#\">Home</a></li> <li class=\"breadcrumb-item\"><a href=\"#\">Library</a></li> <li class=\"breadcrumb-item \" >Data</li> </ol> </nav> ''' def __init__ ( self , * urls , url_dict = None , render_constraints = None , ** attrs ): self . url_dict : dict = url_dict or {} self . attrs = attrs self . urls = urls self . render_constraints = render_constraints or {} # self.template = self._render_comp() self . breadcrum_classes = [ Breadcrumb . BASE . value ] self . tag = 'ol' self . nav_attrs = { 'aria-label' : \"breadcrumb\" } super () . __init__ ( name = 'BS5-breadcrum' , state_props = self . render_constraints ) def _render_comp ( self ): links_dict = {} if self . urls : links_dict = { link : '#' for link in self . urls [ 0 : - 1 ]} if self . url_dict : links_dict = self . url_dict if links_dict : links = [ BS5Element ( 'li' , BS5Element ( 'a' , link_name , href = link_url ) . render (), classes = [ Breadcrumb . ITEM . value ], ) for link_name , link_url in links_dict . items ()] links . append ( BS5Element ( 'li' , self . urls [ - 1 ], classes = [ Breadcrumb . ITEM . value ], ) ) links [ - 1 ] . classes . append ( 'active' ) links [ - 1 ] . attrs . update ({ 'aria-current' : \"page\" }) else : links = [] breadcrum = BS5Element ( self . tag , classes = self . breadcrum_classes , ** self . attrs ) breadcrum . include ( * links ) nav = BS5Element ( 'nav' , ** self . nav_attrs ) return nav . include ( breadcrum )","title":"breadcrumb"},{"location":"reference/probo/styles/frameworks/bs5/components/breadcrumb/#breadcrumb","text":"","title":"breadcrumb"},{"location":"reference/probo/styles/frameworks/bs5/components/breadcrumb/#probo.styles.frameworks.bs5.components.breadcrumb.BS5Breadcrumb","text":"Bases: BS5Component Home Library Data Source code in src\\probo\\styles\\frameworks\\bs5\\components\\breadcrumb.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class BS5Breadcrumb ( BS5Component ): ''' <nav aria-label=\"breadcrumb\"> <ol class=\"breadcrumb\"> <li class=\"breadcrumb-item active \"aria-current=\"page\"><a href=\"#\">Home</a></li> <li class=\"breadcrumb-item\"><a href=\"#\">Library</a></li> <li class=\"breadcrumb-item \" >Data</li> </ol> </nav> ''' def __init__ ( self , * urls , url_dict = None , render_constraints = None , ** attrs ): self . url_dict : dict = url_dict or {} self . attrs = attrs self . urls = urls self . render_constraints = render_constraints or {} # self.template = self._render_comp() self . breadcrum_classes = [ Breadcrumb . BASE . value ] self . tag = 'ol' self . nav_attrs = { 'aria-label' : \"breadcrumb\" } super () . __init__ ( name = 'BS5-breadcrum' , state_props = self . render_constraints ) def _render_comp ( self ): links_dict = {} if self . urls : links_dict = { link : '#' for link in self . urls [ 0 : - 1 ]} if self . url_dict : links_dict = self . url_dict if links_dict : links = [ BS5Element ( 'li' , BS5Element ( 'a' , link_name , href = link_url ) . render (), classes = [ Breadcrumb . ITEM . value ], ) for link_name , link_url in links_dict . items ()] links . append ( BS5Element ( 'li' , self . urls [ - 1 ], classes = [ Breadcrumb . ITEM . value ], ) ) links [ - 1 ] . classes . append ( 'active' ) links [ - 1 ] . attrs . update ({ 'aria-current' : \"page\" }) else : links = [] breadcrum = BS5Element ( self . tag , classes = self . breadcrum_classes , ** self . attrs ) breadcrum . include ( * links ) nav = BS5Element ( 'nav' , ** self . nav_attrs ) return nav . include ( breadcrum )","title":"BS5Breadcrumb"},{"location":"reference/probo/styles/frameworks/bs5/components/button/","text":"button BS5ButtonGroup Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\button.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class BS5ButtonGroup ( BS5Component ): def __init__ ( self , * btns , variant = 'horizontal' , size = 'default' , render_constaints = None , ** attrs ): self . btn_grp_cntnt = {} self . attrs = attrs self . attrs . update ({ 'role' : \"group\" }) self . size = size self . render_constaints = render_constaints self . tag = 'div' self . btn_group_classes = [( \"btn-group-vertical\" if variant == \"vertical\" else \"btn-group\" ),] self . variant = variant self . btns = list ( btns ) if self . size in [ 'sm' , 'lg' ]: self . btn_group_classes . append ( Button [ f 'group_ { self . size } ' . upper ()] . value ) super () . __init__ ( name = 'BS5-button-group' , state_props = self . render_constaints ) @property def lg ( self ): self . btn_group_classes . append ( Button . LG . value ) self . template . add ( Button . LG . value ) return self @property def sm ( self ): self . btn_group_classes . append ( Button . SM . value ) self . template . add ( Button . SM . value ) return self def before_render ( self , * args , ** kwargs ): self . include_content_parts ( * self . btns ) return self def add_btn ( self , content , variant = \"primary\" , size = 'default' , ** attrs ): btn = BS5Button ( content , variant = variant , size = size , ** attrs ) self . btns . append ( btn . render ()) return self def add_check_box_btn ( self , content , variant = \"primary\" , size = 'default' , override_input_attr : dict [ str , str ] = dict (), ** attrs ): ''' <input type=\"checkbox\" class=\"btn-check\" id=\"btncheck1\" autocomplete=\"off\"> <label class=\"btn btn-outline-primary\" for=\"btncheck1\">Checkbox 1</label> ''' if not override_input_attr : bs5_input_attrs = { \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" } else : override_input_attr . update ({ \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" }) bs5_input_attrs = override_input_attr bs5_input = BS5Element ( 'input' , classes = [ \"btn-check\" ], ** bs5_input_attrs ) btn = BS5Button ( content , variant = variant , size = size , ** attrs ) btn . swap_element ( 'label' ) self . btns . append ( f ' { bs5_input . render () }{ btn . render () } ' ) return self def _render_comp ( self ): attrs = { 'Type' : 'button' ,} attrs . update ( self . attrs ) btn_grp = BS5Element ( self . tag , '' . join ( self . btns ), classes = self . btn_group_classes , ** attrs ) return btn_grp add_check_box_btn ( content , variant = 'primary' , size = 'default' , override_input_attr = dict (), ** attrs ) Checkbox 1 Source code in src\\probo\\styles\\frameworks\\bs5\\components\\button.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def add_check_box_btn ( self , content , variant = \"primary\" , size = 'default' , override_input_attr : dict [ str , str ] = dict (), ** attrs ): ''' <input type=\"checkbox\" class=\"btn-check\" id=\"btncheck1\" autocomplete=\"off\"> <label class=\"btn btn-outline-primary\" for=\"btncheck1\">Checkbox 1</label> ''' if not override_input_attr : bs5_input_attrs = { \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" } else : override_input_attr . update ({ \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" }) bs5_input_attrs = override_input_attr bs5_input = BS5Element ( 'input' , classes = [ \"btn-check\" ], ** bs5_input_attrs ) btn = BS5Button ( content , variant = variant , size = size , ** attrs ) btn . swap_element ( 'label' ) self . btns . append ( f ' { bs5_input . render () }{ btn . render () } ' ) return self BS5CloseButton Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\button.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class BS5CloseButton ( BS5Component ): ''' <button type=\"button\" class=\"btn-close\" aria-label=\"Close\"></button> <button type=\"button\" class=\"btn-close\" disabled aria-label=\"Close\"></button> <button type=\"button\" class=\"btn-close btn-close-white\" aria-label=\"Close\"></button> <button type=\"button\" class=\"btn-close btn-close-white\" disabled aria-label=\"Close\"></button> ''' def __init__ ( self , variant = \"base\" , render_constaints = None , ** attrs ): self . variant = variant self . attrs = attrs self . render_constaints = render_constaints self . btn_classes = [ 'btn-close' ] self . attrs . update ({ \"type\" : \"button\" , \"aria-label\" : \"Close\" }) if variant == 'white' : self . btn_classes . append ( 'btn-close-white' ) self . tag = 'button' super () . __init__ ( name = 'BS5-close-button' , state_props = self . render_constaints ) def _render_comp ( self ): button = BS5Element ( self . tag , # self.content, classes = self . btn_classes , ** self . attrs ) return button","title":"button"},{"location":"reference/probo/styles/frameworks/bs5/components/button/#button","text":"","title":"button"},{"location":"reference/probo/styles/frameworks/bs5/components/button/#probo.styles.frameworks.bs5.components.button.BS5ButtonGroup","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\button.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 class BS5ButtonGroup ( BS5Component ): def __init__ ( self , * btns , variant = 'horizontal' , size = 'default' , render_constaints = None , ** attrs ): self . btn_grp_cntnt = {} self . attrs = attrs self . attrs . update ({ 'role' : \"group\" }) self . size = size self . render_constaints = render_constaints self . tag = 'div' self . btn_group_classes = [( \"btn-group-vertical\" if variant == \"vertical\" else \"btn-group\" ),] self . variant = variant self . btns = list ( btns ) if self . size in [ 'sm' , 'lg' ]: self . btn_group_classes . append ( Button [ f 'group_ { self . size } ' . upper ()] . value ) super () . __init__ ( name = 'BS5-button-group' , state_props = self . render_constaints ) @property def lg ( self ): self . btn_group_classes . append ( Button . LG . value ) self . template . add ( Button . LG . value ) return self @property def sm ( self ): self . btn_group_classes . append ( Button . SM . value ) self . template . add ( Button . SM . value ) return self def before_render ( self , * args , ** kwargs ): self . include_content_parts ( * self . btns ) return self def add_btn ( self , content , variant = \"primary\" , size = 'default' , ** attrs ): btn = BS5Button ( content , variant = variant , size = size , ** attrs ) self . btns . append ( btn . render ()) return self def add_check_box_btn ( self , content , variant = \"primary\" , size = 'default' , override_input_attr : dict [ str , str ] = dict (), ** attrs ): ''' <input type=\"checkbox\" class=\"btn-check\" id=\"btncheck1\" autocomplete=\"off\"> <label class=\"btn btn-outline-primary\" for=\"btncheck1\">Checkbox 1</label> ''' if not override_input_attr : bs5_input_attrs = { \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" } else : override_input_attr . update ({ \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" }) bs5_input_attrs = override_input_attr bs5_input = BS5Element ( 'input' , classes = [ \"btn-check\" ], ** bs5_input_attrs ) btn = BS5Button ( content , variant = variant , size = size , ** attrs ) btn . swap_element ( 'label' ) self . btns . append ( f ' { bs5_input . render () }{ btn . render () } ' ) return self def _render_comp ( self ): attrs = { 'Type' : 'button' ,} attrs . update ( self . attrs ) btn_grp = BS5Element ( self . tag , '' . join ( self . btns ), classes = self . btn_group_classes , ** attrs ) return btn_grp","title":"BS5ButtonGroup"},{"location":"reference/probo/styles/frameworks/bs5/components/button/#probo.styles.frameworks.bs5.components.button.BS5ButtonGroup.add_check_box_btn","text":"Checkbox 1 Source code in src\\probo\\styles\\frameworks\\bs5\\components\\button.py 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 def add_check_box_btn ( self , content , variant = \"primary\" , size = 'default' , override_input_attr : dict [ str , str ] = dict (), ** attrs ): ''' <input type=\"checkbox\" class=\"btn-check\" id=\"btncheck1\" autocomplete=\"off\"> <label class=\"btn btn-outline-primary\" for=\"btncheck1\">Checkbox 1</label> ''' if not override_input_attr : bs5_input_attrs = { \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" } else : override_input_attr . update ({ \"type\" : \"checkbox\" , \"id\" : attrs . get ( 'for' , None ), \"autocomplete\" : \"off\" }) bs5_input_attrs = override_input_attr bs5_input = BS5Element ( 'input' , classes = [ \"btn-check\" ], ** bs5_input_attrs ) btn = BS5Button ( content , variant = variant , size = size , ** attrs ) btn . swap_element ( 'label' ) self . btns . append ( f ' { bs5_input . render () }{ btn . render () } ' ) return self","title":"add_check_box_btn"},{"location":"reference/probo/styles/frameworks/bs5/components/button/#probo.styles.frameworks.bs5.components.button.BS5CloseButton","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\button.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class BS5CloseButton ( BS5Component ): ''' <button type=\"button\" class=\"btn-close\" aria-label=\"Close\"></button> <button type=\"button\" class=\"btn-close\" disabled aria-label=\"Close\"></button> <button type=\"button\" class=\"btn-close btn-close-white\" aria-label=\"Close\"></button> <button type=\"button\" class=\"btn-close btn-close-white\" disabled aria-label=\"Close\"></button> ''' def __init__ ( self , variant = \"base\" , render_constaints = None , ** attrs ): self . variant = variant self . attrs = attrs self . render_constaints = render_constaints self . btn_classes = [ 'btn-close' ] self . attrs . update ({ \"type\" : \"button\" , \"aria-label\" : \"Close\" }) if variant == 'white' : self . btn_classes . append ( 'btn-close-white' ) self . tag = 'button' super () . __init__ ( name = 'BS5-close-button' , state_props = self . render_constaints ) def _render_comp ( self ): button = BS5Element ( self . tag , # self.content, classes = self . btn_classes , ** self . attrs ) return button","title":"BS5CloseButton"},{"location":"reference/probo/styles/frameworks/bs5/components/card/","text":"card BS5Card Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\card.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class BS5Card ( BS5Component ): '''''' def __init__ ( self , card_header = None , card_image = None , card_body = None , card_footer = None , render_constraints = None , is_image_bottom = False , ** attrs ): self . attrs = attrs self . is_image_bottom = is_image_bottom self . card_header = card_header self . card_body = card_body self . card_footer = card_footer self . render_constraints = render_constraints or {} # self.template = self._render_comp() self . card_image = card_image self . card_classes = [ Cards . CARD . value ] self . tag = 'div' self . body_children = [] super () . __init__ ( name = 'BS5-card' , state_props = self . render_constraints ) def add_card_title ( self , title : str , tag = 'h1' , ** attrs ): card_title = BS5Element ( tag , title , classes = [ 'card-title' ], ** attrs ) self . body_children . append ( card_title . render ()) return self def add_card_sub_title ( self , sub_title : str , tag = 'h1' , ** attrs ): card_sub_title = BS5Element ( tag , sub_title , classes = [ 'card-subtitle' ], ** attrs ) self . body_children . append ( card_sub_title . render ()) return self def add_card_text ( self , text : str , tag = 'p' , ** attrs ): card_text = BS5Element ( tag , text , classes = [ 'card-text' ], ** attrs ) self . body_children . append ( card_text . render ()) return self def add_card_link ( self , link : str , tag = 'a' , ** attrs ): card_link = BS5Element ( tag , link , classes = [ 'card-link' ], ** attrs ) self . body_children . append ( card_link . render ()) return self def add_card_body ( self , card_body , override = False , ** attrs ): body = BS5Element ( 'div' , card_body , classes = [ Cards . CARD_BODY . value ], ** attrs ) body . include ( * self . body_children ) if self . card_body and not override : self . card_body += body . render () else : self . card_body = body . render () return self def add_card_header ( self , card_header , override = False , ** attrs ): header = BS5Element ( 'div' , card_header , classes = [ Cards . CARD_HEADER . value ], ** attrs ) if self . card_header and not override : self . card_header += header . render () else : self . card_header = header . render () return self def add_card_footer ( self , card_footer , override = False , ** attrs ): footer = BS5Element ( 'div' , card_footer , classes = [ Cards . CARD_FOOTER . value ], ** attrs ) if self . card_footer and not override : self . card_footer += footer . render () else : self . card_footer = footer . render () return self def add_card_image ( self , src_url , override = False , ** attrs ): img = BS5Element ( 'img' , classes = [( Cards . CARD_IMG_BOTTOM . value if self . is_image_bottom else Cards . CARD_IMG_TOP . value )], src = src_url ) if self . card_image and not override : self . card_image += img . render () else : self . card_image = img . render () return self def before_render ( self , ** props ): if self . card_body : if not self . body_children : self . body_children . append ( self . card_body ) if self . is_image_bottom : parts = [ x for x in [ self . card_header , * self . body_children , self . card_footer , self . card_image ] if x is not None ] else : parts = [ x for x in [ self . card_header , self . card_image , * self . body_children , self . card_footer ] if x is not None ] self . include_content_parts ( * parts ) def _render_comp ( self ): if self . card_header : self . add_card_header ( self . card_header , override = True ) if self . card_image : self . add_card_image ( self . card_image , override = True ) if self . card_body : self . add_card_body ( self . card_body , override = True ) if self . card_footer : self . add_card_footer ( self . card_footer , override = True ) if self . is_image_bottom : parts = [ x for x in [ self . card_header , * self . body_children , self . card_footer , self . card_image ] if x is not None ] else : parts = [ x for x in [ self . card_header , self . card_image , * self . body_children , self . card_footer ] if x is not None ] card = BS5Element ( self . tag , '' . join ( parts ), classes = self . card_classes , ** self . attrs ) return card","title":"card"},{"location":"reference/probo/styles/frameworks/bs5/components/card/#card","text":"","title":"card"},{"location":"reference/probo/styles/frameworks/bs5/components/card/#probo.styles.frameworks.bs5.components.card.BS5Card","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\card.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 class BS5Card ( BS5Component ): '''''' def __init__ ( self , card_header = None , card_image = None , card_body = None , card_footer = None , render_constraints = None , is_image_bottom = False , ** attrs ): self . attrs = attrs self . is_image_bottom = is_image_bottom self . card_header = card_header self . card_body = card_body self . card_footer = card_footer self . render_constraints = render_constraints or {} # self.template = self._render_comp() self . card_image = card_image self . card_classes = [ Cards . CARD . value ] self . tag = 'div' self . body_children = [] super () . __init__ ( name = 'BS5-card' , state_props = self . render_constraints ) def add_card_title ( self , title : str , tag = 'h1' , ** attrs ): card_title = BS5Element ( tag , title , classes = [ 'card-title' ], ** attrs ) self . body_children . append ( card_title . render ()) return self def add_card_sub_title ( self , sub_title : str , tag = 'h1' , ** attrs ): card_sub_title = BS5Element ( tag , sub_title , classes = [ 'card-subtitle' ], ** attrs ) self . body_children . append ( card_sub_title . render ()) return self def add_card_text ( self , text : str , tag = 'p' , ** attrs ): card_text = BS5Element ( tag , text , classes = [ 'card-text' ], ** attrs ) self . body_children . append ( card_text . render ()) return self def add_card_link ( self , link : str , tag = 'a' , ** attrs ): card_link = BS5Element ( tag , link , classes = [ 'card-link' ], ** attrs ) self . body_children . append ( card_link . render ()) return self def add_card_body ( self , card_body , override = False , ** attrs ): body = BS5Element ( 'div' , card_body , classes = [ Cards . CARD_BODY . value ], ** attrs ) body . include ( * self . body_children ) if self . card_body and not override : self . card_body += body . render () else : self . card_body = body . render () return self def add_card_header ( self , card_header , override = False , ** attrs ): header = BS5Element ( 'div' , card_header , classes = [ Cards . CARD_HEADER . value ], ** attrs ) if self . card_header and not override : self . card_header += header . render () else : self . card_header = header . render () return self def add_card_footer ( self , card_footer , override = False , ** attrs ): footer = BS5Element ( 'div' , card_footer , classes = [ Cards . CARD_FOOTER . value ], ** attrs ) if self . card_footer and not override : self . card_footer += footer . render () else : self . card_footer = footer . render () return self def add_card_image ( self , src_url , override = False , ** attrs ): img = BS5Element ( 'img' , classes = [( Cards . CARD_IMG_BOTTOM . value if self . is_image_bottom else Cards . CARD_IMG_TOP . value )], src = src_url ) if self . card_image and not override : self . card_image += img . render () else : self . card_image = img . render () return self def before_render ( self , ** props ): if self . card_body : if not self . body_children : self . body_children . append ( self . card_body ) if self . is_image_bottom : parts = [ x for x in [ self . card_header , * self . body_children , self . card_footer , self . card_image ] if x is not None ] else : parts = [ x for x in [ self . card_header , self . card_image , * self . body_children , self . card_footer ] if x is not None ] self . include_content_parts ( * parts ) def _render_comp ( self ): if self . card_header : self . add_card_header ( self . card_header , override = True ) if self . card_image : self . add_card_image ( self . card_image , override = True ) if self . card_body : self . add_card_body ( self . card_body , override = True ) if self . card_footer : self . add_card_footer ( self . card_footer , override = True ) if self . is_image_bottom : parts = [ x for x in [ self . card_header , * self . body_children , self . card_footer , self . card_image ] if x is not None ] else : parts = [ x for x in [ self . card_header , self . card_image , * self . body_children , self . card_footer ] if x is not None ] card = BS5Element ( self . tag , '' . join ( parts ), classes = self . card_classes , ** self . attrs ) return card","title":"BS5Card"},{"location":"reference/probo/styles/frameworks/bs5/components/carousel/","text":"carousel BS5Carousel Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\carousel.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class BS5Carousel ( BS5Component ): def __init__ ( self , * carousel_items , variant = 'light' , render_constraints = None , ** attrs ): self . attrs = attrs self . variant = variant self . render_constraints = render_constraints self . carousel_items = list () if not carousel_items else [ self . add_carousel_item ( item , return_item = True ) for item in carousel_items ] if self . carousel_items : if 'active' not in self . carousel_items [ 0 ] . classes : self . carousel_items [ 0 ] . classes . append ( 'active' ) # self.template = self._render_comp() self . btn_classes = [ Carousel [ self . variant . upper ()] . value if self . variant . upper () in Carousel else Carousel . CAROUSEL . value ] self . carousel_control_prev = str () self . carousel_control_next = str () self . carousel_indicators = str () self . tag = 'div' super () . __init__ ( name = 'BS5-carousel' , state_props = self . render_constraints ) def add_carousel_item ( self , content , carousel_caption = None , caption_attrs = None , return_item = False , ** attrs ): item = BS5Element ( 'div' , content , classes = [ 'carousel-item' ], ** attrs ) if carousel_caption : item_caption = BS5Element ( 'div' , carousel_caption , classes = [ 'carousel-caption' ], ** ( caption_attrs if caption_attrs else dict ()) ) item . include ( item_caption ) if return_item : return item self . carousel_items . append ( item ) return self def add_carousel_controls ( self ,): ''' <button class=\"carousel-control-prev\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"prev\"> <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Previous</span> </button> <button class=\"carousel-control-next\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"next\"> <span class=\"carousel-control-next-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Next</span> </button> ''' control_prev = BS5Element ( 'button' , classes = [ 'carousel-control-prev' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'prev' ) control_prev . include ( BS5Element ( 'span' , classes = [ 'carousel-control-prev-icon' ], aria_hidden = 'true' )) control_prev . include ( BS5Element ( 'span' , 'Previous' , classes = [ 'visually-hidden' ])) control_next = BS5Element ( 'button' , classes = [ 'carousel-control-next' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'next' ) control_next . include ( BS5Element ( 'span' , classes = [ 'carousel-control-next-icon' ], aria_hidden = 'true' )) control_next . include ( BS5Element ( 'span' , 'Next' , classes = [ 'visually-hidden' ])) self . carousel_control_prev = control_prev . render () self . carousel_control_next = control_next . render () return self def add_carousel_indicators ( self ,): ''' <div class=\"carousel-indicators\"> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"0\" class=\"active\" aria-current=\"true\" aria-label=\"Slide 1\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"1\" aria-label=\"Slide 2\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"2\" aria-label=\"Slide 3\"></button> </div> ''' indicators = BS5Element ( 'div' , classes = [ 'carousel-indicators' ] ) indicators_list = [ BS5Element ( 'button' , Type = \"button\" , data_bs_target = f \"# { self . attrs . get ( 'Id' , '' ) } \" , data_bs_slide_to = str ( indx ), aria_label = f \"Slide { indx + 1 } \" , ) for indx in range ( len ( self . carousel_items )) ] indicators_list [ 0 ] . attrs [ 'class' ] = \"active\" indicators . include ( * indicators_list ) self . carousel_indicators = indicators . render () return self def before_render ( self , ** props ): carousel_inner = BS5Element ( 'div' , classes = [ 'carousel-inner' ], ) . include ( * self . carousel_items ) . render () self . include_content_parts ( self . carousel_indicators , carousel_inner , self . carousel_control_prev , self . carousel_control_next ) def _render_comp ( self ): carousel = BS5Element ( self . tag , classes = [ 'carousel' , 'slide' ], data_bs_ride = \"carousel\" , ** self . attrs ) return carousel add_carousel_controls () Previous Next Source code in src\\probo\\styles\\frameworks\\bs5\\components\\carousel.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def add_carousel_controls ( self ,): ''' <button class=\"carousel-control-prev\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"prev\"> <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Previous</span> </button> <button class=\"carousel-control-next\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"next\"> <span class=\"carousel-control-next-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Next</span> </button> ''' control_prev = BS5Element ( 'button' , classes = [ 'carousel-control-prev' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'prev' ) control_prev . include ( BS5Element ( 'span' , classes = [ 'carousel-control-prev-icon' ], aria_hidden = 'true' )) control_prev . include ( BS5Element ( 'span' , 'Previous' , classes = [ 'visually-hidden' ])) control_next = BS5Element ( 'button' , classes = [ 'carousel-control-next' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'next' ) control_next . include ( BS5Element ( 'span' , classes = [ 'carousel-control-next-icon' ], aria_hidden = 'true' )) control_next . include ( BS5Element ( 'span' , 'Next' , classes = [ 'visually-hidden' ])) self . carousel_control_prev = control_prev . render () self . carousel_control_next = control_next . render () return self add_carousel_indicators () Source code in src\\probo\\styles\\frameworks\\bs5\\components\\carousel.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def add_carousel_indicators ( self ,): ''' <div class=\"carousel-indicators\"> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"0\" class=\"active\" aria-current=\"true\" aria-label=\"Slide 1\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"1\" aria-label=\"Slide 2\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"2\" aria-label=\"Slide 3\"></button> </div> ''' indicators = BS5Element ( 'div' , classes = [ 'carousel-indicators' ] ) indicators_list = [ BS5Element ( 'button' , Type = \"button\" , data_bs_target = f \"# { self . attrs . get ( 'Id' , '' ) } \" , data_bs_slide_to = str ( indx ), aria_label = f \"Slide { indx + 1 } \" , ) for indx in range ( len ( self . carousel_items )) ] indicators_list [ 0 ] . attrs [ 'class' ] = \"active\" indicators . include ( * indicators_list ) self . carousel_indicators = indicators . render () return self","title":"carousel"},{"location":"reference/probo/styles/frameworks/bs5/components/carousel/#carousel","text":"","title":"carousel"},{"location":"reference/probo/styles/frameworks/bs5/components/carousel/#probo.styles.frameworks.bs5.components.carousel.BS5Carousel","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\carousel.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 class BS5Carousel ( BS5Component ): def __init__ ( self , * carousel_items , variant = 'light' , render_constraints = None , ** attrs ): self . attrs = attrs self . variant = variant self . render_constraints = render_constraints self . carousel_items = list () if not carousel_items else [ self . add_carousel_item ( item , return_item = True ) for item in carousel_items ] if self . carousel_items : if 'active' not in self . carousel_items [ 0 ] . classes : self . carousel_items [ 0 ] . classes . append ( 'active' ) # self.template = self._render_comp() self . btn_classes = [ Carousel [ self . variant . upper ()] . value if self . variant . upper () in Carousel else Carousel . CAROUSEL . value ] self . carousel_control_prev = str () self . carousel_control_next = str () self . carousel_indicators = str () self . tag = 'div' super () . __init__ ( name = 'BS5-carousel' , state_props = self . render_constraints ) def add_carousel_item ( self , content , carousel_caption = None , caption_attrs = None , return_item = False , ** attrs ): item = BS5Element ( 'div' , content , classes = [ 'carousel-item' ], ** attrs ) if carousel_caption : item_caption = BS5Element ( 'div' , carousel_caption , classes = [ 'carousel-caption' ], ** ( caption_attrs if caption_attrs else dict ()) ) item . include ( item_caption ) if return_item : return item self . carousel_items . append ( item ) return self def add_carousel_controls ( self ,): ''' <button class=\"carousel-control-prev\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"prev\"> <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Previous</span> </button> <button class=\"carousel-control-next\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"next\"> <span class=\"carousel-control-next-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Next</span> </button> ''' control_prev = BS5Element ( 'button' , classes = [ 'carousel-control-prev' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'prev' ) control_prev . include ( BS5Element ( 'span' , classes = [ 'carousel-control-prev-icon' ], aria_hidden = 'true' )) control_prev . include ( BS5Element ( 'span' , 'Previous' , classes = [ 'visually-hidden' ])) control_next = BS5Element ( 'button' , classes = [ 'carousel-control-next' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'next' ) control_next . include ( BS5Element ( 'span' , classes = [ 'carousel-control-next-icon' ], aria_hidden = 'true' )) control_next . include ( BS5Element ( 'span' , 'Next' , classes = [ 'visually-hidden' ])) self . carousel_control_prev = control_prev . render () self . carousel_control_next = control_next . render () return self def add_carousel_indicators ( self ,): ''' <div class=\"carousel-indicators\"> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"0\" class=\"active\" aria-current=\"true\" aria-label=\"Slide 1\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"1\" aria-label=\"Slide 2\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"2\" aria-label=\"Slide 3\"></button> </div> ''' indicators = BS5Element ( 'div' , classes = [ 'carousel-indicators' ] ) indicators_list = [ BS5Element ( 'button' , Type = \"button\" , data_bs_target = f \"# { self . attrs . get ( 'Id' , '' ) } \" , data_bs_slide_to = str ( indx ), aria_label = f \"Slide { indx + 1 } \" , ) for indx in range ( len ( self . carousel_items )) ] indicators_list [ 0 ] . attrs [ 'class' ] = \"active\" indicators . include ( * indicators_list ) self . carousel_indicators = indicators . render () return self def before_render ( self , ** props ): carousel_inner = BS5Element ( 'div' , classes = [ 'carousel-inner' ], ) . include ( * self . carousel_items ) . render () self . include_content_parts ( self . carousel_indicators , carousel_inner , self . carousel_control_prev , self . carousel_control_next ) def _render_comp ( self ): carousel = BS5Element ( self . tag , classes = [ 'carousel' , 'slide' ], data_bs_ride = \"carousel\" , ** self . attrs ) return carousel","title":"BS5Carousel"},{"location":"reference/probo/styles/frameworks/bs5/components/carousel/#probo.styles.frameworks.bs5.components.carousel.BS5Carousel.add_carousel_controls","text":"Previous Next Source code in src\\probo\\styles\\frameworks\\bs5\\components\\carousel.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 def add_carousel_controls ( self ,): ''' <button class=\"carousel-control-prev\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"prev\"> <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Previous</span> </button> <button class=\"carousel-control-next\" type=\"button\" data-bs-target=\"#carouselExampleDark\" data-bs-slide=\"next\"> <span class=\"carousel-control-next-icon\" aria-hidden=\"true\"></span> <span class=\"visually-hidden\">Next</span> </button> ''' control_prev = BS5Element ( 'button' , classes = [ 'carousel-control-prev' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'prev' ) control_prev . include ( BS5Element ( 'span' , classes = [ 'carousel-control-prev-icon' ], aria_hidden = 'true' )) control_prev . include ( BS5Element ( 'span' , 'Previous' , classes = [ 'visually-hidden' ])) control_next = BS5Element ( 'button' , classes = [ 'carousel-control-next' ], Type = 'button' , data_bs_target = '#carouselExampleDark' , data_bs_slide = 'next' ) control_next . include ( BS5Element ( 'span' , classes = [ 'carousel-control-next-icon' ], aria_hidden = 'true' )) control_next . include ( BS5Element ( 'span' , 'Next' , classes = [ 'visually-hidden' ])) self . carousel_control_prev = control_prev . render () self . carousel_control_next = control_next . render () return self","title":"add_carousel_controls"},{"location":"reference/probo/styles/frameworks/bs5/components/carousel/#probo.styles.frameworks.bs5.components.carousel.BS5Carousel.add_carousel_indicators","text":"Source code in src\\probo\\styles\\frameworks\\bs5\\components\\carousel.py 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def add_carousel_indicators ( self ,): ''' <div class=\"carousel-indicators\"> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"0\" class=\"active\" aria-current=\"true\" aria-label=\"Slide 1\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"1\" aria-label=\"Slide 2\"></button> <button type=\"button\" data-bs-target=\"#carouselExampleIndicators\" data-bs-slide-to=\"2\" aria-label=\"Slide 3\"></button> </div> ''' indicators = BS5Element ( 'div' , classes = [ 'carousel-indicators' ] ) indicators_list = [ BS5Element ( 'button' , Type = \"button\" , data_bs_target = f \"# { self . attrs . get ( 'Id' , '' ) } \" , data_bs_slide_to = str ( indx ), aria_label = f \"Slide { indx + 1 } \" , ) for indx in range ( len ( self . carousel_items )) ] indicators_list [ 0 ] . attrs [ 'class' ] = \"active\" indicators . include ( * indicators_list ) self . carousel_indicators = indicators . render () return self","title":"add_carousel_indicators"},{"location":"reference/probo/styles/frameworks/bs5/components/collapse/","text":"collapse","title":"collapse"},{"location":"reference/probo/styles/frameworks/bs5/components/collapse/#collapse","text":"","title":"collapse"},{"location":"reference/probo/styles/frameworks/bs5/components/dropdown/","text":"dropdown BS5Dropdown Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\dropdown.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class BS5Dropdown ( BS5Component ): '''''' def __init__ ( self , render_constraints = None , is_btn_group = False , escape_btn = False , ** attrs ): self . attrs = attrs self . is_btn_group = is_btn_group self . render_constraints = render_constraints self . dropdown_btn = None self . escape_btn = escape_btn self . dropdown_menu = None self . tag = 'div' super () . __init__ ( name = 'BS5-dropdown' , state_props = self . render_constraints ) def add_btn ( self , content , ** attrs ): btn = BS5Element ( 'button' , content , classes = [ Dropdowns . DROPDOWN_TOGGLE . value ,], Type = \"button\" , data_bs_toggle = \"dropdown\" , aria_expanded = \"false\" , ** attrs ) self . dropdown_btn = btn . render () return self def add_menu ( self , * items_content , items_attrs = None , ** attrs ): '''items_attrs must be {index[int]:attrs_dict,}''' menu = BS5Element ( 'ul' , classes = [ Dropdowns . DROPDOWN_MENU . value ,], ** attrs ) if items_attrs : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ** items_attrs [ indx ] ) for indx , content in enumerate ( items_content )] else : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ) for content in items_content ] menu . include ( * items ) self . dropdown_menu = menu . render () return self def before_render ( self , ** props ): if self . dropdown_btn and not self . escape_btn : self . include_content_parts ( self . dropdown_btn , first = True ) if self . dropdown_menu : self . include_content_parts ( self . dropdown_menu ) def _render_comp ( self ): dropdown = BS5Element ( self . tag , classes = [( Dropdowns . DROPDOWN . value if not self . is_btn_group else 'btn-group' ),], ** self . attrs ) if self . dropdown_btn : dropdown . include ( self . dropdown_btn ) if self . dropdown_menu : dropdown . include ( self . dropdown_menu ) return dropdown add_menu ( * items_content , items_attrs = None , ** attrs ) items_attrs must be {index[int]:attrs_dict,} Source code in src\\probo\\styles\\frameworks\\bs5\\components\\dropdown.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def add_menu ( self , * items_content , items_attrs = None , ** attrs ): '''items_attrs must be {index[int]:attrs_dict,}''' menu = BS5Element ( 'ul' , classes = [ Dropdowns . DROPDOWN_MENU . value ,], ** attrs ) if items_attrs : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ** items_attrs [ indx ] ) for indx , content in enumerate ( items_content )] else : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ) for content in items_content ] menu . include ( * items ) self . dropdown_menu = menu . render () return self","title":"dropdown"},{"location":"reference/probo/styles/frameworks/bs5/components/dropdown/#dropdown","text":"","title":"dropdown"},{"location":"reference/probo/styles/frameworks/bs5/components/dropdown/#probo.styles.frameworks.bs5.components.dropdown.BS5Dropdown","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\dropdown.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class BS5Dropdown ( BS5Component ): '''''' def __init__ ( self , render_constraints = None , is_btn_group = False , escape_btn = False , ** attrs ): self . attrs = attrs self . is_btn_group = is_btn_group self . render_constraints = render_constraints self . dropdown_btn = None self . escape_btn = escape_btn self . dropdown_menu = None self . tag = 'div' super () . __init__ ( name = 'BS5-dropdown' , state_props = self . render_constraints ) def add_btn ( self , content , ** attrs ): btn = BS5Element ( 'button' , content , classes = [ Dropdowns . DROPDOWN_TOGGLE . value ,], Type = \"button\" , data_bs_toggle = \"dropdown\" , aria_expanded = \"false\" , ** attrs ) self . dropdown_btn = btn . render () return self def add_menu ( self , * items_content , items_attrs = None , ** attrs ): '''items_attrs must be {index[int]:attrs_dict,}''' menu = BS5Element ( 'ul' , classes = [ Dropdowns . DROPDOWN_MENU . value ,], ** attrs ) if items_attrs : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ** items_attrs [ indx ] ) for indx , content in enumerate ( items_content )] else : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ) for content in items_content ] menu . include ( * items ) self . dropdown_menu = menu . render () return self def before_render ( self , ** props ): if self . dropdown_btn and not self . escape_btn : self . include_content_parts ( self . dropdown_btn , first = True ) if self . dropdown_menu : self . include_content_parts ( self . dropdown_menu ) def _render_comp ( self ): dropdown = BS5Element ( self . tag , classes = [( Dropdowns . DROPDOWN . value if not self . is_btn_group else 'btn-group' ),], ** self . attrs ) if self . dropdown_btn : dropdown . include ( self . dropdown_btn ) if self . dropdown_menu : dropdown . include ( self . dropdown_menu ) return dropdown","title":"BS5Dropdown"},{"location":"reference/probo/styles/frameworks/bs5/components/dropdown/#probo.styles.frameworks.bs5.components.dropdown.BS5Dropdown.add_menu","text":"items_attrs must be {index[int]:attrs_dict,} Source code in src\\probo\\styles\\frameworks\\bs5\\components\\dropdown.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 def add_menu ( self , * items_content , items_attrs = None , ** attrs ): '''items_attrs must be {index[int]:attrs_dict,}''' menu = BS5Element ( 'ul' , classes = [ Dropdowns . DROPDOWN_MENU . value ,], ** attrs ) if items_attrs : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ** items_attrs [ indx ] ) for indx , content in enumerate ( items_content )] else : items = [ BS5Element ( 'li' , content , classes = [ Dropdowns . DROPDOWN_ITEM . value ,], ) for content in items_content ] menu . include ( * items ) self . dropdown_menu = menu . render () return self","title":"add_menu"},{"location":"reference/probo/styles/frameworks/bs5/components/list_group/","text":"list_group BS5ListGroup Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\list_group.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BS5ListGroup ( BS5Component ): ''' ''' def __init__ ( self , * items , content , render_constraints = None , ** attrs ): self . attrs = attrs self . content = content self . render_constraints = render_constraints # self.template = self._render_comp() self . items = list ( items ) self . list_classes = [ Lists . LIST_GROUP . value ] self . tag = 'ul' super () . __init__ ( name = 'BS5-button' , state_props = self . render_constraints ) def add_list_item ( self , content , tag = 'li' , return_item = False , ** attrs ): item = BS5Element ( tag , content , classes = [ Lists . LIST_GROUP_ITEM . value ,( 'list-group-item-action' if tag == 'a' else '' )], ** attrs ) if return_item : return item else : self . items . append ( item . render ()) return self def before_render ( self , ** prop ): self . include_content_parts ( * self . items ) return self def _render_comp ( self ): if self . items : self . items = [ self . add_list_item ( item , return_item = True ) . render () for item in self . items ] list_group = BS5Element ( self . tag , '' . join ( self . items ), classes = self . list_classes , ** self . attrs ) return list_group","title":"list_group"},{"location":"reference/probo/styles/frameworks/bs5/components/list_group/#list_group","text":"","title":"list_group"},{"location":"reference/probo/styles/frameworks/bs5/components/list_group/#probo.styles.frameworks.bs5.components.list_group.BS5ListGroup","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\list_group.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 class BS5ListGroup ( BS5Component ): ''' ''' def __init__ ( self , * items , content , render_constraints = None , ** attrs ): self . attrs = attrs self . content = content self . render_constraints = render_constraints # self.template = self._render_comp() self . items = list ( items ) self . list_classes = [ Lists . LIST_GROUP . value ] self . tag = 'ul' super () . __init__ ( name = 'BS5-button' , state_props = self . render_constraints ) def add_list_item ( self , content , tag = 'li' , return_item = False , ** attrs ): item = BS5Element ( tag , content , classes = [ Lists . LIST_GROUP_ITEM . value ,( 'list-group-item-action' if tag == 'a' else '' )], ** attrs ) if return_item : return item else : self . items . append ( item . render ()) return self def before_render ( self , ** prop ): self . include_content_parts ( * self . items ) return self def _render_comp ( self ): if self . items : self . items = [ self . add_list_item ( item , return_item = True ) . render () for item in self . items ] list_group = BS5Element ( self . tag , '' . join ( self . items ), classes = self . list_classes , ** self . attrs ) return list_group","title":"BS5ListGroup"},{"location":"reference/probo/styles/frameworks/bs5/components/modal/","text":"modal BS5Modal Bases: BS5Component Open modal for @mdo New message Close Source code in src\\probo\\styles\\frameworks\\bs5\\components\\modal.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 class BS5Modal ( BS5Component ): '''<button type=\"button\" class=\"btn btn-primary\" data-bs-toggle=\"modal\" data-bs-target=\"#exampleModal\">Open modal for @mdo</button> <div class=\"modal\" id=\"exampleModal\"> <div class=\"modal-dialog\"> <div class=\"modal-content\"> <div class=\"modal-header\"> <h5 class=\"modal-title\" id=\"exampleModalLabel\">New message</h5> <button type=\"button\" class=\"btn-close\" data-bs-dismiss=\"modal\" aria-label=\"Close\"></button> </div> <div class=\"modal-body\"> </div> <div class=\"modal-footer\"> <button type=\"button\" class=\"btn btn-secondary\" data-bs-dismiss=\"modal\">Close</button> </div> </div> </div> </div>''' def __init__ ( self , render_constraints = None , ** attrs ): self . attrs = attrs self . modal_parts = [] self . render_constraints = render_constraints # self.template = self._render_comp() self . modal_classes = [ Modal . MODAL . value ] self . tag = 'div' self . triggers = [] super () . __init__ ( name = 'BS5-Modal' , state_props = self . render_constraints ) def add_trigger_btn ( self , content , ** attrs ): trigger_btn = BS5Element ( 'button' , content , classes = self . modal_classes , data_bs_toggle = \"modal\" , ** attrs ) self . triggers . append ( trigger_btn ) return self def add_modal_header ( self , other_content , title = None , ** attrs ): header_content = '' if title : header_content += f '<h5 class=\"modal-title\"> { title } </h5>' header_content += other_content modal_header = BS5Element ( 'div' , header_content , classes = [ Modal . MODAL_HEADER . value ], ** attrs ) btn_close = BS5Element ( 'button' , Type = \"button\" , Class = \"btn-close\" , data_bs_dismiss = \"modal\" , ) modal_header . include ( btn_close ) self . modal_parts . append ( modal_header . render ()) return self def add_modal_body ( self , content , ** attrs ): modal_body = BS5Element ( 'div' , content , classes = [ Modal . MODAL_BODY . value ], ** attrs ) self . modal_parts . append ( modal_body . render ()) return self def add_modal_footer ( self , content , ** attrs ): modal_footer = BS5Element ( 'div' , content , classes = [ Modal . MODAL_FOOTER . value ], ** attrs ) self . modal_parts . append ( modal_footer . render ()) return self def before_render ( self , ** props ): moal_dailog = BS5Element ( 'div' , BS5Element ( 'div' , '' . join ( self . modal_parts ), classes = [ Modal . MODAL_CONTENT . value ] ), classes = [ Modal . MODAL_DIALOG . value ] ) self . include_content_parts ( moal_dailog ) def _render_comp ( self ): button = BS5Element ( self . tag , classes = self . modal_classes , ** self . attrs ) return button","title":"modal"},{"location":"reference/probo/styles/frameworks/bs5/components/modal/#modal","text":"","title":"modal"},{"location":"reference/probo/styles/frameworks/bs5/components/modal/#probo.styles.frameworks.bs5.components.modal.BS5Modal","text":"Bases: BS5Component Open modal for @mdo","title":"BS5Modal"},{"location":"reference/probo/styles/frameworks/bs5/components/nav/","text":"nav BS5Nav Bases: BS5Component Active Source code in src\\probo\\styles\\frameworks\\bs5\\components\\nav.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class BS5Nav ( BS5Component ): ''' <ul class=\"nav nav-pills\"> <li class=\"nav-item\"> <a class=\"nav-link active\" aria-current=\"page\" href=\"#\">Active</a> </li> </ul> ''' def __init__ ( self , * content , render_constraints = None , is_tab = False , is_fill = False , is_pill = False , is_justified = False , ** attrs ): self . attrs = attrs self . render_constraints = render_constraints self . content = '' . join ( content ) self . nav_items = list () self . is_tab = is_tab # self.template = self._render_comp() self . is_fill = is_fill self . is_pill = is_pill self . is_justified = is_justified self . nav_classes = [ Nav . NAV . value ] self . tag = 'ul' if self . is_tab : self . nav_classes . append ( Nav . NAV_TABS . value ) if self . is_justified : self . nav_classes . append ( Nav . NAV_JUSTIFYIED . value ) if self . is_pill : self . nav_classes . append ( Nav . NAV_PILLS . value ) if self . is_fill : self . nav_classes . append ( Nav . NAV_FILL . value ) super () . __init__ ( name = 'BS5-nav' , state_props = self . render_constraints ) def add_nav_item ( self , content , tag = 'li' , ** attrs ): item = BS5Element ( tag , content , classes = [ 'nav-item' ], ** attrs ) self . nav_items . append ( item ) return self def add_nav_link ( self , content , active = False , ** attrs ): item = BS5Element ( 'a' , content , classes = [ 'nav-link' ,], ** attrs ) if active : item . classes . append ( 'active' ) item . attr_manager . set_attr ( 'aria-current' , \"page\" ) if attrs . get ( 'Class' , None ) and 'disabled' in attrs [ 'Class' ]: item . attr_manager . set_attr ( 'aria-disabled' , \"true\" ) self . nav_items . append ( item ) return self def before_render ( self , ** props ): self . include_content_parts ( * self . nav_items ) def _render_comp ( self ): nav = BS5Element ( self . tag , self . content , classes = self . nav_classes , ** self . attrs ) return nav","title":"nav"},{"location":"reference/probo/styles/frameworks/bs5/components/nav/#nav","text":"","title":"nav"},{"location":"reference/probo/styles/frameworks/bs5/components/nav/#probo.styles.frameworks.bs5.components.nav.BS5Nav","text":"Bases: BS5Component Active Source code in src\\probo\\styles\\frameworks\\bs5\\components\\nav.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class BS5Nav ( BS5Component ): ''' <ul class=\"nav nav-pills\"> <li class=\"nav-item\"> <a class=\"nav-link active\" aria-current=\"page\" href=\"#\">Active</a> </li> </ul> ''' def __init__ ( self , * content , render_constraints = None , is_tab = False , is_fill = False , is_pill = False , is_justified = False , ** attrs ): self . attrs = attrs self . render_constraints = render_constraints self . content = '' . join ( content ) self . nav_items = list () self . is_tab = is_tab # self.template = self._render_comp() self . is_fill = is_fill self . is_pill = is_pill self . is_justified = is_justified self . nav_classes = [ Nav . NAV . value ] self . tag = 'ul' if self . is_tab : self . nav_classes . append ( Nav . NAV_TABS . value ) if self . is_justified : self . nav_classes . append ( Nav . NAV_JUSTIFYIED . value ) if self . is_pill : self . nav_classes . append ( Nav . NAV_PILLS . value ) if self . is_fill : self . nav_classes . append ( Nav . NAV_FILL . value ) super () . __init__ ( name = 'BS5-nav' , state_props = self . render_constraints ) def add_nav_item ( self , content , tag = 'li' , ** attrs ): item = BS5Element ( tag , content , classes = [ 'nav-item' ], ** attrs ) self . nav_items . append ( item ) return self def add_nav_link ( self , content , active = False , ** attrs ): item = BS5Element ( 'a' , content , classes = [ 'nav-link' ,], ** attrs ) if active : item . classes . append ( 'active' ) item . attr_manager . set_attr ( 'aria-current' , \"page\" ) if attrs . get ( 'Class' , None ) and 'disabled' in attrs [ 'Class' ]: item . attr_manager . set_attr ( 'aria-disabled' , \"true\" ) self . nav_items . append ( item ) return self def before_render ( self , ** props ): self . include_content_parts ( * self . nav_items ) def _render_comp ( self ): nav = BS5Element ( self . tag , self . content , classes = self . nav_classes , ** self . attrs ) return nav","title":"BS5Nav"},{"location":"reference/probo/styles/frameworks/bs5/components/navbar/","text":"navbar BS5NavBar Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\navbar.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class BS5NavBar ( BS5Component ): ''' ''' def __init__ ( self , * content , render_constraints = None , wraper_func = None , ** attrs ): self . attrs = attrs self . wraper_func = wraper_func self . render_constraints = render_constraints self . content = \"\" . join ([ x . render () if hasattr ( x , 'render' ) else x for x in content ]) self . navbar_items = list () # self.template = self._render_comp() self . navbar_classes = [ Navbar . NAVBAR . value ] self . tag = 'nav' super () . __init__ ( name = 'BS5-NavBar' , state_props = self . render_constraints ) self . attr_manager . root = {} def add_navbar_brand ( self , content , tag = 'div' , ** attrs ): item = BS5Element ( tag , content , classes = [ 'navbar-brand' ], ** attrs ) self . navbar_items . append ( BS5Element ( 'div' , classes = [ 'container-fluid' ]) . include ( item ,) . render ()) return self def add_navbar_text ( self , content , tag = 'span' , ** attrs ): item = BS5Element ( tag , content , classes = [ 'navbar-text' ], ** attrs ) self . navbar_items . append ( BS5Element ( 'div' , classes = [ 'container-fluid' ]) . include ( item ,) . render ()) return self def before_render ( self , ** props ): self . include_content_parts ( * self . navbar_items ) def _render_comp ( self ): nav = BS5Element ( self . tag , ( self . wraper_func ( self . content ) if callable ( self . wraper_func ) else self . content ), classes = self . navbar_classes , ** self . attrs ) return nav","title":"navbar"},{"location":"reference/probo/styles/frameworks/bs5/components/navbar/#navbar","text":"","title":"navbar"},{"location":"reference/probo/styles/frameworks/bs5/components/navbar/#probo.styles.frameworks.bs5.components.navbar.BS5NavBar","text":"Bases: BS5Component Source code in src\\probo\\styles\\frameworks\\bs5\\components\\navbar.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 class BS5NavBar ( BS5Component ): ''' ''' def __init__ ( self , * content , render_constraints = None , wraper_func = None , ** attrs ): self . attrs = attrs self . wraper_func = wraper_func self . render_constraints = render_constraints self . content = \"\" . join ([ x . render () if hasattr ( x , 'render' ) else x for x in content ]) self . navbar_items = list () # self.template = self._render_comp() self . navbar_classes = [ Navbar . NAVBAR . value ] self . tag = 'nav' super () . __init__ ( name = 'BS5-NavBar' , state_props = self . render_constraints ) self . attr_manager . root = {} def add_navbar_brand ( self , content , tag = 'div' , ** attrs ): item = BS5Element ( tag , content , classes = [ 'navbar-brand' ], ** attrs ) self . navbar_items . append ( BS5Element ( 'div' , classes = [ 'container-fluid' ]) . include ( item ,) . render ()) return self def add_navbar_text ( self , content , tag = 'span' , ** attrs ): item = BS5Element ( tag , content , classes = [ 'navbar-text' ], ** attrs ) self . navbar_items . append ( BS5Element ( 'div' , classes = [ 'container-fluid' ]) . include ( item ,) . render ()) return self def before_render ( self , ** props ): self . include_content_parts ( * self . navbar_items ) def _render_comp ( self ): nav = BS5Element ( self . tag , ( self . wraper_func ( self . content ) if callable ( self . wraper_func ) else self . content ), classes = self . navbar_classes , ** self . attrs ) return nav","title":"BS5NavBar"},{"location":"reference/probo/styles/frameworks/bs5/components/offcanvas/","text":"offcanvas","title":"offcanvas"},{"location":"reference/probo/styles/frameworks/bs5/components/offcanvas/#offcanvas","text":"","title":"offcanvas"},{"location":"reference/probo/styles/frameworks/bs5/components/pagination/","text":"pagination","title":"pagination"},{"location":"reference/probo/styles/frameworks/bs5/components/pagination/#pagination","text":"","title":"pagination"},{"location":"reference/probo/styles/frameworks/bs5/components/popover/","text":"popover","title":"popover"},{"location":"reference/probo/styles/frameworks/bs5/components/popover/#popover","text":"","title":"popover"},{"location":"reference/probo/styles/frameworks/bs5/components/progress/","text":"progress","title":"progress"},{"location":"reference/probo/styles/frameworks/bs5/components/progress/#progress","text":"","title":"progress"},{"location":"reference/probo/styles/frameworks/bs5/components/scrollspy/","text":"scrollspy","title":"scrollspy"},{"location":"reference/probo/styles/frameworks/bs5/components/scrollspy/#scrollspy","text":"","title":"scrollspy"},{"location":"reference/probo/styles/frameworks/bs5/components/spinner/","text":"spinner","title":"spinner"},{"location":"reference/probo/styles/frameworks/bs5/components/spinner/#spinner","text":"","title":"spinner"},{"location":"reference/probo/styles/frameworks/bs5/components/table/","text":"table","title":"table"},{"location":"reference/probo/styles/frameworks/bs5/components/table/#table","text":"","title":"table"},{"location":"reference/probo/styles/frameworks/bs5/components/toast/","text":"toast","title":"toast"},{"location":"reference/probo/styles/frameworks/bs5/components/toast/#toast","text":"","title":"toast"},{"location":"reference/probo/styles/frameworks/bs5/components/tooltips/","text":"tooltips BS5Tooltips Bases: BS5Component Bootstrap 5 Tooltip component. Actually creates the trigger element (usually a button or link) that displays the tooltip on hover/focus. Source code in src\\probo\\styles\\frameworks\\bs5\\components\\tooltips.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class BS5Tooltips ( BS5Component ): \"\"\" Bootstrap 5 Tooltip component. Actually creates the *trigger* element (usually a button or link) that displays the tooltip on hover/focus. \"\"\" def __init__ ( self , content , title , placement = \"top\" , tag = \"button\" , render_constraints = None , ** attrs ): self . render_constraints = render_constraints self . attrs = attrs self . tag = tag self . content = content self . title = title self . placement = placement self . tooltips_classes = [] super () . __init__ ( name = 'BS5-Tooltips' , state_props = self . render_constraints ) def _render_comp ( self ): # Base BS5Component logic expects this to return the BS5Element to render tooltip_attrs = { 'data-bs-toggle' : 'tooltip' , 'data-bs-placement' : self . placement , 'title' : self . title , # Accessible name if not provided } if self . tag == 'button' : tooltip_attrs [ 'type' ] = 'button' root = BS5Element ( self . tag , self . content , classes = self . tooltips_classes , ** tooltip_attrs ) root . attr_manager . set_bulk_attr ( ** self . attrs ) return root","title":"tooltips"},{"location":"reference/probo/styles/frameworks/bs5/components/tooltips/#tooltips","text":"","title":"tooltips"},{"location":"reference/probo/styles/frameworks/bs5/components/tooltips/#probo.styles.frameworks.bs5.components.tooltips.BS5Tooltips","text":"Bases: BS5Component Bootstrap 5 Tooltip component. Actually creates the trigger element (usually a button or link) that displays the tooltip on hover/focus. Source code in src\\probo\\styles\\frameworks\\bs5\\components\\tooltips.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 class BS5Tooltips ( BS5Component ): \"\"\" Bootstrap 5 Tooltip component. Actually creates the *trigger* element (usually a button or link) that displays the tooltip on hover/focus. \"\"\" def __init__ ( self , content , title , placement = \"top\" , tag = \"button\" , render_constraints = None , ** attrs ): self . render_constraints = render_constraints self . attrs = attrs self . tag = tag self . content = content self . title = title self . placement = placement self . tooltips_classes = [] super () . __init__ ( name = 'BS5-Tooltips' , state_props = self . render_constraints ) def _render_comp ( self ): # Base BS5Component logic expects this to return the BS5Element to render tooltip_attrs = { 'data-bs-toggle' : 'tooltip' , 'data-bs-placement' : self . placement , 'title' : self . title , # Accessible name if not provided } if self . tag == 'button' : tooltip_attrs [ 'type' ] = 'button' root = BS5Element ( self . tag , self . content , classes = self . tooltips_classes , ** tooltip_attrs ) root . attr_manager . set_bulk_attr ( ** self . attrs ) return root","title":"BS5Tooltips"},{"location":"reference/probo/templates/default_templates/","text":"default_templates","title":"default_templates"},{"location":"reference/probo/templates/default_templates/#default_templates","text":"","title":"default_templates"},{"location":"reference/probo/templates/resolver/","text":"resolver TemplateResolver Source code in src\\probo\\templates\\resolver.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class TemplateResolver : def __init__ ( self , tmplt_str = None , load_it = False ): self . tmplt_str = tmplt_str self . template_attributes = {} self . load_it = load_it self . template_info = {} self . template_tags = [] \"\"\" take template and process to css sylectors them eache added value to self selectors shall be tested if they exucted in the template first\"\"\" def parse_xml ( self , xml_string : str ) -> ET . Element : \"\"\"Parse XML string and return the root element.\"\"\" return ET . fromstring ( xml_string ) def merge_attributes ( self , existing_attrs : dict , new_attrs : dict ) -> dict : \"\"\"Merge new attributes into existing ones (merge class names, override duplicates).\"\"\" for key , value in new_attrs . items (): if key == \"class\" : # Merge class lists uniquely existing_classes = set ( existing_attrs . get ( \"class\" , \"\" ) . split ()) new_classes = set ( value . split ()) existing_attrs [ \"class\" ] = \" \" . join ( existing_classes . union ( new_classes ) ) . strip () else : # Override or add new attributes existing_attrs [ key ] = value return existing_attrs def collect_elements_attributes ( self , root : ET . Element , load_it = False ) -> dict : \"\"\" Traverse XML and collect tags with their merged attributes. Ignores the root tag itself. \"\"\" result = {} def _traverse ( elem ): if elem . tag != \"root\" : # Merge attributes for same tags if load_it : self . template_tags . append ( elem . tag ) if elem . tag not in result : result [ elem . tag ] = elem . attrib . copy () else : result [ elem . tag ] = self . merge_attributes ( result [ elem . tag ], elem . attrib ) for child in elem : _traverse ( child ) _traverse ( root ) return result def xml_to_tag_dict ( self , xml_string : str ) -> dict : \"\"\"Main function: XML \u2192 dict of tags \u2192 merged attributes.\"\"\" root = self . parse_xml ( xml_string ) return self . collect_elements_attributes ( root ) def invert_tag_attribute_dict ( self , tag_dict : dict , unique : bool = True , split_classes : bool = True ) -> dict : \"\"\" Invert {tag: {attr: value}} into {attr: [values...]}. Args: tag_dict (dict): dict of tags and their attributes unique (bool): if True, remove duplicate values split_classes (bool): if True, split 'class' attributes into separate tokens Returns: dict: attribute \u2192 list of all values \"\"\" result = {} for tag , attrs in tag_dict . items (): for attr , value in attrs . items (): if not value : continue # Split class values into individual tokens if split_classes and attr == \"class\" : values = value . split () else : values = [ value ] # Initialize attribute list if attr not in result : result [ attr ] = [] result [ attr ] . extend ( values ) # Make unique if requested if unique : result = { k : list ( dict . fromkeys ( v )) for k , v in result . items () } # preserves order return result def __template_resolver ( self , tmplt_str = None , load_it = False ): xml_data = HtmlToXmlConverter ( str ( tmplt_str )) . to_xml () result = self . xml_to_tag_dict ( xml_data ) # self.template_info = result if load_it : self . template_tags = list ( set ( self . template_tags )) self . template_attributes . update ( self . invert_tag_attribute_dict ( result )) return result def template_resolver ( self , template = None , load_it = False ): if template : return self . __template_resolver ( template , load_it ) else : info = self . __template_resolver ( tmplt_str = self . tmplt_str , load_it = self . load_it ) self . template_info . update ( info ) return info collect_elements_attributes ( root , load_it = False ) Traverse XML and collect tags with their merged attributes. Ignores the root tag itself. Source code in src\\probo\\templates\\resolver.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def collect_elements_attributes ( self , root : ET . Element , load_it = False ) -> dict : \"\"\" Traverse XML and collect tags with their merged attributes. Ignores the root tag itself. \"\"\" result = {} def _traverse ( elem ): if elem . tag != \"root\" : # Merge attributes for same tags if load_it : self . template_tags . append ( elem . tag ) if elem . tag not in result : result [ elem . tag ] = elem . attrib . copy () else : result [ elem . tag ] = self . merge_attributes ( result [ elem . tag ], elem . attrib ) for child in elem : _traverse ( child ) _traverse ( root ) return result invert_tag_attribute_dict ( tag_dict , unique = True , split_classes = True ) Invert {tag: {attr: value}} into {attr: [values...]}. Parameters: tag_dict ( dict ) \u2013 dict of tags and their attributes unique ( bool , default: True ) \u2013 if True, remove duplicate values split_classes ( bool , default: True ) \u2013 if True, split 'class' attributes into separate tokens Returns: dict ( dict ) \u2013 attribute \u2192 list of all values Source code in src\\probo\\templates\\resolver.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def invert_tag_attribute_dict ( self , tag_dict : dict , unique : bool = True , split_classes : bool = True ) -> dict : \"\"\" Invert {tag: {attr: value}} into {attr: [values...]}. Args: tag_dict (dict): dict of tags and their attributes unique (bool): if True, remove duplicate values split_classes (bool): if True, split 'class' attributes into separate tokens Returns: dict: attribute \u2192 list of all values \"\"\" result = {} for tag , attrs in tag_dict . items (): for attr , value in attrs . items (): if not value : continue # Split class values into individual tokens if split_classes and attr == \"class\" : values = value . split () else : values = [ value ] # Initialize attribute list if attr not in result : result [ attr ] = [] result [ attr ] . extend ( values ) # Make unique if requested if unique : result = { k : list ( dict . fromkeys ( v )) for k , v in result . items () } # preserves order return result merge_attributes ( existing_attrs , new_attrs ) Merge new attributes into existing ones (merge class names, override duplicates). Source code in src\\probo\\templates\\resolver.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def merge_attributes ( self , existing_attrs : dict , new_attrs : dict ) -> dict : \"\"\"Merge new attributes into existing ones (merge class names, override duplicates).\"\"\" for key , value in new_attrs . items (): if key == \"class\" : # Merge class lists uniquely existing_classes = set ( existing_attrs . get ( \"class\" , \"\" ) . split ()) new_classes = set ( value . split ()) existing_attrs [ \"class\" ] = \" \" . join ( existing_classes . union ( new_classes ) ) . strip () else : # Override or add new attributes existing_attrs [ key ] = value return existing_attrs parse_xml ( xml_string ) Parse XML string and return the root element. Source code in src\\probo\\templates\\resolver.py 15 16 17 def parse_xml ( self , xml_string : str ) -> ET . Element : \"\"\"Parse XML string and return the root element.\"\"\" return ET . fromstring ( xml_string ) xml_to_tag_dict ( xml_string ) Main function: XML \u2192 dict of tags \u2192 merged attributes. Source code in src\\probo\\templates\\resolver.py 61 62 63 64 def xml_to_tag_dict ( self , xml_string : str ) -> dict : \"\"\"Main function: XML \u2192 dict of tags \u2192 merged attributes.\"\"\" root = self . parse_xml ( xml_string ) return self . collect_elements_attributes ( root )","title":"resolver"},{"location":"reference/probo/templates/resolver/#resolver","text":"","title":"resolver"},{"location":"reference/probo/templates/resolver/#probo.templates.resolver.TemplateResolver","text":"Source code in src\\probo\\templates\\resolver.py 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 class TemplateResolver : def __init__ ( self , tmplt_str = None , load_it = False ): self . tmplt_str = tmplt_str self . template_attributes = {} self . load_it = load_it self . template_info = {} self . template_tags = [] \"\"\" take template and process to css sylectors them eache added value to self selectors shall be tested if they exucted in the template first\"\"\" def parse_xml ( self , xml_string : str ) -> ET . Element : \"\"\"Parse XML string and return the root element.\"\"\" return ET . fromstring ( xml_string ) def merge_attributes ( self , existing_attrs : dict , new_attrs : dict ) -> dict : \"\"\"Merge new attributes into existing ones (merge class names, override duplicates).\"\"\" for key , value in new_attrs . items (): if key == \"class\" : # Merge class lists uniquely existing_classes = set ( existing_attrs . get ( \"class\" , \"\" ) . split ()) new_classes = set ( value . split ()) existing_attrs [ \"class\" ] = \" \" . join ( existing_classes . union ( new_classes ) ) . strip () else : # Override or add new attributes existing_attrs [ key ] = value return existing_attrs def collect_elements_attributes ( self , root : ET . Element , load_it = False ) -> dict : \"\"\" Traverse XML and collect tags with their merged attributes. Ignores the root tag itself. \"\"\" result = {} def _traverse ( elem ): if elem . tag != \"root\" : # Merge attributes for same tags if load_it : self . template_tags . append ( elem . tag ) if elem . tag not in result : result [ elem . tag ] = elem . attrib . copy () else : result [ elem . tag ] = self . merge_attributes ( result [ elem . tag ], elem . attrib ) for child in elem : _traverse ( child ) _traverse ( root ) return result def xml_to_tag_dict ( self , xml_string : str ) -> dict : \"\"\"Main function: XML \u2192 dict of tags \u2192 merged attributes.\"\"\" root = self . parse_xml ( xml_string ) return self . collect_elements_attributes ( root ) def invert_tag_attribute_dict ( self , tag_dict : dict , unique : bool = True , split_classes : bool = True ) -> dict : \"\"\" Invert {tag: {attr: value}} into {attr: [values...]}. Args: tag_dict (dict): dict of tags and their attributes unique (bool): if True, remove duplicate values split_classes (bool): if True, split 'class' attributes into separate tokens Returns: dict: attribute \u2192 list of all values \"\"\" result = {} for tag , attrs in tag_dict . items (): for attr , value in attrs . items (): if not value : continue # Split class values into individual tokens if split_classes and attr == \"class\" : values = value . split () else : values = [ value ] # Initialize attribute list if attr not in result : result [ attr ] = [] result [ attr ] . extend ( values ) # Make unique if requested if unique : result = { k : list ( dict . fromkeys ( v )) for k , v in result . items () } # preserves order return result def __template_resolver ( self , tmplt_str = None , load_it = False ): xml_data = HtmlToXmlConverter ( str ( tmplt_str )) . to_xml () result = self . xml_to_tag_dict ( xml_data ) # self.template_info = result if load_it : self . template_tags = list ( set ( self . template_tags )) self . template_attributes . update ( self . invert_tag_attribute_dict ( result )) return result def template_resolver ( self , template = None , load_it = False ): if template : return self . __template_resolver ( template , load_it ) else : info = self . __template_resolver ( tmplt_str = self . tmplt_str , load_it = self . load_it ) self . template_info . update ( info ) return info","title":"TemplateResolver"},{"location":"reference/probo/templates/resolver/#probo.templates.resolver.TemplateResolver.collect_elements_attributes","text":"Traverse XML and collect tags with their merged attributes. Ignores the root tag itself. Source code in src\\probo\\templates\\resolver.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def collect_elements_attributes ( self , root : ET . Element , load_it = False ) -> dict : \"\"\" Traverse XML and collect tags with their merged attributes. Ignores the root tag itself. \"\"\" result = {} def _traverse ( elem ): if elem . tag != \"root\" : # Merge attributes for same tags if load_it : self . template_tags . append ( elem . tag ) if elem . tag not in result : result [ elem . tag ] = elem . attrib . copy () else : result [ elem . tag ] = self . merge_attributes ( result [ elem . tag ], elem . attrib ) for child in elem : _traverse ( child ) _traverse ( root ) return result","title":"collect_elements_attributes"},{"location":"reference/probo/templates/resolver/#probo.templates.resolver.TemplateResolver.invert_tag_attribute_dict","text":"Invert {tag: {attr: value}} into {attr: [values...]}. Parameters: tag_dict ( dict ) \u2013 dict of tags and their attributes unique ( bool , default: True ) \u2013 if True, remove duplicate values split_classes ( bool , default: True ) \u2013 if True, split 'class' attributes into separate tokens Returns: dict ( dict ) \u2013 attribute \u2192 list of all values Source code in src\\probo\\templates\\resolver.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def invert_tag_attribute_dict ( self , tag_dict : dict , unique : bool = True , split_classes : bool = True ) -> dict : \"\"\" Invert {tag: {attr: value}} into {attr: [values...]}. Args: tag_dict (dict): dict of tags and their attributes unique (bool): if True, remove duplicate values split_classes (bool): if True, split 'class' attributes into separate tokens Returns: dict: attribute \u2192 list of all values \"\"\" result = {} for tag , attrs in tag_dict . items (): for attr , value in attrs . items (): if not value : continue # Split class values into individual tokens if split_classes and attr == \"class\" : values = value . split () else : values = [ value ] # Initialize attribute list if attr not in result : result [ attr ] = [] result [ attr ] . extend ( values ) # Make unique if requested if unique : result = { k : list ( dict . fromkeys ( v )) for k , v in result . items () } # preserves order return result","title":"invert_tag_attribute_dict"},{"location":"reference/probo/templates/resolver/#probo.templates.resolver.TemplateResolver.merge_attributes","text":"Merge new attributes into existing ones (merge class names, override duplicates). Source code in src\\probo\\templates\\resolver.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def merge_attributes ( self , existing_attrs : dict , new_attrs : dict ) -> dict : \"\"\"Merge new attributes into existing ones (merge class names, override duplicates).\"\"\" for key , value in new_attrs . items (): if key == \"class\" : # Merge class lists uniquely existing_classes = set ( existing_attrs . get ( \"class\" , \"\" ) . split ()) new_classes = set ( value . split ()) existing_attrs [ \"class\" ] = \" \" . join ( existing_classes . union ( new_classes ) ) . strip () else : # Override or add new attributes existing_attrs [ key ] = value return existing_attrs","title":"merge_attributes"},{"location":"reference/probo/templates/resolver/#probo.templates.resolver.TemplateResolver.parse_xml","text":"Parse XML string and return the root element. Source code in src\\probo\\templates\\resolver.py 15 16 17 def parse_xml ( self , xml_string : str ) -> ET . Element : \"\"\"Parse XML string and return the root element.\"\"\" return ET . fromstring ( xml_string )","title":"parse_xml"},{"location":"reference/probo/templates/resolver/#probo.templates.resolver.TemplateResolver.xml_to_tag_dict","text":"Main function: XML \u2192 dict of tags \u2192 merged attributes. Source code in src\\probo\\templates\\resolver.py 61 62 63 64 def xml_to_tag_dict ( self , xml_string : str ) -> dict : \"\"\"Main function: XML \u2192 dict of tags \u2192 merged attributes.\"\"\" root = self . parse_xml ( xml_string ) return self . collect_elements_attributes ( root )","title":"xml_to_tag_dict"},{"location":"reference/probo/terminal/app_generator/","text":"app_generator create_hacksoft_structure ( app_dir ) Services (Write) + Selectors (Read). Source code in src\\probo\\terminal\\app_generator.py 7 8 9 10 11 12 13 def create_hacksoft_structure ( app_dir : Path ): \"\"\"Services (Write) + Selectors (Read).\"\"\" for folder in [ \"services\" , \"selectors\" ]: d = app_dir / folder d . mkdir ( parents = True , exist_ok = True ) ( d / \"__init__.py\" ) . touch () ( d / f \" { folder } .py\" ) . touch () create_probo_dj_structure ( app_dir , app_name ) The Full Enterprise Stack. Source code in src\\probo\\terminal\\app_generator.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def create_probo_dj_structure ( app_dir : Path , app_name : str ): \"\"\"The Full Enterprise Stack.\"\"\" # 1. Deep Layer Separation structure = { \"services\" : [ \"__init__.py\" , f \" { app_name } _service.py\" , \"systems/\" ], \"selectors\" : [ \"__init__.py\" , \"selectors.py\" ], # Split Views & Forms into Admin/Client \"forms\" : [ \"__init__.py\" , \"admin_forms/\" , \"client_forms/\" ], \"views\" : [ \"__init__.py\" , \"admin_views/\" , \"client_views/\" ], \"urls\" : [ \"__init__.py\" , \"admin_urls.py\" , \"client_urls.py\" ], \"exceptions\" : [ \"__init__.py\" , \"service_exception.py\" ], } for folder , files in structure . items (): folder_path = app_dir / folder folder_path . mkdir ( parents = True , exist_ok = True ) for f in files : if f . endswith ( \"/\" ): ( folder_path / f ) . mkdir ( parents = True , exist_ok = True ) else : ( folder_path / f ) . touch () # 2. Root Utilities for f in [ \"signals.py\" , \"dependencies.py\" , \"tasks.py\" ]: ( app_dir / f ) . touch ()","title":"app_generator"},{"location":"reference/probo/terminal/app_generator/#app_generator","text":"","title":"app_generator"},{"location":"reference/probo/terminal/app_generator/#probo.terminal.app_generator.create_hacksoft_structure","text":"Services (Write) + Selectors (Read). Source code in src\\probo\\terminal\\app_generator.py 7 8 9 10 11 12 13 def create_hacksoft_structure ( app_dir : Path ): \"\"\"Services (Write) + Selectors (Read).\"\"\" for folder in [ \"services\" , \"selectors\" ]: d = app_dir / folder d . mkdir ( parents = True , exist_ok = True ) ( d / \"__init__.py\" ) . touch () ( d / f \" { folder } .py\" ) . touch ()","title":"create_hacksoft_structure"},{"location":"reference/probo/terminal/app_generator/#probo.terminal.app_generator.create_probo_dj_structure","text":"The Full Enterprise Stack. Source code in src\\probo\\terminal\\app_generator.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def create_probo_dj_structure ( app_dir : Path , app_name : str ): \"\"\"The Full Enterprise Stack.\"\"\" # 1. Deep Layer Separation structure = { \"services\" : [ \"__init__.py\" , f \" { app_name } _service.py\" , \"systems/\" ], \"selectors\" : [ \"__init__.py\" , \"selectors.py\" ], # Split Views & Forms into Admin/Client \"forms\" : [ \"__init__.py\" , \"admin_forms/\" , \"client_forms/\" ], \"views\" : [ \"__init__.py\" , \"admin_views/\" , \"client_views/\" ], \"urls\" : [ \"__init__.py\" , \"admin_urls.py\" , \"client_urls.py\" ], \"exceptions\" : [ \"__init__.py\" , \"service_exception.py\" ], } for folder , files in structure . items (): folder_path = app_dir / folder folder_path . mkdir ( parents = True , exist_ok = True ) for f in files : if f . endswith ( \"/\" ): ( folder_path / f ) . mkdir ( parents = True , exist_ok = True ) else : ( folder_path / f ) . touch () # 2. Root Utilities for f in [ \"signals.py\" , \"dependencies.py\" , \"tasks.py\" ]: ( app_dir / f ) . touch ()","title":"create_probo_dj_structure"},{"location":"reference/probo/terminal/cli/","text":"cli build_css ( registry_path = typer . Option ( 'probo_tcm.py' , help = 'Path to the TCM registry file' ), output = typer . Option ( 'static/css/style.css' , help = 'Output path for the CSS file' )) Scans all registered components, triggers JIT compilation, deduplicates styles, and exports a single CSS bundle. Source code in src\\probo\\terminal\\cli.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @app . command ( \"build:css\" ) def build_css ( registry_path : Path = typer . Option ( \"probo_tcm.py\" , help = \"Path to the TCM registry file\" ), output : Path = typer . Option ( \"static/css/style.css\" , help = \"Output path for the CSS file\" ), ): \"\"\" Scans all registered components, triggers JIT compilation, deduplicates styles, and exports a single CSS bundle. \"\"\" tcm = load_tcm_registry ( registry_path ) seen_signatures = set () final_css_blocks = [] typer . echo ( f \"\ud83c\udfa8 Scanning { len ( tcm . url_name_comp ) } components for JIT CSS...\" ) for name , ComponentClass in tcm . url_name_comp . items (): try : # 1. Mock Render (Force Design Mode / Static Defaults) # We assume the component can render with default s_data comp = ComponentClass () # If you implemented the 'strict_dynamic' logic, ensure defaults are used if hasattr ( comp , \"elements\" ): for el in comp . elements : el . d_data_key = None # Force static fallback _ , css_output = comp . render () if not css_output : continue # 2. Deduplicate css_hash = hash ( css_output ) if css_hash not in seen_signatures : seen_signatures . add ( css_hash ) final_css_blocks . append ( f \"/* --- Component: { name } --- */\" ) final_css_blocks . append ( css_output ) except Exception as e : console . print ( f \"[yellow]\u26a0\ufe0f Skipping { name } : { e } [/yellow]\" ) # 3. Write output . parent . mkdir ( parents = True , exist_ok = True ) output . write_text ( \" \\n \" . join ( final_css_blocks ), encoding = \"utf-8\" ) console . print ( \"[bold green]CSS Exported \u2705\u2705\u2705 [/bold green]\" , ) console . print ( f \"[bold green]\u2705 Successfully wrote { len ( seen_signatures ) } unique styles to { output } [/bold green]\" , ) build_html ( registry_path = typer . Option ( 'probo_tcm.py' , help = 'Path to the TCM registry file' ), output_dir = typer . Option ( 'dist' , help = 'Directory to save HTML files' )) Renders all registered components as static HTML files. Useful for prototyping or static site generation. Source code in src\\probo\\terminal\\cli.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 @app . command ( \"build:html\" ) def build_html ( registry_path : Path = typer . Option ( \"probo_tcm.py\" , help = \"Path to the TCM registry file\" ), output_dir : Path = typer . Option ( \"dist\" , help = \"Directory to save HTML files\" ), ): \"\"\" Renders all registered components as static HTML files. Useful for prototyping or static site generation. \"\"\" tcm = load_tcm_registry ( registry_path ) output_dir . mkdir ( parents = True , exist_ok = True ) typer . echo ( f \"\ud83c\udfd7\ufe0f Rendering components to ' { output_dir } /'...\" ) count = 0 for name , ComponentClass in tcm . url_name_comp . items (): try : # 1. Render comp = ComponentClass () html_output , css_output = comp . render () # 2. Construct Full Page (Inject CSS for standalone viewing) full_page = f \"\"\"<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title> { name } - PROBO Static Build</title> <style> { css_output } </style> </head> <body> { html_output } </body> </html>\"\"\" # 3. Save file_path = output_dir / f \" { name } .html\" file_path . write_text ( full_page , encoding = \"utf-8\" ) count += 1 typer . echo ( f \" \ud83d\udcc4 Generated: { file_path } \" ) except Exception as e : console . print ( f \"\u26a0\ufe0f Failed to render { name } : { e } \" , ) console . print ( f \"[bold green]\u2705 Generated { count } HTML files.[/bold green]\" , ) echo ( text ) Print arguments to the console (Debug tool). Source code in src\\probo\\terminal\\cli.py 419 420 421 422 423 @app . command ( \"echo\" ) def echo ( text : str ): \"\"\"Print arguments to the console (Debug tool).\"\"\" # This replaces your 'echo' method console . print ( f \"[italic blue]Echo:[/italic blue] { text } \" ) init ( name ) Scaffold a pure 'PROBO Project' (Standalone / Static Site). Best for prototyping, landing pages, or HTMX-only sites. Source code in src\\probo\\terminal\\cli.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @app . command ( \"init\" ) def init ( name : str ): \"\"\" Scaffold a pure 'PROBO Project' (Standalone / Static Site). Best for prototyping, landing pages, or HTMX-only sites. \"\"\" project_dir = Path . cwd () / name if project_dir . exists (): console . print ( f \"[red]Error: Directory ' { name } ' already exists![/red]\" ) raise typer . Exit ( 1 ) project_dir . mkdir ( parents = True ) # 1. The Entry Point ( project_dir / \"main.py\" ) . write_text ( \"\"\" from probo.cli import build_html, build_css if __name__ == \"__main__\": print(\"Building static site...\") # Add build logic here \"\"\" , encoding = \"utf-8\" , ) # 2. The Registry ( project_dir / \"probo_tcm.py\" ) . write_text ( \"\"\" from probo import TemplateComponentMap tcm = TemplateComponentMap() # from components.pages import HomePage # tcm.register(home=HomePage) \"\"\" , encoding = \"utf-8\" , ) # 3. The Components Layer ( project_dir / \"components\" ) . mkdir () ( project_dir / \"components\" / \"__init__.py\" ) . touch () ( project_dir / \"components\" / \"pages.py\" ) . touch () # 4. Assets ( project_dir / \"assets\" ) . mkdir () ( project_dir / \"dist\" ) . mkdir () # Output folder console . print ( f \"[green]\u2728 Pure PROBO Project ' { name } ' initialized![/green]\" ) console . print ( f \"[dim]Run 'cd { name } ' then 'probo shell' to start building.[/dim]\" ) load_tcm_registry ( path ) Dynamically loads the 'probo_tcm.py' file from the user's project. Returns the 'tcm' object containing the registered components. Source code in src\\probo\\terminal\\cli.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def load_tcm_registry ( path : Path ): \"\"\" Dynamically loads the 'probo_tcm.py' file from the user's project. Returns the 'tcm' object containing the registered components. \"\"\" if not path . exists (): console . print ( f \"[red] Error: Could not find ' { path } '. Are you in the project root?[/red]\" ) raise typer . Exit ( code = 1 ) # Add current directory to sys.path so the user's code can import their own modules sys . path . append ( str ( Path . cwd ())) try : spec = spec_from_file_location ( \"probo_tcm\" , path ) module = module_from_spec ( spec ) spec . loader . exec_module ( module ) if not hasattr ( module , \"tcm\" ): console . print ( f \"[red] Error: ' { path } ' exists but does not export a 'tcm' object.[/red]\" ) raise typer . Exit ( code = 1 ) return module . tcm except Exception as e : console . print ( f \"[red] Error loading registry: { e } [/red]\" ) raise typer . Exit ( code = 1 ) preview_component ( component_name , registry_path = typer . Option ( 'probo_tcm.py' , help = 'Path to the TCM registry' )) Renders a specific component, saves it to a temporary file, and opens it in your default browser immediately. Source code in src\\probo\\terminal\\cli.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 @app . command ( \"preview\" ) def preview_component ( component_name : str , registry_path : Path = typer . Option ( \"probo_tcm.py\" , help = \"Path to the TCM registry\" ), ): \"\"\" Renders a specific component, saves it to a temporary file, and opens it in your default browser immediately. \"\"\" # 1. Load Registry tcm = load_tcm_registry ( registry_path ) if component_name not in tcm . url_name_comp : console . print ( f \"Error: Component ' { component_name } ' not found in registry.\" , ) return try : # 2. Render ComponentClass = tcm . url_name_comp [ component_name ] comp = ComponentClass () html_output , css_output = comp . render () # 3. Wrap in HTML Shell full_page = f \"\"\"<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Preview: { component_name } </title> <style> body {{ font-family: system-ui; padding: 2rem; }} /* Component Styles */ { css_output } </style> </head> <body> <div style=\"border: 1px dashed #ccc; padding: 1rem;\"> { html_output } </div> <div style=\"margin-top: 1rem; color: #666; font-size: 0.8rem;\"> Rendering: <strong> { component_name } </strong> </div> </body> </html>\"\"\" # 4. Save to Temp File (The Logic from your 'build_logic') import tempfile fd , path = tempfile . mkstemp ( suffix = \".html\" , prefix = f \"probo_ { component_name } _\" ) with os . fdopen ( fd , \"w\" ) as tmp : tmp . write ( full_page ) # 5. Open Browser (The Logic from your 'brow_a_file') file_url = f \"file:/// { path } \" console . print ( f \"[blue]\ud83d\udc40 Opening preview for { component_name } ...[/blue]...\" , ) webbrowser . open_new_tab ( file_url ) except Exception as e : console . print ( f \"Error rendering { component_name } : { e } \" , ) shell () Starts an interactive Python shell with PROBO pre-loaded and Rich styling. Source code in src\\probo\\terminal\\cli.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @app . command ( \"shell\" ) def shell (): \"\"\" Starts an interactive Python shell with PROBO pre-loaded and Rich styling. \"\"\" user_ns = {} exec ( \"from probo import *\" , user_ns ) def displayhook ( value ): if value is None : return if hasattr ( value , \"render\" ): html_str = value . render () syntax = Syntax ( html_str , \"html\" , theme = \"monokai\" , line_numbers = False ) console . print ( syntax ) elif isinstance ( value , str ) and value . strip () . startswith ( \"<\" ): syntax = Syntax ( value , \"html\" , theme = \"monokai\" ) console . print ( syntax ) else : console . print ( value ) sys . displayhook = displayhook banner_text = \"\"\" [bold green]PROBO Interactive Shell v1.0[/bold green] [yellow]\u2022 Standard:[/yellow] div('Hello', id='main') [yellow]\u2022 Shorthand:[/yellow] emmet('div #main .container -c Content') [yellow]\u2022 Logic:[/yellow] loop(5, hr()) [italic]Type [red]exit()[/red] to quit.[/italic]\"\"\" console . print ( Panel ( banner_text , title = \"PROBO Console\" , expand = False )) # user_ns = locals() console . print ( f \"[bold blue]Context:[/bold blue] { os . getcwd () } \" ) try : python_code . interact ( banner = \"\" , local = user_ns ) except SystemExit : pass startapp ( name , structure = typer . Option ( DjangoStructure . BASE , '--structure' , '-s' , help = \"Choose architecture: 'base' (Standard), 'hacksoft' (DDD), or 'probo-dj' (Enterprise).\" )) Create a Django app with PROBO scaffolding. Source code in src\\probo\\terminal\\cli.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @app . command ( \"dj-app\" ) def startapp ( name : str , structure : DjangoStructure = typer . Option ( DjangoStructure . BASE , \"--structure\" , \"-s\" , help = \"Choose architecture: 'base' (Standard), 'hacksoft' (DDD), or 'probo-dj' (Enterprise).\" , ), ): \"\"\" Create a Django app with PROBO scaffolding. \"\"\" # 1. Run standard Django command try : subprocess . run ([ sys . executable , \"manage.py\" , \"startapp\" , name ], check = True ) except ( subprocess . CalledProcessError , FileNotFoundError ): console . print ( \"[red]Error: Could not run 'manage.py'. Are you in the root of a Django project?[/red]\" ) return app_dir = Path . cwd () / name # 2. Common PROBO Layer (All structures get this) components_dir = app_dir / \"components\" components_dir . mkdir ( parents = True , exist_ok = True ) ( components_dir / \"__init__.py\" ) . touch () ( app_dir / \"probo_tcm.py\" ) . write_text ( \"\"\" # utilities for django views and multi-component mapping from probo.context import TemplateComponentMap from django.utils.safestring import mark_safe from django.template import Template, RequestContext def render_probo(request, *raw_template_strings,**context): ''' use this to desplay html string as safe html and use it as django's render ''' raw_template_string = ''.join([tmplt.render() if hasattr(tmplt,'render') else str(tmplt) for tmplt in raw_template_strings]) context = RequestContext(request, context) template = Template(raw_template_string) # 4. Render and Return return mark_safe(template.render(context)) tcm = TemplateComponentMap() #mapper of component objects \"\"\" ) # 3. Apply Structure Logic if structure == DjangoStructure . HACKSOFT : create_hacksoft_structure ( app_dir ) console . print ( f \"[green]\u2728 Created App ' { name } ' (HackSoft Style)[/green]\" ) elif structure == DjangoStructure . PROBO_DJ : create_probo_dj_structure ( app_dir , name ) console . print ( f \"[green]\u2728 Created App ' { name } ' (PROBO-DJ Enterprise)[/green]\" ) else : console . print ( f \"[green]\u2728 Created App ' { name } ' (Base Style)[/green]\" ) # Visual Confirmation console . print ( \" + components/\" ) console . print ( \" + probo_tcm.py\" ) version () Show the current version. Source code in src\\probo\\terminal\\cli.py 410 411 412 413 414 415 416 @app . command ( \"version\" ) def version (): \"\"\"Show the current version.\"\"\" # This replaces your 'show_version' method console . print ( f \"[bold cyan]Mastodon UI (probo)[/bold cyan] version [yellow] { VERSION } [/yellow]\" )","title":"cli"},{"location":"reference/probo/terminal/cli/#cli","text":"","title":"cli"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.build_css","text":"Scans all registered components, triggers JIT compilation, deduplicates styles, and exports a single CSS bundle. Source code in src\\probo\\terminal\\cli.py 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 @app . command ( \"build:css\" ) def build_css ( registry_path : Path = typer . Option ( \"probo_tcm.py\" , help = \"Path to the TCM registry file\" ), output : Path = typer . Option ( \"static/css/style.css\" , help = \"Output path for the CSS file\" ), ): \"\"\" Scans all registered components, triggers JIT compilation, deduplicates styles, and exports a single CSS bundle. \"\"\" tcm = load_tcm_registry ( registry_path ) seen_signatures = set () final_css_blocks = [] typer . echo ( f \"\ud83c\udfa8 Scanning { len ( tcm . url_name_comp ) } components for JIT CSS...\" ) for name , ComponentClass in tcm . url_name_comp . items (): try : # 1. Mock Render (Force Design Mode / Static Defaults) # We assume the component can render with default s_data comp = ComponentClass () # If you implemented the 'strict_dynamic' logic, ensure defaults are used if hasattr ( comp , \"elements\" ): for el in comp . elements : el . d_data_key = None # Force static fallback _ , css_output = comp . render () if not css_output : continue # 2. Deduplicate css_hash = hash ( css_output ) if css_hash not in seen_signatures : seen_signatures . add ( css_hash ) final_css_blocks . append ( f \"/* --- Component: { name } --- */\" ) final_css_blocks . append ( css_output ) except Exception as e : console . print ( f \"[yellow]\u26a0\ufe0f Skipping { name } : { e } [/yellow]\" ) # 3. Write output . parent . mkdir ( parents = True , exist_ok = True ) output . write_text ( \" \\n \" . join ( final_css_blocks ), encoding = \"utf-8\" ) console . print ( \"[bold green]CSS Exported \u2705\u2705\u2705 [/bold green]\" , ) console . print ( f \"[bold green]\u2705 Successfully wrote { len ( seen_signatures ) } unique styles to { output } [/bold green]\" , )","title":"build_css"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.build_html","text":"Renders all registered components as static HTML files. Useful for prototyping or static site generation. Source code in src\\probo\\terminal\\cli.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 @app . command ( \"build:html\" ) def build_html ( registry_path : Path = typer . Option ( \"probo_tcm.py\" , help = \"Path to the TCM registry file\" ), output_dir : Path = typer . Option ( \"dist\" , help = \"Directory to save HTML files\" ), ): \"\"\" Renders all registered components as static HTML files. Useful for prototyping or static site generation. \"\"\" tcm = load_tcm_registry ( registry_path ) output_dir . mkdir ( parents = True , exist_ok = True ) typer . echo ( f \"\ud83c\udfd7\ufe0f Rendering components to ' { output_dir } /'...\" ) count = 0 for name , ComponentClass in tcm . url_name_comp . items (): try : # 1. Render comp = ComponentClass () html_output , css_output = comp . render () # 2. Construct Full Page (Inject CSS for standalone viewing) full_page = f \"\"\"<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title> { name } - PROBO Static Build</title> <style> { css_output } </style> </head> <body> { html_output } </body> </html>\"\"\" # 3. Save file_path = output_dir / f \" { name } .html\" file_path . write_text ( full_page , encoding = \"utf-8\" ) count += 1 typer . echo ( f \" \ud83d\udcc4 Generated: { file_path } \" ) except Exception as e : console . print ( f \"\u26a0\ufe0f Failed to render { name } : { e } \" , ) console . print ( f \"[bold green]\u2705 Generated { count } HTML files.[/bold green]\" , )","title":"build_html"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.echo","text":"Print arguments to the console (Debug tool). Source code in src\\probo\\terminal\\cli.py 419 420 421 422 423 @app . command ( \"echo\" ) def echo ( text : str ): \"\"\"Print arguments to the console (Debug tool).\"\"\" # This replaces your 'echo' method console . print ( f \"[italic blue]Echo:[/italic blue] { text } \" )","title":"echo"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.init","text":"Scaffold a pure 'PROBO Project' (Standalone / Static Site). Best for prototyping, landing pages, or HTMX-only sites. Source code in src\\probo\\terminal\\cli.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @app . command ( \"init\" ) def init ( name : str ): \"\"\" Scaffold a pure 'PROBO Project' (Standalone / Static Site). Best for prototyping, landing pages, or HTMX-only sites. \"\"\" project_dir = Path . cwd () / name if project_dir . exists (): console . print ( f \"[red]Error: Directory ' { name } ' already exists![/red]\" ) raise typer . Exit ( 1 ) project_dir . mkdir ( parents = True ) # 1. The Entry Point ( project_dir / \"main.py\" ) . write_text ( \"\"\" from probo.cli import build_html, build_css if __name__ == \"__main__\": print(\"Building static site...\") # Add build logic here \"\"\" , encoding = \"utf-8\" , ) # 2. The Registry ( project_dir / \"probo_tcm.py\" ) . write_text ( \"\"\" from probo import TemplateComponentMap tcm = TemplateComponentMap() # from components.pages import HomePage # tcm.register(home=HomePage) \"\"\" , encoding = \"utf-8\" , ) # 3. The Components Layer ( project_dir / \"components\" ) . mkdir () ( project_dir / \"components\" / \"__init__.py\" ) . touch () ( project_dir / \"components\" / \"pages.py\" ) . touch () # 4. Assets ( project_dir / \"assets\" ) . mkdir () ( project_dir / \"dist\" ) . mkdir () # Output folder console . print ( f \"[green]\u2728 Pure PROBO Project ' { name } ' initialized![/green]\" ) console . print ( f \"[dim]Run 'cd { name } ' then 'probo shell' to start building.[/dim]\" )","title":"init"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.load_tcm_registry","text":"Dynamically loads the 'probo_tcm.py' file from the user's project. Returns the 'tcm' object containing the registered components. Source code in src\\probo\\terminal\\cli.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 def load_tcm_registry ( path : Path ): \"\"\" Dynamically loads the 'probo_tcm.py' file from the user's project. Returns the 'tcm' object containing the registered components. \"\"\" if not path . exists (): console . print ( f \"[red] Error: Could not find ' { path } '. Are you in the project root?[/red]\" ) raise typer . Exit ( code = 1 ) # Add current directory to sys.path so the user's code can import their own modules sys . path . append ( str ( Path . cwd ())) try : spec = spec_from_file_location ( \"probo_tcm\" , path ) module = module_from_spec ( spec ) spec . loader . exec_module ( module ) if not hasattr ( module , \"tcm\" ): console . print ( f \"[red] Error: ' { path } ' exists but does not export a 'tcm' object.[/red]\" ) raise typer . Exit ( code = 1 ) return module . tcm except Exception as e : console . print ( f \"[red] Error loading registry: { e } [/red]\" ) raise typer . Exit ( code = 1 )","title":"load_tcm_registry"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.preview_component","text":"Renders a specific component, saves it to a temporary file, and opens it in your default browser immediately. Source code in src\\probo\\terminal\\cli.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 @app . command ( \"preview\" ) def preview_component ( component_name : str , registry_path : Path = typer . Option ( \"probo_tcm.py\" , help = \"Path to the TCM registry\" ), ): \"\"\" Renders a specific component, saves it to a temporary file, and opens it in your default browser immediately. \"\"\" # 1. Load Registry tcm = load_tcm_registry ( registry_path ) if component_name not in tcm . url_name_comp : console . print ( f \"Error: Component ' { component_name } ' not found in registry.\" , ) return try : # 2. Render ComponentClass = tcm . url_name_comp [ component_name ] comp = ComponentClass () html_output , css_output = comp . render () # 3. Wrap in HTML Shell full_page = f \"\"\"<!DOCTYPE html> <html lang=\"en\"> <head> <meta charset=\"UTF-8\"> <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"> <title>Preview: { component_name } </title> <style> body {{ font-family: system-ui; padding: 2rem; }} /* Component Styles */ { css_output } </style> </head> <body> <div style=\"border: 1px dashed #ccc; padding: 1rem;\"> { html_output } </div> <div style=\"margin-top: 1rem; color: #666; font-size: 0.8rem;\"> Rendering: <strong> { component_name } </strong> </div> </body> </html>\"\"\" # 4. Save to Temp File (The Logic from your 'build_logic') import tempfile fd , path = tempfile . mkstemp ( suffix = \".html\" , prefix = f \"probo_ { component_name } _\" ) with os . fdopen ( fd , \"w\" ) as tmp : tmp . write ( full_page ) # 5. Open Browser (The Logic from your 'brow_a_file') file_url = f \"file:/// { path } \" console . print ( f \"[blue]\ud83d\udc40 Opening preview for { component_name } ...[/blue]...\" , ) webbrowser . open_new_tab ( file_url ) except Exception as e : console . print ( f \"Error rendering { component_name } : { e } \" , )","title":"preview_component"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.shell","text":"Starts an interactive Python shell with PROBO pre-loaded and Rich styling. Source code in src\\probo\\terminal\\cli.py 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 @app . command ( \"shell\" ) def shell (): \"\"\" Starts an interactive Python shell with PROBO pre-loaded and Rich styling. \"\"\" user_ns = {} exec ( \"from probo import *\" , user_ns ) def displayhook ( value ): if value is None : return if hasattr ( value , \"render\" ): html_str = value . render () syntax = Syntax ( html_str , \"html\" , theme = \"monokai\" , line_numbers = False ) console . print ( syntax ) elif isinstance ( value , str ) and value . strip () . startswith ( \"<\" ): syntax = Syntax ( value , \"html\" , theme = \"monokai\" ) console . print ( syntax ) else : console . print ( value ) sys . displayhook = displayhook banner_text = \"\"\" [bold green]PROBO Interactive Shell v1.0[/bold green] [yellow]\u2022 Standard:[/yellow] div('Hello', id='main') [yellow]\u2022 Shorthand:[/yellow] emmet('div #main .container -c Content') [yellow]\u2022 Logic:[/yellow] loop(5, hr()) [italic]Type [red]exit()[/red] to quit.[/italic]\"\"\" console . print ( Panel ( banner_text , title = \"PROBO Console\" , expand = False )) # user_ns = locals() console . print ( f \"[bold blue]Context:[/bold blue] { os . getcwd () } \" ) try : python_code . interact ( banner = \"\" , local = user_ns ) except SystemExit : pass","title":"shell"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.startapp","text":"Create a Django app with PROBO scaffolding. Source code in src\\probo\\terminal\\cli.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 @app . command ( \"dj-app\" ) def startapp ( name : str , structure : DjangoStructure = typer . Option ( DjangoStructure . BASE , \"--structure\" , \"-s\" , help = \"Choose architecture: 'base' (Standard), 'hacksoft' (DDD), or 'probo-dj' (Enterprise).\" , ), ): \"\"\" Create a Django app with PROBO scaffolding. \"\"\" # 1. Run standard Django command try : subprocess . run ([ sys . executable , \"manage.py\" , \"startapp\" , name ], check = True ) except ( subprocess . CalledProcessError , FileNotFoundError ): console . print ( \"[red]Error: Could not run 'manage.py'. Are you in the root of a Django project?[/red]\" ) return app_dir = Path . cwd () / name # 2. Common PROBO Layer (All structures get this) components_dir = app_dir / \"components\" components_dir . mkdir ( parents = True , exist_ok = True ) ( components_dir / \"__init__.py\" ) . touch () ( app_dir / \"probo_tcm.py\" ) . write_text ( \"\"\" # utilities for django views and multi-component mapping from probo.context import TemplateComponentMap from django.utils.safestring import mark_safe from django.template import Template, RequestContext def render_probo(request, *raw_template_strings,**context): ''' use this to desplay html string as safe html and use it as django's render ''' raw_template_string = ''.join([tmplt.render() if hasattr(tmplt,'render') else str(tmplt) for tmplt in raw_template_strings]) context = RequestContext(request, context) template = Template(raw_template_string) # 4. Render and Return return mark_safe(template.render(context)) tcm = TemplateComponentMap() #mapper of component objects \"\"\" ) # 3. Apply Structure Logic if structure == DjangoStructure . HACKSOFT : create_hacksoft_structure ( app_dir ) console . print ( f \"[green]\u2728 Created App ' { name } ' (HackSoft Style)[/green]\" ) elif structure == DjangoStructure . PROBO_DJ : create_probo_dj_structure ( app_dir , name ) console . print ( f \"[green]\u2728 Created App ' { name } ' (PROBO-DJ Enterprise)[/green]\" ) else : console . print ( f \"[green]\u2728 Created App ' { name } ' (Base Style)[/green]\" ) # Visual Confirmation console . print ( \" + components/\" ) console . print ( \" + probo_tcm.py\" )","title":"startapp"},{"location":"reference/probo/terminal/cli/#probo.terminal.cli.version","text":"Show the current version. Source code in src\\probo\\terminal\\cli.py 410 411 412 413 414 415 416 @app . command ( \"version\" ) def version (): \"\"\"Show the current version.\"\"\" # This replaces your 'show_version' method console . print ( f \"[bold cyan]Mastodon UI (probo)[/bold cyan] version [yellow] { VERSION } [/yellow]\" )","title":"version"},{"location":"reference/probo/terminal/emmet/","text":"emmet emmet ( command_str ) Parses a shorthand string and returns a real MUI Element. Syntax: tag #id .class -s style:value -c \"Content here\" Example: emmet('div #main .container -c \"Hello World\"') Source code in src\\probo\\terminal\\emmet.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def emmet ( command_str : str ): \"\"\" Parses a shorthand string and returns a real MUI Element. Syntax: tag #id .class -s style:value -c \"Content here\" Example: emmet('div #main .container -c \"Hello World\"') \"\"\" # 1. Tokenize (Simple split, respecting quotes would require shlex) import shlex try : args = shlex . split ( command_str ) except ValueError : return None if not args : return None # 2. Extract Tag tag_name = args [ 0 ] if not hasattr ( tag_functions , tag_name ): raise ValueError ( f \"Unknown tag: { tag_name } \" ) tag_func = getattr ( tag_functions , tag_name ) # 3. Parse Attributes attrs = {} classes = [] content_parts = [] styles = {} i = 1 while i < len ( args ): arg = args [ i ] if arg . startswith ( \"#\" ): attrs [ \"id\" ] = arg [ 1 :] elif arg . startswith ( \".\" ): classes . append ( arg [ 1 :]) # Collect classes list elif arg == \"-s\" : # Style parsing (simple key:value) i += 1 if i < len ( args ) and \":\" in args [ i ]: k , v = args [ i ] . split ( \":\" , 1 ) styles [ k ] = v elif arg == \"-c\" : # Content parsing (everything until end or next flag) i += 1 while i < len ( args ) and not args [ i ] . startswith ( \"-\" ): content_parts . append ( args [ i ]) i += 1 continue # Skip the increment at end of loop elif \":\" in arg : # Arbitrary attributes (type:text) k , v = arg . split ( \":\" , 1 ) attrs [ k ] = v i += 1 # 4. Assemble if classes : attrs [ \"class_\" ] = \" \" . join ( classes ) # Handle Style object if you support it in v1, or just string # if styles: attrs['style'] = ES(**styles) content = \" \" . join ( content_parts ) # 5. Create the Real Object return tag_func ( content , ** attrs )","title":"emmet"},{"location":"reference/probo/terminal/emmet/#emmet","text":"","title":"emmet"},{"location":"reference/probo/terminal/emmet/#probo.terminal.emmet.emmet","text":"Parses a shorthand string and returns a real MUI Element. Syntax: tag #id .class -s style:value -c \"Content here\" Example: emmet('div #main .container -c \"Hello World\"') Source code in src\\probo\\terminal\\emmet.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 def emmet ( command_str : str ): \"\"\" Parses a shorthand string and returns a real MUI Element. Syntax: tag #id .class -s style:value -c \"Content here\" Example: emmet('div #main .container -c \"Hello World\"') \"\"\" # 1. Tokenize (Simple split, respecting quotes would require shlex) import shlex try : args = shlex . split ( command_str ) except ValueError : return None if not args : return None # 2. Extract Tag tag_name = args [ 0 ] if not hasattr ( tag_functions , tag_name ): raise ValueError ( f \"Unknown tag: { tag_name } \" ) tag_func = getattr ( tag_functions , tag_name ) # 3. Parse Attributes attrs = {} classes = [] content_parts = [] styles = {} i = 1 while i < len ( args ): arg = args [ i ] if arg . startswith ( \"#\" ): attrs [ \"id\" ] = arg [ 1 :] elif arg . startswith ( \".\" ): classes . append ( arg [ 1 :]) # Collect classes list elif arg == \"-s\" : # Style parsing (simple key:value) i += 1 if i < len ( args ) and \":\" in args [ i ]: k , v = args [ i ] . split ( \":\" , 1 ) styles [ k ] = v elif arg == \"-c\" : # Content parsing (everything until end or next flag) i += 1 while i < len ( args ) and not args [ i ] . startswith ( \"-\" ): content_parts . append ( args [ i ]) i += 1 continue # Skip the increment at end of loop elif \":\" in arg : # Arbitrary attributes (type:text) k , v = arg . split ( \":\" , 1 ) attrs [ k ] = v i += 1 # 4. Assemble if classes : attrs [ \"class_\" ] = \" \" . join ( classes ) # Handle Style object if you support it in v1, or just string # if styles: attrs['style'] = ES(**styles) content = \" \" . join ( content_parts ) # 5. Create the Real Object return tag_func ( content , ** attrs )","title":"emmet"},{"location":"reference/probo/xml/elements/","text":"elements XMLComment Represents an XML comment. Output: Source code in src\\probo\\xml\\elements.py 88 89 90 91 92 93 94 95 96 97 98 class XMLComment : \"\"\" Represents an XML comment. Output: <!-- ...content... --> \"\"\" def __init__ ( self , content : str ): self . content = content def render ( self ) -> str : return f \"<!-- { self . content } -->\" XMLDocument Represents a full XML document. Manages the Declaration ( ) and the Root Element. Source code in src\\probo\\xml\\elements.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class XMLDocument : \"\"\" Represents a full XML document. Manages the Declaration (<?xml ... ?>) and the Root Element. \"\"\" def __init__ ( self , root : Optional [ XMLElement ] = None , version = \"1.0\" , encoding = \"UTF-8\" , standalone = None , ): self . root = root self . version = version self . encoding = encoding self . standalone = standalone self . instructions = [] # List for things like xml-stylesheet def set_root ( self , root : XMLElement ): self . root = root return self def add_instruction ( self , target : str , data : str ): \"\"\"Add processing instructions before the root.\"\"\" self . instructions . append ( XMLInstruction ( target , data )) return self def render ( self ) -> str : # 1. Declaration decl = f '<?xml version=\" { self . version } \" encoding=\" { self . encoding } \"' if self . standalone : decl += f ' standalone=\" { self . standalone } \"' decl += \"?>\" # 2. Instructions instr_str = \"\" if self . instructions : instr_str = \" \\n \" + \" \\n \" . join ( i . render () for i in self . instructions ) # 3. Root root_str = \"\" if self . root : root_str = \" \\n \" + ( self . root . render () if hasattr ( self . root , \"render\" ) else str ( self . root ) ) return f \" { decl }{ instr_str }{ root_str } \" add_instruction ( target , data ) Add processing instructions before the root. Source code in src\\probo\\xml\\elements.py 140 141 142 143 def add_instruction ( self , target : str , data : str ): \"\"\"Add processing instructions before the root.\"\"\" self . instructions . append ( XMLInstruction ( target , data )) return self XMLElement Represents a generic XML element. Unlike HTML, XML tags are case-sensitive and must strictly handle attributes. Source code in src\\probo\\xml\\elements.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class XMLElement : \"\"\" Represents a generic XML element. Unlike HTML, XML tags are case-sensitive and must strictly handle attributes. \"\"\" def __init__ ( self , tag : str , content : Union [ str , \"XMLElement\" , List [ \"XMLElement\" ]] = \"\" , ** attrs , ): self . tag = tag self . content = content self . attrs = attrs self . children = [] self . attr_manager = ElementAttributeManipulator ( self . attrs ) # Handle initial content if it's a list if isinstance ( content , list ): self . children . extend ( content ) elif content : # If it's a single item (str or Element), add to children list for uniform handling self . children . append ( content ) def add ( self , child : Union [ \"XMLElement\" , str ]): \"\"\"Fluent API to add children.\"\"\" self . children . append ( child ) return self def set_attr ( self , key : str , value : Any ): self . attrs [ key ] = value return self def _render_attrs ( self ) -> str : \"\"\" Renders attributes. XML Rule: No boolean attributes (e.g. 'disabled'). Must be key=\"value\". \"\"\" parts = [] for k , v in self . attrs . items (): # XML allows any key characters, but usually we keep them as is. # We convert values to string strictly. if v is None : continue if isinstance ( v , bool ): parts . append ( f ' { k } =\" { k } \"' ) else : parts . append ( f ' { k } =\" { v } \"' ) return \" \" . join ( parts ) def render ( self ) -> str : attr_str = self . _render_attrs () if attr_str : attr_str = \" \" + attr_str # Render children inner_html = \"\" for child in self . children : if hasattr ( child , \"render\" ): inner_html += child . render () else : inner_html += str ( child ) # XML Rule: Self-closing tag is mandatory if empty if not inner_html : return f \"< { self . tag }{ attr_str } />\" return f \"< { self . tag }{ attr_str } > { inner_html } </ { self . tag } >\" add ( child ) Fluent API to add children. Source code in src\\probo\\xml\\elements.py 28 29 30 31 def add ( self , child : Union [ \"XMLElement\" , str ]): \"\"\"Fluent API to add children.\"\"\" self . children . append ( child ) return self XMLInstruction Represents a Processing Instruction (PI). Output: Example: Source code in src\\probo\\xml\\elements.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class XMLInstruction : \"\"\" Represents a Processing Instruction (PI). Output: <?target content?> Example: <?xml-stylesheet type=\"text/xsl\" href=\"style.xsl\"?> \"\"\" def __init__ ( self , target : str , data : str = \"\" ): self . target = target self . data = data def render ( self ) -> str : data_str = f \" { self . data } \" if self . data else \"\" return f \"<? { self . target }{ data_str } ?>\" XMLSection Represents a CDATA section. Used to escape blocks of text that would otherwise be interpreted as markup. Output: Source code in src\\probo\\xml\\elements.py 74 75 76 77 78 79 80 81 82 83 84 85 class XMLSection : \"\"\" Represents a CDATA section. Used to escape blocks of text that would otherwise be interpreted as markup. Output: <![CDATA[ ...content... ]]> \"\"\" def __init__ ( self , content : str ): self . content = content def render ( self ) -> str : return f \"<![CDATA[ { self . content } ]]>\"","title":"elements"},{"location":"reference/probo/xml/elements/#elements","text":"","title":"elements"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLComment","text":"Represents an XML comment. Output: Source code in src\\probo\\xml\\elements.py 88 89 90 91 92 93 94 95 96 97 98 class XMLComment : \"\"\" Represents an XML comment. Output: <!-- ...content... --> \"\"\" def __init__ ( self , content : str ): self . content = content def render ( self ) -> str : return f \"<!-- { self . content } -->\"","title":"XMLComment"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLDocument","text":"Represents a full XML document. Manages the Declaration ( ) and the Root Element. Source code in src\\probo\\xml\\elements.py 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 class XMLDocument : \"\"\" Represents a full XML document. Manages the Declaration (<?xml ... ?>) and the Root Element. \"\"\" def __init__ ( self , root : Optional [ XMLElement ] = None , version = \"1.0\" , encoding = \"UTF-8\" , standalone = None , ): self . root = root self . version = version self . encoding = encoding self . standalone = standalone self . instructions = [] # List for things like xml-stylesheet def set_root ( self , root : XMLElement ): self . root = root return self def add_instruction ( self , target : str , data : str ): \"\"\"Add processing instructions before the root.\"\"\" self . instructions . append ( XMLInstruction ( target , data )) return self def render ( self ) -> str : # 1. Declaration decl = f '<?xml version=\" { self . version } \" encoding=\" { self . encoding } \"' if self . standalone : decl += f ' standalone=\" { self . standalone } \"' decl += \"?>\" # 2. Instructions instr_str = \"\" if self . instructions : instr_str = \" \\n \" + \" \\n \" . join ( i . render () for i in self . instructions ) # 3. Root root_str = \"\" if self . root : root_str = \" \\n \" + ( self . root . render () if hasattr ( self . root , \"render\" ) else str ( self . root ) ) return f \" { decl }{ instr_str }{ root_str } \"","title":"XMLDocument"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLDocument.add_instruction","text":"Add processing instructions before the root. Source code in src\\probo\\xml\\elements.py 140 141 142 143 def add_instruction ( self , target : str , data : str ): \"\"\"Add processing instructions before the root.\"\"\" self . instructions . append ( XMLInstruction ( target , data )) return self","title":"add_instruction"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLElement","text":"Represents a generic XML element. Unlike HTML, XML tags are case-sensitive and must strictly handle attributes. Source code in src\\probo\\xml\\elements.py 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 class XMLElement : \"\"\" Represents a generic XML element. Unlike HTML, XML tags are case-sensitive and must strictly handle attributes. \"\"\" def __init__ ( self , tag : str , content : Union [ str , \"XMLElement\" , List [ \"XMLElement\" ]] = \"\" , ** attrs , ): self . tag = tag self . content = content self . attrs = attrs self . children = [] self . attr_manager = ElementAttributeManipulator ( self . attrs ) # Handle initial content if it's a list if isinstance ( content , list ): self . children . extend ( content ) elif content : # If it's a single item (str or Element), add to children list for uniform handling self . children . append ( content ) def add ( self , child : Union [ \"XMLElement\" , str ]): \"\"\"Fluent API to add children.\"\"\" self . children . append ( child ) return self def set_attr ( self , key : str , value : Any ): self . attrs [ key ] = value return self def _render_attrs ( self ) -> str : \"\"\" Renders attributes. XML Rule: No boolean attributes (e.g. 'disabled'). Must be key=\"value\". \"\"\" parts = [] for k , v in self . attrs . items (): # XML allows any key characters, but usually we keep them as is. # We convert values to string strictly. if v is None : continue if isinstance ( v , bool ): parts . append ( f ' { k } =\" { k } \"' ) else : parts . append ( f ' { k } =\" { v } \"' ) return \" \" . join ( parts ) def render ( self ) -> str : attr_str = self . _render_attrs () if attr_str : attr_str = \" \" + attr_str # Render children inner_html = \"\" for child in self . children : if hasattr ( child , \"render\" ): inner_html += child . render () else : inner_html += str ( child ) # XML Rule: Self-closing tag is mandatory if empty if not inner_html : return f \"< { self . tag }{ attr_str } />\" return f \"< { self . tag }{ attr_str } > { inner_html } </ { self . tag } >\"","title":"XMLElement"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLElement.add","text":"Fluent API to add children. Source code in src\\probo\\xml\\elements.py 28 29 30 31 def add ( self , child : Union [ \"XMLElement\" , str ]): \"\"\"Fluent API to add children.\"\"\" self . children . append ( child ) return self","title":"add"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLInstruction","text":"Represents a Processing Instruction (PI). Output: Example: Source code in src\\probo\\xml\\elements.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 class XMLInstruction : \"\"\" Represents a Processing Instruction (PI). Output: <?target content?> Example: <?xml-stylesheet type=\"text/xsl\" href=\"style.xsl\"?> \"\"\" def __init__ ( self , target : str , data : str = \"\" ): self . target = target self . data = data def render ( self ) -> str : data_str = f \" { self . data } \" if self . data else \"\" return f \"<? { self . target }{ data_str } ?>\"","title":"XMLInstruction"},{"location":"reference/probo/xml/elements/#probo.xml.elements.XMLSection","text":"Represents a CDATA section. Used to escape blocks of text that would otherwise be interpreted as markup. Output: Source code in src\\probo\\xml\\elements.py 74 75 76 77 78 79 80 81 82 83 84 85 class XMLSection : \"\"\" Represents a CDATA section. Used to escape blocks of text that would otherwise be interpreted as markup. Output: <![CDATA[ ...content... ]]> \"\"\" def __init__ ( self , content : str ): self . content = content def render ( self ) -> str : return f \"<![CDATA[ { self . content } ]]>\"","title":"XMLSection"},{"location":"reference/probo/xml/xml/","text":"xml HtmlToXmlConverter A class to convert HTML strings to XML, designed with web framework functionalities in mind. Features: - Robust HTML parsing using BeautifulSoup. - Conversion to a well-formed XML structure. - Simple templating for data rendering (e.g., {{ variable }}). - Chaining methods for a fluent API. - Error handling for malformed HTML. - Pretty printing for XML output. Source code in src\\probo\\xml\\xml.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 class HtmlToXmlConverter : \"\"\" A class to convert HTML strings to XML, designed with web framework functionalities in mind. Features: - Robust HTML parsing using BeautifulSoup. - Conversion to a well-formed XML structure. - Simple templating for data rendering (e.g., {{ variable }}). - Chaining methods for a fluent API. - Error handling for malformed HTML. - Pretty printing for XML output. \"\"\" def __init__ ( self , html_string : str = \"\" ): \"\"\" Initializes the converter with an optional HTML string. Args: html_string (str): The initial HTML string to process. \"\"\" self . _html_string = html_string self . _parsed_soup = None self . _data_context = {} self . _xml_root = None def load_html ( self , html_string : str ) -> \"HtmlToXmlConverter\" : \"\"\" Loads a new HTML string into the converter. Args: html_string (str): The HTML string to load. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _html_string = html_string self . _parsed_soup = None # Reset parsed soup self . _xml_root = None # Reset XML root return self def with_data ( self , data : dict ) -> \"HtmlToXmlConverter\" : \"\"\" Sets the data context for rendering HTML templates. Args: data (dict): A dictionary of data to be used for templating. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _data_context = data return self def render ( self ) -> \"HtmlToXmlConverter\" : \"\"\" Renders the HTML string by replacing placeholders with data from the context. This is a simple templating mechanism. Placeholders are in the format {{ variable_name }}. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" if not self . _html_string : print ( \"Warning: No HTML string loaded to render.\" ) return self rendered_html = self . _html_string for key , value in self . _data_context . items (): placeholder = r \"{{\\s*\" + re . escape ( key ) + r \"\\s*}}\" rendered_html = re . sub ( placeholder , str ( value ), rendered_html ) self . _html_string = rendered_html return self def _parse_html ( self ): \"\"\" Internal method to parse the HTML string using BeautifulSoup. Handles basic parsing errors. \"\"\" if not self . _html_string : raise ValueError ( \"No HTML string provided for parsing.\" ) try : # Using 'html.parser' for general HTML, 'lxml' or 'html5lib' # can be more robust for very malformed HTML if available. self . _parsed_soup = BeautifulSoup ( self . _html_string , \"html.parser\" ) except Exception as e : raise RuntimeError ( f \"Error parsing HTML: { e } \" ) def _build_xml_element ( self , soup_tag : Tag , parent_xml_element : ET . Element ): \"\"\" Recursively builds XML elements from BeautifulSoup tags. Args: soup_tag (bs4.Tag): The BeautifulSoup tag to convert. parent_xml_element (xml.etree.ElementTree.Element): The parent XML element. \"\"\" # Create the XML element with the tag name xml_element = ET . SubElement ( parent_xml_element , soup_tag . name ) # Add attributes for attr , value in soup_tag . attrs . items (): # BeautifulSoup returns attribute values as lists for multi-valued # attributes like 'class'. Join them for XML. if isinstance ( value , list ): xml_element . set ( attr , \" \" . join ( value )) else : xml_element . set ( attr , str ( value )) # Process children (text and nested tags) for child in soup_tag . contents : if isinstance ( child , NavigableString ): # If it's a string, append it as text to the current XML element # Strip whitespace from text nodes to avoid empty text nodes # unless they contain significant content. text = str ( child ) . strip () if text : if xml_element . text is None : xml_element . text = text else : xml_element . text += text # Append if text already exists elif isinstance ( child , Tag ): # If it's another tag, recurse self . _build_xml_element ( child , xml_element ) def to_xml ( self , pretty_print : bool = False ) -> str : \"\"\" Converts the loaded and potentially rendered HTML to an XML string. Args: pretty_print (bool): If True, the XML output will be formatted with indentation. Returns: str: The XML representation of the HTML. Raises: ValueError: If no HTML string is loaded. RuntimeError: If there's an error during HTML parsing or XML conversion. \"\"\" if not self . _html_string : raise ValueError ( \"No HTML string loaded. Use load_html() first.\" ) # Ensure HTML is parsed if self . _parsed_soup is None : self . _parse_html () # Create a dummy root element for the XML tree if HTML has multiple top-level elements # or if we want a consistent root. # In a real framework, you might decide on a specific root element like <document> or <template>. self . _xml_root = ET . Element ( \"root\" ) # Using 'root' as a generic container # Iterate through the top-level children of the parsed HTML body # or the entire soup if no body is found (e.g., for fragments) if self . _parsed_soup . body : elements_to_convert = self . _parsed_soup . body . contents else : # Handle cases where HTML might be a fragment without <body> elements_to_convert = self . _parsed_soup . contents for element in elements_to_convert : if isinstance ( element , Tag ): self . _build_xml_element ( element , self . _xml_root ) elif isinstance ( element , NavigableString ): text = str ( element ) . strip () if text : # If top-level text, add it to the root's text or create a text element if self . _xml_root . text is None : self . _xml_root . text = text else : self . _xml_root . text += text # Append if text already exists # Convert ElementTree to string if pretty_print : # Use minidom for pretty printing as ET's tostring is basic rough_string = ET . tostring ( self . _xml_root , \"utf-8\" ) reparsed = minidom . parseString ( rough_string ) return reparsed . toprettyxml ( indent = \" \" ) else : return ET . tostring ( self . _xml_root , encoding = \"unicode\" ) # --- Framework-like Extension Points --- def validate_xml ( self ) -> bool : \"\"\" Placeholder for XML validation (e.g., against an XSD schema). In a real framework, this would involve more complex logic. Returns: bool: True if XML is valid (conceptually), False otherwise. \"\"\" if self . _xml_root is None : print ( \"Warning: No XML generated yet to validate.\" ) return False # For demonstration, we'll just check if it's not empty return len ( self . _xml_root ) > 0 # Simple check if root has children def save_xml ( self , filepath : str , pretty_print : bool = False ): \"\"\" Saves the generated XML to a file. Args: filepath (str): The path to the file where XML will be saved. pretty_print (bool): If True, saves with pretty indentation. \"\"\" if self . _xml_root is None : self . to_xml () xml_string = self . to_xml ( pretty_print = pretty_print ) try : with open ( filepath , \"w\" , encoding = \"utf-8\" ) as f : f . write ( xml_string ) print ( f \"XML successfully saved to { filepath } \" ) except IOError as e : print ( f \"Error saving XML to file: { e } \" ) __init__ ( html_string = '' ) Initializes the converter with an optional HTML string. Parameters: html_string ( str , default: '' ) \u2013 The initial HTML string to process. Source code in src\\probo\\xml\\xml.py 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , html_string : str = \"\" ): \"\"\" Initializes the converter with an optional HTML string. Args: html_string (str): The initial HTML string to process. \"\"\" self . _html_string = html_string self . _parsed_soup = None self . _data_context = {} self . _xml_root = None load_html ( html_string ) Loads a new HTML string into the converter. Parameters: html_string ( str ) \u2013 The HTML string to load. Returns: HtmlToXmlConverter ( HtmlToXmlConverter ) \u2013 The instance of the converter for chaining. Source code in src\\probo\\xml\\xml.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def load_html ( self , html_string : str ) -> \"HtmlToXmlConverter\" : \"\"\" Loads a new HTML string into the converter. Args: html_string (str): The HTML string to load. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _html_string = html_string self . _parsed_soup = None # Reset parsed soup self . _xml_root = None # Reset XML root return self render () Renders the HTML string by replacing placeholders with data from the context. This is a simple templating mechanism. Placeholders are in the format {{ variable_name }}. Returns: HtmlToXmlConverter ( HtmlToXmlConverter ) \u2013 The instance of the converter for chaining. Source code in src\\probo\\xml\\xml.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def render ( self ) -> \"HtmlToXmlConverter\" : \"\"\" Renders the HTML string by replacing placeholders with data from the context. This is a simple templating mechanism. Placeholders are in the format {{ variable_name }}. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" if not self . _html_string : print ( \"Warning: No HTML string loaded to render.\" ) return self rendered_html = self . _html_string for key , value in self . _data_context . items (): placeholder = r \"{{\\s*\" + re . escape ( key ) + r \"\\s*}}\" rendered_html = re . sub ( placeholder , str ( value ), rendered_html ) self . _html_string = rendered_html return self save_xml ( filepath , pretty_print = False ) Saves the generated XML to a file. Parameters: filepath ( str ) \u2013 The path to the file where XML will be saved. pretty_print ( bool , default: False ) \u2013 If True, saves with pretty indentation. Source code in src\\probo\\xml\\xml.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def save_xml ( self , filepath : str , pretty_print : bool = False ): \"\"\" Saves the generated XML to a file. Args: filepath (str): The path to the file where XML will be saved. pretty_print (bool): If True, saves with pretty indentation. \"\"\" if self . _xml_root is None : self . to_xml () xml_string = self . to_xml ( pretty_print = pretty_print ) try : with open ( filepath , \"w\" , encoding = \"utf-8\" ) as f : f . write ( xml_string ) print ( f \"XML successfully saved to { filepath } \" ) except IOError as e : print ( f \"Error saving XML to file: { e } \" ) to_xml ( pretty_print = False ) Converts the loaded and potentially rendered HTML to an XML string. Parameters: pretty_print ( bool , default: False ) \u2013 If True, the XML output will be formatted with indentation. Returns: str ( str ) \u2013 The XML representation of the HTML. Raises: ValueError \u2013 If no HTML string is loaded. RuntimeError \u2013 If there's an error during HTML parsing or XML conversion. Source code in src\\probo\\xml\\xml.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def to_xml ( self , pretty_print : bool = False ) -> str : \"\"\" Converts the loaded and potentially rendered HTML to an XML string. Args: pretty_print (bool): If True, the XML output will be formatted with indentation. Returns: str: The XML representation of the HTML. Raises: ValueError: If no HTML string is loaded. RuntimeError: If there's an error during HTML parsing or XML conversion. \"\"\" if not self . _html_string : raise ValueError ( \"No HTML string loaded. Use load_html() first.\" ) # Ensure HTML is parsed if self . _parsed_soup is None : self . _parse_html () # Create a dummy root element for the XML tree if HTML has multiple top-level elements # or if we want a consistent root. # In a real framework, you might decide on a specific root element like <document> or <template>. self . _xml_root = ET . Element ( \"root\" ) # Using 'root' as a generic container # Iterate through the top-level children of the parsed HTML body # or the entire soup if no body is found (e.g., for fragments) if self . _parsed_soup . body : elements_to_convert = self . _parsed_soup . body . contents else : # Handle cases where HTML might be a fragment without <body> elements_to_convert = self . _parsed_soup . contents for element in elements_to_convert : if isinstance ( element , Tag ): self . _build_xml_element ( element , self . _xml_root ) elif isinstance ( element , NavigableString ): text = str ( element ) . strip () if text : # If top-level text, add it to the root's text or create a text element if self . _xml_root . text is None : self . _xml_root . text = text else : self . _xml_root . text += text # Append if text already exists # Convert ElementTree to string if pretty_print : # Use minidom for pretty printing as ET's tostring is basic rough_string = ET . tostring ( self . _xml_root , \"utf-8\" ) reparsed = minidom . parseString ( rough_string ) return reparsed . toprettyxml ( indent = \" \" ) else : return ET . tostring ( self . _xml_root , encoding = \"unicode\" ) validate_xml () Placeholder for XML validation (e.g., against an XSD schema). In a real framework, this would involve more complex logic. Returns: bool ( bool ) \u2013 True if XML is valid (conceptually), False otherwise. Source code in src\\probo\\xml\\xml.py 191 192 193 194 195 196 197 198 199 200 201 202 203 def validate_xml ( self ) -> bool : \"\"\" Placeholder for XML validation (e.g., against an XSD schema). In a real framework, this would involve more complex logic. Returns: bool: True if XML is valid (conceptually), False otherwise. \"\"\" if self . _xml_root is None : print ( \"Warning: No XML generated yet to validate.\" ) return False # For demonstration, we'll just check if it's not empty return len ( self . _xml_root ) > 0 # Simple check if root has children with_data ( data ) Sets the data context for rendering HTML templates. Parameters: data ( dict ) \u2013 A dictionary of data to be used for templating. Returns: HtmlToXmlConverter ( HtmlToXmlConverter ) \u2013 The instance of the converter for chaining. Source code in src\\probo\\xml\\xml.py 48 49 50 51 52 53 54 55 56 57 58 59 def with_data ( self , data : dict ) -> \"HtmlToXmlConverter\" : \"\"\" Sets the data context for rendering HTML templates. Args: data (dict): A dictionary of data to be used for templating. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _data_context = data return self","title":"xml"},{"location":"reference/probo/xml/xml/#xml","text":"","title":"xml"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter","text":"A class to convert HTML strings to XML, designed with web framework functionalities in mind. Features: - Robust HTML parsing using BeautifulSoup. - Conversion to a well-formed XML structure. - Simple templating for data rendering (e.g., {{ variable }}). - Chaining methods for a fluent API. - Error handling for malformed HTML. - Pretty printing for XML output. Source code in src\\probo\\xml\\xml.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 class HtmlToXmlConverter : \"\"\" A class to convert HTML strings to XML, designed with web framework functionalities in mind. Features: - Robust HTML parsing using BeautifulSoup. - Conversion to a well-formed XML structure. - Simple templating for data rendering (e.g., {{ variable }}). - Chaining methods for a fluent API. - Error handling for malformed HTML. - Pretty printing for XML output. \"\"\" def __init__ ( self , html_string : str = \"\" ): \"\"\" Initializes the converter with an optional HTML string. Args: html_string (str): The initial HTML string to process. \"\"\" self . _html_string = html_string self . _parsed_soup = None self . _data_context = {} self . _xml_root = None def load_html ( self , html_string : str ) -> \"HtmlToXmlConverter\" : \"\"\" Loads a new HTML string into the converter. Args: html_string (str): The HTML string to load. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _html_string = html_string self . _parsed_soup = None # Reset parsed soup self . _xml_root = None # Reset XML root return self def with_data ( self , data : dict ) -> \"HtmlToXmlConverter\" : \"\"\" Sets the data context for rendering HTML templates. Args: data (dict): A dictionary of data to be used for templating. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _data_context = data return self def render ( self ) -> \"HtmlToXmlConverter\" : \"\"\" Renders the HTML string by replacing placeholders with data from the context. This is a simple templating mechanism. Placeholders are in the format {{ variable_name }}. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" if not self . _html_string : print ( \"Warning: No HTML string loaded to render.\" ) return self rendered_html = self . _html_string for key , value in self . _data_context . items (): placeholder = r \"{{\\s*\" + re . escape ( key ) + r \"\\s*}}\" rendered_html = re . sub ( placeholder , str ( value ), rendered_html ) self . _html_string = rendered_html return self def _parse_html ( self ): \"\"\" Internal method to parse the HTML string using BeautifulSoup. Handles basic parsing errors. \"\"\" if not self . _html_string : raise ValueError ( \"No HTML string provided for parsing.\" ) try : # Using 'html.parser' for general HTML, 'lxml' or 'html5lib' # can be more robust for very malformed HTML if available. self . _parsed_soup = BeautifulSoup ( self . _html_string , \"html.parser\" ) except Exception as e : raise RuntimeError ( f \"Error parsing HTML: { e } \" ) def _build_xml_element ( self , soup_tag : Tag , parent_xml_element : ET . Element ): \"\"\" Recursively builds XML elements from BeautifulSoup tags. Args: soup_tag (bs4.Tag): The BeautifulSoup tag to convert. parent_xml_element (xml.etree.ElementTree.Element): The parent XML element. \"\"\" # Create the XML element with the tag name xml_element = ET . SubElement ( parent_xml_element , soup_tag . name ) # Add attributes for attr , value in soup_tag . attrs . items (): # BeautifulSoup returns attribute values as lists for multi-valued # attributes like 'class'. Join them for XML. if isinstance ( value , list ): xml_element . set ( attr , \" \" . join ( value )) else : xml_element . set ( attr , str ( value )) # Process children (text and nested tags) for child in soup_tag . contents : if isinstance ( child , NavigableString ): # If it's a string, append it as text to the current XML element # Strip whitespace from text nodes to avoid empty text nodes # unless they contain significant content. text = str ( child ) . strip () if text : if xml_element . text is None : xml_element . text = text else : xml_element . text += text # Append if text already exists elif isinstance ( child , Tag ): # If it's another tag, recurse self . _build_xml_element ( child , xml_element ) def to_xml ( self , pretty_print : bool = False ) -> str : \"\"\" Converts the loaded and potentially rendered HTML to an XML string. Args: pretty_print (bool): If True, the XML output will be formatted with indentation. Returns: str: The XML representation of the HTML. Raises: ValueError: If no HTML string is loaded. RuntimeError: If there's an error during HTML parsing or XML conversion. \"\"\" if not self . _html_string : raise ValueError ( \"No HTML string loaded. Use load_html() first.\" ) # Ensure HTML is parsed if self . _parsed_soup is None : self . _parse_html () # Create a dummy root element for the XML tree if HTML has multiple top-level elements # or if we want a consistent root. # In a real framework, you might decide on a specific root element like <document> or <template>. self . _xml_root = ET . Element ( \"root\" ) # Using 'root' as a generic container # Iterate through the top-level children of the parsed HTML body # or the entire soup if no body is found (e.g., for fragments) if self . _parsed_soup . body : elements_to_convert = self . _parsed_soup . body . contents else : # Handle cases where HTML might be a fragment without <body> elements_to_convert = self . _parsed_soup . contents for element in elements_to_convert : if isinstance ( element , Tag ): self . _build_xml_element ( element , self . _xml_root ) elif isinstance ( element , NavigableString ): text = str ( element ) . strip () if text : # If top-level text, add it to the root's text or create a text element if self . _xml_root . text is None : self . _xml_root . text = text else : self . _xml_root . text += text # Append if text already exists # Convert ElementTree to string if pretty_print : # Use minidom for pretty printing as ET's tostring is basic rough_string = ET . tostring ( self . _xml_root , \"utf-8\" ) reparsed = minidom . parseString ( rough_string ) return reparsed . toprettyxml ( indent = \" \" ) else : return ET . tostring ( self . _xml_root , encoding = \"unicode\" ) # --- Framework-like Extension Points --- def validate_xml ( self ) -> bool : \"\"\" Placeholder for XML validation (e.g., against an XSD schema). In a real framework, this would involve more complex logic. Returns: bool: True if XML is valid (conceptually), False otherwise. \"\"\" if self . _xml_root is None : print ( \"Warning: No XML generated yet to validate.\" ) return False # For demonstration, we'll just check if it's not empty return len ( self . _xml_root ) > 0 # Simple check if root has children def save_xml ( self , filepath : str , pretty_print : bool = False ): \"\"\" Saves the generated XML to a file. Args: filepath (str): The path to the file where XML will be saved. pretty_print (bool): If True, saves with pretty indentation. \"\"\" if self . _xml_root is None : self . to_xml () xml_string = self . to_xml ( pretty_print = pretty_print ) try : with open ( filepath , \"w\" , encoding = \"utf-8\" ) as f : f . write ( xml_string ) print ( f \"XML successfully saved to { filepath } \" ) except IOError as e : print ( f \"Error saving XML to file: { e } \" )","title":"HtmlToXmlConverter"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.__init__","text":"Initializes the converter with an optional HTML string. Parameters: html_string ( str , default: '' ) \u2013 The initial HTML string to process. Source code in src\\probo\\xml\\xml.py 21 22 23 24 25 26 27 28 29 30 31 def __init__ ( self , html_string : str = \"\" ): \"\"\" Initializes the converter with an optional HTML string. Args: html_string (str): The initial HTML string to process. \"\"\" self . _html_string = html_string self . _parsed_soup = None self . _data_context = {} self . _xml_root = None","title":"__init__"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.load_html","text":"Loads a new HTML string into the converter. Parameters: html_string ( str ) \u2013 The HTML string to load. Returns: HtmlToXmlConverter ( HtmlToXmlConverter ) \u2013 The instance of the converter for chaining. Source code in src\\probo\\xml\\xml.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def load_html ( self , html_string : str ) -> \"HtmlToXmlConverter\" : \"\"\" Loads a new HTML string into the converter. Args: html_string (str): The HTML string to load. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _html_string = html_string self . _parsed_soup = None # Reset parsed soup self . _xml_root = None # Reset XML root return self","title":"load_html"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.render","text":"Renders the HTML string by replacing placeholders with data from the context. This is a simple templating mechanism. Placeholders are in the format {{ variable_name }}. Returns: HtmlToXmlConverter ( HtmlToXmlConverter ) \u2013 The instance of the converter for chaining. Source code in src\\probo\\xml\\xml.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def render ( self ) -> \"HtmlToXmlConverter\" : \"\"\" Renders the HTML string by replacing placeholders with data from the context. This is a simple templating mechanism. Placeholders are in the format {{ variable_name }}. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" if not self . _html_string : print ( \"Warning: No HTML string loaded to render.\" ) return self rendered_html = self . _html_string for key , value in self . _data_context . items (): placeholder = r \"{{\\s*\" + re . escape ( key ) + r \"\\s*}}\" rendered_html = re . sub ( placeholder , str ( value ), rendered_html ) self . _html_string = rendered_html return self","title":"render"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.save_xml","text":"Saves the generated XML to a file. Parameters: filepath ( str ) \u2013 The path to the file where XML will be saved. pretty_print ( bool , default: False ) \u2013 If True, saves with pretty indentation. Source code in src\\probo\\xml\\xml.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def save_xml ( self , filepath : str , pretty_print : bool = False ): \"\"\" Saves the generated XML to a file. Args: filepath (str): The path to the file where XML will be saved. pretty_print (bool): If True, saves with pretty indentation. \"\"\" if self . _xml_root is None : self . to_xml () xml_string = self . to_xml ( pretty_print = pretty_print ) try : with open ( filepath , \"w\" , encoding = \"utf-8\" ) as f : f . write ( xml_string ) print ( f \"XML successfully saved to { filepath } \" ) except IOError as e : print ( f \"Error saving XML to file: { e } \" )","title":"save_xml"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.to_xml","text":"Converts the loaded and potentially rendered HTML to an XML string. Parameters: pretty_print ( bool , default: False ) \u2013 If True, the XML output will be formatted with indentation. Returns: str ( str ) \u2013 The XML representation of the HTML. Raises: ValueError \u2013 If no HTML string is loaded. RuntimeError \u2013 If there's an error during HTML parsing or XML conversion. Source code in src\\probo\\xml\\xml.py 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 def to_xml ( self , pretty_print : bool = False ) -> str : \"\"\" Converts the loaded and potentially rendered HTML to an XML string. Args: pretty_print (bool): If True, the XML output will be formatted with indentation. Returns: str: The XML representation of the HTML. Raises: ValueError: If no HTML string is loaded. RuntimeError: If there's an error during HTML parsing or XML conversion. \"\"\" if not self . _html_string : raise ValueError ( \"No HTML string loaded. Use load_html() first.\" ) # Ensure HTML is parsed if self . _parsed_soup is None : self . _parse_html () # Create a dummy root element for the XML tree if HTML has multiple top-level elements # or if we want a consistent root. # In a real framework, you might decide on a specific root element like <document> or <template>. self . _xml_root = ET . Element ( \"root\" ) # Using 'root' as a generic container # Iterate through the top-level children of the parsed HTML body # or the entire soup if no body is found (e.g., for fragments) if self . _parsed_soup . body : elements_to_convert = self . _parsed_soup . body . contents else : # Handle cases where HTML might be a fragment without <body> elements_to_convert = self . _parsed_soup . contents for element in elements_to_convert : if isinstance ( element , Tag ): self . _build_xml_element ( element , self . _xml_root ) elif isinstance ( element , NavigableString ): text = str ( element ) . strip () if text : # If top-level text, add it to the root's text or create a text element if self . _xml_root . text is None : self . _xml_root . text = text else : self . _xml_root . text += text # Append if text already exists # Convert ElementTree to string if pretty_print : # Use minidom for pretty printing as ET's tostring is basic rough_string = ET . tostring ( self . _xml_root , \"utf-8\" ) reparsed = minidom . parseString ( rough_string ) return reparsed . toprettyxml ( indent = \" \" ) else : return ET . tostring ( self . _xml_root , encoding = \"unicode\" )","title":"to_xml"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.validate_xml","text":"Placeholder for XML validation (e.g., against an XSD schema). In a real framework, this would involve more complex logic. Returns: bool ( bool ) \u2013 True if XML is valid (conceptually), False otherwise. Source code in src\\probo\\xml\\xml.py 191 192 193 194 195 196 197 198 199 200 201 202 203 def validate_xml ( self ) -> bool : \"\"\" Placeholder for XML validation (e.g., against an XSD schema). In a real framework, this would involve more complex logic. Returns: bool: True if XML is valid (conceptually), False otherwise. \"\"\" if self . _xml_root is None : print ( \"Warning: No XML generated yet to validate.\" ) return False # For demonstration, we'll just check if it's not empty return len ( self . _xml_root ) > 0 # Simple check if root has children","title":"validate_xml"},{"location":"reference/probo/xml/xml/#probo.xml.xml.HtmlToXmlConverter.with_data","text":"Sets the data context for rendering HTML templates. Parameters: data ( dict ) \u2013 A dictionary of data to be used for templating. Returns: HtmlToXmlConverter ( HtmlToXmlConverter ) \u2013 The instance of the converter for chaining. Source code in src\\probo\\xml\\xml.py 48 49 50 51 52 53 54 55 56 57 58 59 def with_data ( self , data : dict ) -> \"HtmlToXmlConverter\" : \"\"\" Sets the data context for rendering HTML templates. Args: data (dict): A dictionary of data to be used for templating. Returns: HtmlToXmlConverter: The instance of the converter for chaining. \"\"\" self . _data_context = data return self","title":"with_data"}]}